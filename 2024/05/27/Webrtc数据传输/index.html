<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc数据传输 | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc数据传输
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">5月 27, 2024&nbsp;&nbsp;18:14:48</a>
                          </span>
                          
                            
                  </div>
                  
              </header>

              <div class="post-content">
                <h1 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h1><h2 id="RTP构造与发送"><a href="#RTP构造与发送" class="headerlink" title="RTP构造与发送"></a>RTP构造与发送</h2><pre><code>// 发送端发送RTP包
//入队pacer报文
RTPSenderVideo::SendVideo----视频帧组包成RTP报文
RTPSenderVideo::LogAndSendToNetwork
RTPSender::EnqueuePackets
TaskQueuePacedSender::EnqueuePackets
PacingController::EnqueuePacket
</code></pre><p>  // pacer出队发送<br>    TaskQueuePacedSender::MaybeProcessPackets<br>  → PacingController::ProcessPackets<br>    PacketRouter::SendPacket // 发送数据<br>  → ModuleRtpRtcpImpl2::TrySendPacket<br>  → RtpSenderEgress::SendPacket<br>    RtpSenderEgress::CompleteSendPacket<br>  → RtpSenderEgress::SendPacketToNetwork<br>  → MediaChannelUtil::TransportForMediaChannels::SendRtp<br>  → MediaChannelUtil::TransportForMediaChannels::DoSendPacket</p>
<h3 id="RTP发送"><a href="#RTP发送" class="headerlink" title="RTP发送"></a>RTP发送</h3><h2 id="twcc数据的构造传输处理"><a href="#twcc数据的构造传输处理" class="headerlink" title="twcc数据的构造传输处理"></a>twcc数据的构造传输处理</h2><h3 id="发送端构造发送RTP报文"><a href="#发送端构造发送RTP报文" class="headerlink" title="发送端构造发送RTP报文"></a>发送端构造发送RTP报文</h3><p><code>PacketRouter::SendPacket</code>函数在发送packet之前为每个带有TWCC扩展的RTP包头设置对应的TransportSequenceNumber，然后进行发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PacketRouter::SendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> PacedPacketInfo&amp; cluster_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 设置RTP包头的TWCC序列号</span></span><br><span class="line">  <span class="type">bool</span> assign_transport_sequence_number =</span><br><span class="line">      packet-&gt;<span class="built_in">HasExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="keyword">if</span> (assign_transport_sequence_number) &#123;</span><br><span class="line">    packet-&gt;<span class="built_in">SetExtension</span>&lt;TransportSequenceNumber&gt;((transport_seq_ + <span class="number">1</span>) &amp;</span><br><span class="line">                                                  <span class="number">0xFFFF</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ssrc = packet-&gt;<span class="built_in">Ssrc</span>();</span><br><span class="line">  <span class="keyword">auto</span> it = send_modules_map_.<span class="built_in">find</span>(ssrc);</span><br><span class="line">  <span class="keyword">if</span> (it == send_modules_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Failed to send packet, matching RTP module not found &quot;</span></span><br><span class="line">           <span class="string">&quot;or transport error. SSRC = &quot;</span></span><br><span class="line">        &lt;&lt; packet-&gt;<span class="built_in">Ssrc</span>() &lt;&lt; <span class="string">&quot;, sequence number &quot;</span> &lt;&lt; packet-&gt;<span class="built_in">SequenceNumber</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RtpRtcpInterface* rtp_module = it-&gt;second;</span><br><span class="line">  <span class="comment">// ModuleRtpRtcpImpl2::TrySendPacket尝试发送RTP数据包</span></span><br><span class="line">  <span class="keyword">if</span> (!rtp_module-&gt;<span class="built_in">TrySendPacket</span>(std::<span class="built_in">move</span>(packet), cluster_info)) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Failed to send packet, rejected by RTP module.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  modules_used_in_current_batch_.<span class="built_in">insert</span>(rtp_module);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sending succeeded.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleRtpRtcpImpl2::TrySendPacket</code>用于发送RTP数据包，首先检查是否可以发送媒体数据，以及是否可以在媒体SSRC上发送填充数据，然后进行序列化，并最终将RtpPacketToSend packet传递给RtpSenderEgress::SendPacket函数发送RTP数据包，并处理一些发送前的准备工作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ModuleRtpRtcpImpl2::TrySendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(rtp_sender_);</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;rtp_sender_-&gt;sequencing_checker);</span><br><span class="line">  <span class="comment">// 不在发送媒体数据</span></span><br><span class="line">  <span class="keyword">if</span> (!rtp_sender_-&gt;packet_generator.<span class="built_in">SendingMedia</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据包是填充数据，并且SSRC与媒体数据的SSRC相同，但不能在媒体SSRC上发送填充数据</span></span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kPadding &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">Ssrc</span>() == rtp_sender_-&gt;packet_generator.<span class="built_in">SSRC</span>() &amp;&amp;</span><br><span class="line">      !rtp_sender_-&gt;sequencer.<span class="built_in">CanSendPaddingOnMediaSsrc</span>()) &#123;</span><br><span class="line">    <span class="comment">// 新的媒体数据包抢占了这个生成的填充数据包，丢弃它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查是否是FEC数据，并且SSRC与FEC的SSRC相同</span></span><br><span class="line">  <span class="type">bool</span> is_flexfec =</span><br><span class="line">      packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kForwardErrorCorrection &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">Ssrc</span>() == rtp_sender_-&gt;packet_generator.<span class="built_in">FlexfecSsrc</span>();</span><br><span class="line">  <span class="comment">// 如果不是FEC数据，进行序列化</span></span><br><span class="line">  <span class="keyword">if</span> (!is_flexfec) &#123;</span><br><span class="line">    rtp_sender_-&gt;sequencer.<span class="built_in">Sequence</span>(*packet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转发给RtpSenderEgress模块</span></span><br><span class="line">  <span class="comment">// RtpSenderEgress::SendPacket发送数据包</span></span><br><span class="line">  rtp_sender_-&gt;packet_sender.<span class="built_in">SendPacket</span>(std::<span class="built_in">move</span>(packet), pacing_info);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleRtpRtcpImpl2::TrySendPacket</code>函数将数据包加入到待发送列表中，或直接发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::SendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 创建一个待发送的数据包</span></span><br><span class="line">  <span class="keyword">auto</span> compound_packet = Packet&#123;std::<span class="built_in">move</span>(packet), pacing_info, now&#125;;</span><br><span class="line">  <span class="comment">// 如果启用了数据包批量发送，并且不是音频</span></span><br><span class="line">  <span class="keyword">if</span> (enable_send_packet_batching_ &amp;&amp; !is_audio_) &#123;</span><br><span class="line">    <span class="comment">// 将数据包添加到待发送的数据包列表中，用于Pacing发送</span></span><br><span class="line">    <span class="comment">// 实际在发送时，会在RtpSenderEgress::OnBatchComplete函数中遍历packets_to_send_</span></span><br><span class="line">    <span class="comment">// 并调用CompleteSendPacket函数进行发送</span></span><br><span class="line">    packets_to_send_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(compound_packet));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接发送数据包，会处理TransportSequenceNumber</span></span><br><span class="line">    <span class="built_in">CompleteSendPacket</span>(compound_packet, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpSenderEgress::CompleteSendPacket</code>处理实际的数据包发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::CompleteSendPacket</span><span class="params">(<span class="type">const</span> Packet&amp; compound_packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> last_in_batch)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(worker_queue_);</span><br><span class="line">  <span class="keyword">auto</span>&amp; [packet, pacing_info, now] = compound_packet;</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(packet);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_media = packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kAudio ||</span><br><span class="line">                        packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kVideo;</span><br><span class="line">  <span class="comment">// 数据包的参数</span></span><br><span class="line">  PacketOptions options;</span><br><span class="line">  options.included_in_allocation = force_part_of_allocation_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下游代码实际上使用这个标志来区分媒体和其他所有内容</span></span><br><span class="line">  options.is_retransmit = !is_media;</span><br><span class="line">  <span class="comment">// 提取数据包的TransportSequenceNumber生成feedback包</span></span><br><span class="line">  absl::optional&lt;<span class="type">uint16_t</span>&gt; packet_id =</span><br><span class="line">      packet-&gt;<span class="built_in">GetExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="comment">//启用了TWCC的扩展</span></span><br><span class="line">  <span class="keyword">if</span> (packet_id.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    options.packet_id = *packet_id;</span><br><span class="line">    options.included_in_feedback = <span class="literal">true</span>;</span><br><span class="line">    options.included_in_allocation = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 将TransportSequenceNumber转发给TransportFeedbackObserver模块</span></span><br><span class="line">    <span class="comment">// 将一些信息添加到传输反馈中，用于进行TWCC的反馈</span></span><br><span class="line">    <span class="built_in">AddPacketToTransportFeedback</span>(*packet_id, *packet, pacing_info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  options.additional_data = packet-&gt;<span class="built_in">additional_data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果数据包不是填充数据或重传数据，并且有发送数据包的观察者，并且有捕获时间</span></span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;<span class="built_in">packet_type</span>() != RtpPacketMediaType::kPadding &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">packet_type</span>() != RtpPacketMediaType::kRetransmission &amp;&amp;</span><br><span class="line">      send_packet_observer_ != <span class="literal">nullptr</span> &amp;&amp; packet-&gt;<span class="built_in">capture_time</span>().<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 发送数据包</span></span><br><span class="line">    send_packet_observer_-&gt;<span class="built_in">OnSendPacket</span>(packet_id, packet-&gt;<span class="built_in">capture_time</span>(),</span><br><span class="line">                                        packet-&gt;<span class="built_in">Ssrc</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置是否可以批量发送和是否是批量中的最后一个包</span></span><br><span class="line">  options.batchable = enable_send_packet_batching_ &amp;&amp; !is_audio_;</span><br><span class="line">  options.last_packet_in_batch = last_in_batch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往网络发送RTP数据包</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> send_success = <span class="built_in">SendPacketToNetwork</span>(*packet, options, pacing_info);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无论发送是否成功，都将数据包放入重传历史记录或更新待发送状态</span></span><br><span class="line">  <span class="keyword">if</span> (is_media &amp;&amp; packet-&gt;<span class="built_in">allow_retransmission</span>()) &#123;</span><br><span class="line">    packet_history_-&gt;<span class="built_in">PutRtpPacket</span>(std::<span class="built_in">make_unique</span>&lt;RtpPacketToSend&gt;(*packet),</span><br><span class="line">                                  now);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;<span class="built_in">retransmitted_sequence_number</span>()) &#123;</span><br><span class="line">    packet_history_-&gt;<span class="built_in">MarkPacketAsSent</span>(*packet-&gt;<span class="built_in">retransmitted_sequence_number</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送成功</span></span><br><span class="line">  <span class="keyword">if</span> (send_success) &#123;</span><br><span class="line">    media_has_been_sent_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 更新RTP统计信息</span></span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(packet-&gt;<span class="built_in">packet_type</span>().<span class="built_in">has_value</span>());</span><br><span class="line">    RtpPacketMediaType packet_type = *packet-&gt;<span class="built_in">packet_type</span>();</span><br><span class="line">    <span class="function">RtpPacketCounter <span class="title">counter</span><span class="params">(*packet)</span></span>;</span><br><span class="line">    <span class="comment">// RtpSenderEgress::UpdateRtpStats实时更新发送数据的码率</span></span><br><span class="line">    <span class="built_in">UpdateRtpStats</span>(now, packet-&gt;<span class="built_in">Ssrc</span>(), packet_type, std::<span class="built_in">move</span>(counter),</span><br><span class="line">                   packet-&gt;<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpSenderEgress::AddPacketToTransportFeedback</code>函数构造<code>RtpPacketSendInfo packet_info</code>记录当前RTP报的信息，如Sequence Number、Transport Sequence Number、Packet Size等，其添加到传输反馈中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::AddPacketToTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> packet_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RtpPacketToSend&amp; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传输反馈</span></span><br><span class="line">  <span class="keyword">if</span> (transport_feedback_observer_) &#123;</span><br><span class="line">    <span class="comment">// 构造packet_info，填充发送的RTP包信息，包括传输序号、RTP时间戳、长度、调度信息等</span></span><br><span class="line">    RtpPacketSendInfo packet_info;</span><br><span class="line">    <span class="comment">// 扩展的sequence_number</span></span><br><span class="line">    packet_info.transport_sequence_number = packet_id;</span><br><span class="line">    packet_info.rtp_timestamp = packet.<span class="built_in">Timestamp</span>();</span><br><span class="line">    packet_info.length = packet.<span class="built_in">size</span>();</span><br><span class="line">    packet_info.pacing_info = pacing_info;</span><br><span class="line">    packet_info.packet_type = packet.<span class="built_in">packet_type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数据包类型设置不同的信息</span></span><br><span class="line">    <span class="keyword">switch</span> (*packet_info.packet_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kAudio:</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kVideo:</span><br><span class="line">        packet_info.media_ssrc = ssrc_;</span><br><span class="line">        packet_info.rtp_sequence_number = packet.<span class="built_in">SequenceNumber</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kRetransmission:</span><br><span class="line">        <span class="comment">// 重传包填充原始媒体包的SSRC和序号</span></span><br><span class="line">        packet_info.media_ssrc = ssrc_;</span><br><span class="line">        packet_info.rtp_sequence_number =</span><br><span class="line">            *packet.<span class="built_in">retransmitted_sequence_number</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kPadding:</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kForwardErrorCorrection:</span><br><span class="line">        <span class="comment">// We&#x27;re not interested in feedback about these packets being received</span></span><br><span class="line">        <span class="comment">// or lost.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RtpTransportControllerSend继承TransportFeedbackObserver，</span></span><br><span class="line">    <span class="comment">// 依赖于TransportFeedbackAdapter类。</span></span><br><span class="line">    <span class="comment">// 有数据包要进行发送，transport_feedback_observer_生成数据包。实际调用</span></span><br><span class="line">    <span class="comment">// RtpTransportControllerSend::OnAddPacket函数添加feedback包</span></span><br><span class="line">    transport_feedback_observer_-&gt;<span class="built_in">OnAddPacket</span>(packet_info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::OnAddPacket</code>收到RtpPacketSendInfo反馈，交给<code>TransportFeedbackAdapter</code>模块进行处理:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnAddPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RtpPacketSendInfo&amp; packet_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  Timestamp creation_time =</span><br><span class="line">      Timestamp::<span class="built_in">Millis</span>(env_.<span class="built_in">clock</span>().<span class="built_in">TimeInMilliseconds</span>());</span><br><span class="line">  <span class="comment">// 将数据包添加到反馈解复用器</span></span><br><span class="line">  feedback_demuxer_.<span class="built_in">AddPacket</span>(packet_info);</span><br><span class="line">  <span class="comment">// 给TransportFeedbackAdapter::AddPacket添加feedback</span></span><br><span class="line">  transport_feedback_adapter_.<span class="built_in">AddPacket</span>(</span><br><span class="line">      packet_info, transport_overhead_bytes_per_packet_, creation_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::AddPacket</code>利用<code>RtpSenderEgress::AddPacketToTransportFeedback</code>中创建的<code>RtpPacketSendInfo packet_info</code>创建<code>PacketFeedback packet</code>，然后以 <TransportSequenceNumber,PacketFeedback> 插入到 history<em>容器中。PacketFeedback记录的信息是创建时间、TransportSequenceNumber、待发送的RTP包大小、SSRC等信息，等待feedback的时候计算数据。**history</em> 是TransportFeedbackAdapter类成员变量std::map<int64_t, PacketFeedback> history_**。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransportFeedbackAdapter::AddPacket</span><span class="params">(<span class="type">const</span> RtpPacketSendInfo&amp; packet_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> overhead_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Timestamp creation_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 生成PacketFeedback包</span></span><br><span class="line">  PacketFeedback packet;</span><br><span class="line">  packet.creation_time = creation_time;</span><br><span class="line">  packet.sent.sequence_number =</span><br><span class="line">      seq_num_unwrapper_.<span class="built_in">Unwrap</span>(packet_info.transport_sequence_number);</span><br><span class="line">  packet.sent.size = DataSize::<span class="built_in">Bytes</span>(packet_info.length + overhead_bytes);</span><br><span class="line">  packet.sent.audio = packet_info.packet_type == RtpPacketMediaType::kAudio;</span><br><span class="line">  packet.network_route = network_route_;</span><br><span class="line">  packet.sent.pacing_info = packet_info.pacing_info;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 历史记录中的数据包已经超出了发送时间历史窗口6s就进行删除</span></span><br><span class="line">  <span class="keyword">while</span> (!history_.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">         creation_time - history_.<span class="built_in">begin</span>()-&gt;second.creation_time &gt;</span><br><span class="line">             kSendTimeHistoryWindow) &#123;</span><br><span class="line">    <span class="comment">// TODO(sprang): Warn if erasing (too many) old items?</span></span><br><span class="line">    <span class="keyword">if</span> (history_.<span class="built_in">begin</span>()-&gt;second.sent.sequence_number &gt; last_ack_seq_num_)</span><br><span class="line">      in_flight_.<span class="built_in">RemoveInFlightPacketBytes</span>(history_.<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line">    history_.<span class="built_in">erase</span>(history_.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以transport_sequence_number和PacketFeedback为key-valiue，存入history_中</span></span><br><span class="line">  history_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(packet.sent.sequence_number, packet));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储到history_中已经完成把TWCC扩展的RTP包经过网络发送前的处理流程。</p>
<p><code>SendPacketToNetwork</code>函数通过网络发送RTP数据包。</p>
<h3 id="发送RTP包后的处理"><a href="#发送RTP包后的处理" class="headerlink" title="发送RTP包后的处理"></a>发送RTP包后的处理</h3><p>消息经Call模块，到达worker线程，最终反馈到RtpTransportControllerSend模块，接下来处理已发送的数据包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当一个数据包被发送时，OnSentPacket函数会被调用</span></span><br><span class="line">  <span class="comment">// 通常在网络线程上调用</span></span><br><span class="line">  <span class="comment">// 如果当前线程不是任务队列所在的线程</span></span><br><span class="line">  <span class="keyword">if</span> (TaskQueueBase::<span class="built_in">Current</span>() != task_queue_) &#123;</span><br><span class="line">    <span class="comment">// 在任务队列上异步执行RtpTransportControllerSend::ProcessSentPacket函数</span></span><br><span class="line">    task_queue_-&gt;<span class="built_in">PostTask</span>(<span class="built_in">SafeTask</span>(safety_.<span class="built_in">flag</span>(), [<span class="keyword">this</span>, sent_packet]() &#123;</span><br><span class="line">      <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">      <span class="comment">// 打包sent_packet</span></span><br><span class="line">      <span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前的任务队列就是task_queue_，直接处理已发送的数据包</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::ProcessSentPacket</code>处理已发送的RTP包:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::ProcessSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// 1. TransportFeedbackAdapter::ProcessSentPacket函数</span></span><br><span class="line">  <span class="comment">// 从发送的报文获取SentPacket消息</span></span><br><span class="line">  absl::optional&lt;SentPacket&gt; packet_msg =</span><br><span class="line">      transport_feedback_adapter_.<span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">  <span class="keyword">if</span> (!packet_msg)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 有反馈信息</span></span><br><span class="line">  <span class="comment">// 获取拥塞状态更新</span></span><br><span class="line">  <span class="keyword">auto</span> congestion_update = <span class="built_in">GetCongestedStateUpdate</span>();</span><br><span class="line">  NetworkControlUpdate control_update;</span><br><span class="line">  <span class="comment">// 发送反馈SentPacket包作用到GoogCcNetworkController模块</span></span><br><span class="line">  <span class="comment">// 2. GoogCcNetworkController::OnSentPacket函数</span></span><br><span class="line">  <span class="keyword">if</span> (controller_)</span><br><span class="line">    control_update = controller_-&gt;<span class="built_in">OnSentPacket</span>(*packet_msg);</span><br><span class="line">  <span class="comment">// 如果没有拥塞状态更新和控制更新，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!congestion_update &amp;&amp; !control_update.<span class="built_in">has_updates</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 3. RtpTransportControllerSend::ProcessSentPacketUpdates 处理发送的数据包更新</span></span><br><span class="line">  <span class="built_in">ProcessSentPacketUpdates</span>(std::<span class="built_in">move</span>(control_update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::ProcessSentPacket</code>保存了包发送时的相关信息，保存在其history_中，根据数据包是否被包含在反馈中，以及是否被包含在分配中，来更新数据包的发送时间、在途数据的大小、未跟踪的数据大小等统计信息，最终得到<code>SentPacket</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;SentPacket&gt; <span class="title">TransportFeedbackAdapter::ProcessSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> send_time = Timestamp::<span class="built_in">Millis</span>(sent_packet.send_time_ms);</span><br><span class="line">  <span class="comment">// 数据包被包含在反馈中，或者数据包的ID不为-1</span></span><br><span class="line">  <span class="keyword">if</span> (sent_packet.info.included_in_feedback || sent_packet.packet_id != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 数据包的序列号</span></span><br><span class="line">    <span class="type">int64_t</span> unwrapped_seq_num =</span><br><span class="line">        seq_num_unwrapper_.<span class="built_in">Unwrap</span>(sent_packet.packet_id);</span><br><span class="line">    <span class="comment">// 根据已发送包的信息，根据seq number进行查询history_，</span></span><br><span class="line">    <span class="comment">// 查询到后，对里面的数据进行更新，主要是更新其发送时间</span></span><br><span class="line">    <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(unwrapped_seq_num);</span><br><span class="line">    <span class="comment">// 对SentPacket it-&gt;second.sent赋值，主要包含实际发送数据的大小、</span></span><br><span class="line">    <span class="comment">// 发送时间、transport seq number、以及data_in_flight</span></span><br><span class="line">    <span class="keyword">if</span> (it != history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 数据包的发送时间已经被设置，这是一个重传的数据包</span></span><br><span class="line">      <span class="type">bool</span> packet_retransmit = it-&gt;second.sent.send_time.<span class="built_in">IsFinite</span>();</span><br><span class="line">      <span class="comment">// 更新数据包的发送时间</span></span><br><span class="line">      it-&gt;second.sent.send_time = send_time;</span><br><span class="line">      <span class="comment">// 更新最后的发送时间</span></span><br><span class="line">      last_send_time_ = std::<span class="built_in">max</span>(last_send_time_, send_time);</span><br><span class="line">      <span class="comment">// 有未跟踪的数据,加入先前未ACK的数据量</span></span><br><span class="line">      <span class="keyword">if</span> (!pending_untracked_size_.<span class="built_in">IsZero</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_time &lt; last_untracked_send_time_)</span><br><span class="line">          <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;appending acknowledged data for out of order packet. (Diff: &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">ToString</span>(last_untracked_send_time_ - send_time) &lt;&lt; <span class="string">&quot; ms.)&quot;</span>;</span><br><span class="line">        it-&gt;second.sent.prior_unacked_data += pending_untracked_size_;</span><br><span class="line">        pending_untracked_size_ = DataSize::<span class="built_in">Zero</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是一个重传的数据包</span></span><br><span class="line">      <span class="keyword">if</span> (!packet_retransmit) &#123;</span><br><span class="line">        <span class="comment">// 数据包的序列号大于最后确认的序列号，添加在途数据包的字节</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second.sent.sequence_number &gt; last_ack_seq_num_)</span><br><span class="line">          <span class="comment">// 将已发送的RTP包中的实际palyload大小记录到in_flight_data_ 的map中，</span></span><br><span class="line">          <span class="comment">// 进行发送字节统计，最终会作用到pacer模块</span></span><br><span class="line">          in_flight_.<span class="built_in">AddInFlightPacketBytes</span>(it-&gt;second);</span><br><span class="line">        <span class="comment">// data_in_flight描述6s的统计窗口内，网络中一共有多少字节的数据在发送，告诉pacer模块</span></span><br><span class="line">        it-&gt;second.sent.data_in_flight = <span class="built_in">GetOutstandingData</span>();</span><br><span class="line">        <span class="comment">// 返回SentPacket信息</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.sent;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sent_packet.info.included_in_allocation) &#123;</span><br><span class="line">    <span class="comment">// 数据包被包含在分配中</span></span><br><span class="line">    <span class="comment">// 忽略序号小于最后发送时间的未跟踪数据</span></span><br><span class="line">    <span class="keyword">if</span> (send_time &lt; last_send_time_) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;ignoring untracked data for out of order packet.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累积未跟踪的数据量</span></span><br><span class="line">    pending_untracked_size_ +=</span><br><span class="line">        DataSize::<span class="built_in">Bytes</span>(sent_packet.info.packet_size_bytes);</span><br><span class="line">    <span class="comment">// 更新最后未跟踪时间</span></span><br><span class="line">    last_untracked_send_time_ = std::<span class="built_in">max</span>(last_untracked_send_time_, send_time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AddInFlightPacketBytes</code>函数在每次发送数据包之后进行大小的累加，将每次发送的多少字节填入到in<em>flight_data</em>容器中，进行发送字节统计，最终会作用到pacer模块。<code>RemoveInFlightPacketBytes</code>函数用于seq number包已经收到接收端发回来的twcc feedback报告后，将对应seq number的包的大小计数从in<em>flight_data</em>容器中移除；同时用于用于<code>TransportFeedbackAdapter::AddPacket</code>函数中移除超时的（6s）的数据包。<br>综上，in<em>flight_data</em>容器描述的最大6s时间窗口内，总共有多少数据正在网络中发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每次发送的多少字节填入到in_flight_data_容器中，进行发送字节统计，最终会作用到pacer模块。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InFlightBytesTracker::AddInFlightPacketBytes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketFeedback&amp; packet)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(packet.sent.send_time.<span class="built_in">IsFinite</span>());</span><br><span class="line">  <span class="keyword">auto</span> it = in_flight_data_.<span class="built_in">find</span>(packet.network_route);</span><br><span class="line">  <span class="keyword">if</span> (it != in_flight_data_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    it-&gt;second += packet.sent.size;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    in_flight_data_.<span class="built_in">insert</span>(&#123;packet.network_route, packet.sent.size&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在每次接收到接收端发送回来的twcc feedback报告后根据收到的seq number 将对应seq number的包的大小计数从in_flight_bytes_中进行移除，</span></span><br><span class="line"><span class="comment">// 同时在发送数据包的时候在TransportFeedbackAdapter模块AddPacket函数中会判断发送包的生命周期，如果超时（大于6s）进行移除。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InFlightBytesTracker::RemoveInFlightPacketBytes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketFeedback&amp; packet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet.sent.send_time.<span class="built_in">IsInfinite</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">auto</span> it = in_flight_data_.<span class="built_in">find</span>(packet.network_route);</span><br><span class="line">  <span class="keyword">if</span> (it != in_flight_data_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_DCHECK_GE</span>(it-&gt;second, packet.sent.size);</span><br><span class="line">    it-&gt;second -= packet.sent.size;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second.<span class="built_in">IsZero</span>())</span><br><span class="line">      in_flight_data_.<span class="built_in">erase</span>(it);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DataSize <span class="title">InFlightBytesTracker::GetOutstandingData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::NetworkRoute&amp; network_route)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = in_flight_data_.<span class="built_in">find</span>(network_route);</span><br><span class="line">  <span class="keyword">if</span> (it != in_flight_data_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DataSize::<span class="built_in">Zero</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>GoogCcNetworkController::OnSentPacket</code>将发送反馈的SentPacket包作用到GoogCcNetworkController模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SentPacket sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 网络受限会导致会对AlrDetector模块中的受限的起始时间alr_started_time_ms_赋值。</span></span><br><span class="line">  <span class="comment">// 其原理是通过预设的码率和预设的带宽利用率，以及每次发送数据的时间间隔，</span></span><br><span class="line">  <span class="comment">// 然后配合本次实际发送的字节数进行比较，比较预算应该发送多少字节的数据</span></span><br><span class="line">  <span class="comment">// 和实际发送了多少字节的数据的比例，来判断当前发送是否充分利用网络带宽</span></span><br><span class="line">  <span class="comment">// 原理参考 https://www.jianshu.com/p/55e5246f12b9</span></span><br><span class="line">  <span class="comment">// AlrDetector::OnBytesSent回调函数调用，更新发送数据的大小和时间，检测是否处于ALR状态</span></span><br><span class="line">  alr_detector_-&gt;<span class="built_in">OnBytesSent</span>(sent_packet.size.<span class="built_in">bytes</span>(),</span><br><span class="line">                             sent_packet.send_time.<span class="built_in">ms</span>());</span><br><span class="line">  <span class="comment">// 将探测结果设置到该模块，带宽利用率高的情况下，探测结果可能会没有值</span></span><br><span class="line">  acknowledged_bitrate_estimator_-&gt;<span class="built_in">SetAlr</span>(</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>().<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_packet_sent_) &#123;</span><br><span class="line">    first_packet_sent_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始化反馈时间为发送时间，以允许在收到第一个反馈之前估计RTT</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdatePropagationRtt</span>(sent_packet.send_time,</span><br><span class="line">                                                TimeDelta::<span class="built_in">Zero</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录本次发送的包信息，为基于丢包的动态码率估计提供入参信息</span></span><br><span class="line">  <span class="comment">// 基于丢包的带宽估计参考 https://www.jianshu.com/p/a3310e5d3768</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">OnSentPacket</span>(sent_packet);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 触发码率估计</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateOutstandingData</span>(</span><br><span class="line">        sent_packet.data_in_flight.<span class="built_in">bytes</span>());</span><br><span class="line">    NetworkControlUpdate update;</span><br><span class="line">    <span class="comment">// 可能触发网络变化事件</span></span><br><span class="line">    <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, sent_packet.send_time);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::ProcessSentPacketUpdates</code>进行发包后的更新：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTC_RUN_ON(task_queue_)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::ProcessSentPacketUpdates</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkControlUpdate updates)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// 作用到pacer并更新拥塞状态</span></span><br><span class="line">  <span class="built_in">UpdateCongestedState</span>();</span><br><span class="line">  <span class="keyword">if</span> (controller_) &#123;</span><br><span class="line">    <span class="comment">// 进行码率更新</span></span><br><span class="line">    <span class="built_in">PostUpdates</span>(std::<span class="built_in">move</span>(updates));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有在以下情况下更新未完成的数据：</span></span><br><span class="line">  <span class="comment">// 1. 使用了数据包反馈。</span></span><br><span class="line">  <span class="comment">// 2. 数据包尚未收到确认。</span></span><br><span class="line">  <span class="comment">// 3. 不是先前数据包的重传。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::UpdateCongestedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断网络是否拥塞并设置拥塞状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> update = <span class="built_in">GetCongestedStateUpdate</span>()) &#123;</span><br><span class="line">    is_congested_ = update.<span class="built_in">value</span>();</span><br><span class="line">    <span class="comment">// 更新到pacer模块</span></span><br><span class="line">    pacer_.<span class="built_in">SetCongested</span>(update.<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::optional&lt;<span class="type">bool</span>&gt; <span class="title">RtpTransportControllerSend::GetCongestedStateUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据当前网络中实际在发送的数据大小和拥塞窗口上限做比较，发生拥塞则会取消本次发送</span></span><br><span class="line">  <span class="comment">// congestion_window_size_是GoogCcNetworkController带宽估计得到的网络拥塞窗口上限，</span></span><br><span class="line">  <span class="comment">// 通过RtpTransportControllerSend::PostUpdates()函数配置到pacer模块</span></span><br><span class="line">  <span class="type">bool</span> congested = transport_feedback_adapter_.<span class="built_in">GetOutstandingData</span>() &gt;=</span><br><span class="line">                   congestion_window_size_;</span><br><span class="line">  <span class="keyword">if</span> (congested != is_congested_)</span><br><span class="line">    <span class="keyword">return</span> congested;</span><br><span class="line">  <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="接收端构造发送twcc-feedback报文"><a href="#接收端构造发送twcc-feedback报文" class="headerlink" title="接收端构造发送twcc feedback报文"></a>接收端构造发送twcc feedback报文</h3><p>接收端接收到带TWCC协议的rtp包后的处理，主要是生成基于TWCC的RTCP报文，并定时将报文发送给发送端。</p>
<p><strong>接收端</strong>在<code>ReceiveSideCongestionController::OnReceivedPacket</code>函数中根据RTP包是否有<code>transport-wide sequence number</code>判断是否是 REMB-GCC 还是 TFB-GCC。有序列号，会在RemoteEstimatorProxy中处理RTP包的到达时间，构造Transport-cc报文，反馈给发送端。大概函数调用流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReceiveSideCongestionController::OnReceivedPacket</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::IncomingPacket</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::Process</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::SendPeriodicFeedbacks</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::BuildFeedbackPacket</span><br></pre></td></tr></table></figure>
<p><code>PacketArrivalTimeMap::AddPacket</code>函数记录RTP包到达的时间，存到 <sequence_number, arrival_time> 的映射队列。<code>RemoteEstimatorProxy</code>是进行Sendside-BWE在接收端的代理类，其中的<code>Process</code>函数以100ms为发送周期发送TransportCC报文</p>
<p>RemoteEstimatorProxy::IncomingPacket中，如果RTP包带有TransportSequenceNumber扩展，会记录该RTP包的到达时间，然后添加到构造的Transport-cc报文中。</p>
<p>发送周期会根据当前码率动态调整，其取值范围在[50ms, 250ms]之间，其本身可用的发送码率为当前可用码率的5%。</p>
<p>周期发送RTCP包的函数调用为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RemoteEstimatorProxy::Process</span><br><span class="line">-&gt;RemoteEstimatorProxy::SendPeriodicFeedbacks</span><br><span class="line">-&gt;RemoteEstimatorProxy::MaybeBuildFeedbackPacket</span><br><span class="line">-&gt;TransportFeedback::AddReceivedPacket</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="RTP接收与解析"><a href="#RTP接收与解析" class="headerlink" title="RTP接收与解析"></a>RTP接收与解析</h2><h1 id="RTCP"><a href="#RTCP" class="headerlink" title="RTCP"></a>RTCP</h1><p>RTCP负责QOS相关的内容，通常由RR, SR, SDES, BYE等，RTC3550。RTCP报文的数据源来自RTP报文发送和接收时的统计信息。</p>
<p>在WebRTC内部，RTCP报文的发送采取周期性发送和及时发送相结合的策略：ModuleProcess线程周期性发送RTCP报文；而RtpSender则在每次发送RTP报文之前都判断是否需要发送RTCP报文；另外在接收端码率估计模块构造出REMB报文后，通过设置超时让ModuleProcess模块立即发送RTCP报文。</p>
<h2 id="RTCP构造与发送"><a href="#RTCP构造与发送" class="headerlink" title="RTCP构造与发送"></a>RTCP构造与发送</h2><p>  // 发送RTCP包过程<br>  RTCPSender::SendRTCP根据不同Feedback信息发送不同的RTCP包<br>  PrepareReport确定发包类型<br>  RTCPSender::ComputeCompoundRTCPPacket 构造不同的RTCP包，然后AppendPacket添加到容器中，接下来进行序列化发送</p>
<h2 id="RTCP接收与解析"><a href="#RTCP接收与解析" class="headerlink" title="RTCP接收与解析"></a>RTCP接收与解析</h2><p>数据经过网络接收到达Call对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Call::DeliverRtcpPacket</span><span class="params">(rtc::CopyOnWriteBuffer packet)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(worker_thread_);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(<span class="built_in">IsRtcpPacket</span>(packet));</span><br><span class="line">  <span class="built_in">TRACE_EVENT0</span>(<span class="string">&quot;webrtc&quot;</span>, <span class="string">&quot;Call::DeliverRtcp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  receive_stats_.<span class="built_in">AddReceivedRtcpBytes</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(packet.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="type">bool</span> rtcp_delivered = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  std::set&lt;AudioReceiveStreamImpl*&gt; audio_receive_streams_</span></span><br><span class="line"><span class="comment">      RTC_GUARDED_BY(worker_thread_);</span></span><br><span class="line"><span class="comment">  std::set&lt;VideoReceiveStream2*&gt; video_receive_streams_</span></span><br><span class="line"><span class="comment">      RTC_GUARDED_BY(worker_thread_);</span></span><br><span class="line"><span class="comment">  std::map&lt;uint32_t, AudioSendStream*&gt; audio_send_ssrcs_</span></span><br><span class="line"><span class="comment">      RTC_GUARDED_BY(worker_thread_);</span></span><br><span class="line"><span class="comment">  std::map&lt;uint32_t, VideoSendStream*&gt; video_send_ssrcs_</span></span><br><span class="line"><span class="comment">      RTC_GUARDED_BY(worker_thread_);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (VideoReceiveStream2* stream : video_receive_streams_) &#123;</span><br><span class="line">    <span class="comment">// VideoReceiveStream2::DeliverRtcp</span></span><br><span class="line">    <span class="keyword">if</span> (stream-&gt;<span class="built_in">DeliverRtcp</span>(packet.<span class="built_in">cdata</span>(), packet.<span class="built_in">size</span>()))</span><br><span class="line">      rtcp_delivered = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (AudioReceiveStreamImpl* stream : audio_receive_streams_) &#123;</span><br><span class="line">    stream-&gt;<span class="built_in">DeliverRtcp</span>(packet.<span class="built_in">cdata</span>(), packet.<span class="built_in">size</span>());</span><br><span class="line">    rtcp_delivered = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (VideoSendStream* stream : video_send_streams_) &#123;</span><br><span class="line">    stream-&gt;<span class="built_in">DeliverRtcp</span>(packet.<span class="built_in">cdata</span>(), packet.<span class="built_in">size</span>());</span><br><span class="line">    rtcp_delivered = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : audio_send_ssrcs_) &#123;</span><br><span class="line">    kv.second-&gt;<span class="built_in">DeliverRtcp</span>(packet.<span class="built_in">cdata</span>(), packet.<span class="built_in">size</span>());</span><br><span class="line">    rtcp_delivered = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rtcp_delivered) &#123;</span><br><span class="line">    env_.<span class="built_in">event_log</span>().<span class="built_in">Log</span>(std::<span class="built_in">make_unique</span>&lt;RtcEventRtcpPacketIncoming&gt;(packet));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以视频流为例</p>
<p>  VideoReceiveStream2::DeliverRtcp<br>  RtpVideoStreamReceiver2::DeliverRtcp<br>  ModuleRtpRtcpImpl2::IncomingRtcpPacket<br>  -&gt;RTCPReceiver::IncomingPacket 解析和反馈RTCP报文，根据不同的报文类型进行处理，得到PacketInformation对象<br>  -&gt;RTCPReceiver::TriggerCallbacksFromRtcpPacket 根据PacketInformation对象触发观察者执行各种回调函数进行处理，控制BEW、NACK、SLI等，控制数据的编码、发送和码率等QOS保证，这里是RTCP起作用的地方。</p>
<p>  // 发送端接收Rtcp包带宽估计<br>  -&gt;RtpTransportControllerSend::OnTransportFeedback<br>  -&gt;GoogCcNetworkController::OnTransportPacketsFeedback<br>  -&gt;DelayBasedBwe::IncomingPacketFeedbackVector<br>  -&gt;DelayBasedBwe::IncomingPacketFeedback<br>  -&gt;DelayBasedBwe::MaybeUpdateEstimate</p>
<p>  // 发送端基于丢包的带宽估计<br>  -&gt;RtpTransportControllerSend::OnReport<br>  -&gt;GoogCcNetworkController::OnTransportLossReport<br>  -&gt;SendSideBandwidthEstimation::UpdatePacketsLost<br>  -&gt;SendSideBandwidthEstimation::UpdateEstimate<br>  -&gt;SendSideBandwidthEstimation::UpdateTargetBitrate</p>
<p>  // 发送端带宽估计<br>  ReceiveSideCongestionController::OnReceivedPacket<br>  RemoteBitrateEstimatorAbsSendTime::IncomingPacket<br>  RemoteBitrateEstimatorAbsSendTime::ProcessClusters<br>  InterArrival::ComputeDeltas<br>  OveruseEstimator::Update<br>  OveruseDetector::Detect</p>
<h2 id="接收RTCP的处理"><a href="#接收RTCP的处理" class="headerlink" title="接收RTCP的处理"></a>接收RTCP的处理</h2><p>收到RTCP报文会传给RTCPReceiver，并进行解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::IncomingPacket</span><span class="params">(rtc::ArrayView&lt;<span class="type">const</span> <span class="type">uint8_t</span>&gt; packet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Incoming empty RTCP packet&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PacketInformation packet_information;</span><br><span class="line">  <span class="comment">// RTCPReceiver::ParseCompoundPacket解析rtcp报文，并进行相应的处理</span></span><br><span class="line">  <span class="comment">// RR,SR,SDES, XR, BYE, APP, </span></span><br><span class="line">  <span class="comment">// RTPFB: NACK, TMMBR, TMMBN, Rapid Resync Request, Transport Feedback</span></span><br><span class="line">  <span class="comment">// PSFB: PLI, FIR, AFB</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseCompoundPacket</span>(packet, &amp;packet_information))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 触发不同的回调函数进行处理，控制流媒体数据的编码、发送、码率等，也是RTCP报文起作用的地方</span></span><br><span class="line">  <span class="comment">// 带宽估计转发给RtpTransportControllerSend，作用到GoogCcNetworkController模块</span></span><br><span class="line">  <span class="built_in">TriggerCallbacksFromRtcpPacket</span>(packet_information);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RTCPReceiver::ParseCompoundPacket</code>解析rtcp报文，并进行相应的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RTCPReceiver::ParseCompoundPacket</span><span class="params">(rtc::ArrayView&lt;<span class="type">const</span> <span class="type">uint8_t</span>&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       PacketInformation* packet_information)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;rtcp_receiver_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  CommonHeader rtcp_block;</span><br><span class="line">  <span class="comment">// If a sender report is received but no DLRR, we need to reset the</span></span><br><span class="line">  <span class="comment">// roundTripTime stat according to the standard, see</span></span><br><span class="line">  <span class="comment">// https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteoutboundrtpstreamstats-roundtriptime</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">RtcpReceivedBlock</span> &#123;</span><br><span class="line">    <span class="type">bool</span> sender_report = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> dlrr = <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// For each remote SSRC we store if we&#x27;ve received a sender report or a DLRR</span></span><br><span class="line">  <span class="comment">// block.</span></span><br><span class="line">  flat_map&lt;<span class="type">uint32_t</span>, RtcpReceivedBlock&gt; received_blocks;</span><br><span class="line">  <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">uint8_t</span>* next_block = packet.<span class="built_in">begin</span>();</span><br><span class="line">       valid &amp;&amp; next_block != packet.<span class="built_in">end</span>();</span><br><span class="line">       next_block = rtcp_block.<span class="built_in">NextPacket</span>()) &#123;</span><br><span class="line">    <span class="type">ptrdiff_t</span> remaining_blocks_size = packet.<span class="built_in">end</span>() - next_block;</span><br><span class="line">    <span class="built_in">RTC_DCHECK_GT</span>(remaining_blocks_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rtcp_block.<span class="built_in">Parse</span>(next_block, remaining_blocks_size)) &#123;</span><br><span class="line">      valid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (rtcp_block.<span class="built_in">type</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> rtcp::SenderReport::kPacketType:</span><br><span class="line">        <span class="comment">// RTCPReceiver::HandleReportBlock计算RTT</span></span><br><span class="line">        valid = <span class="built_in">HandleSenderReport</span>(rtcp_block, packet_information);</span><br><span class="line">        received_blocks[packet_information-&gt;remote_ssrc].sender_report = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::ReceiverReport::kPacketType:</span><br><span class="line">        <span class="comment">// RTCPReceiver::HandleReportBlock计算RTT</span></span><br><span class="line">        valid = <span class="built_in">HandleReceiverReport</span>(rtcp_block, packet_information);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::Sdes::kPacketType:\</span><br><span class="line">        valid = <span class="built_in">HandleSdes</span>(rtcp_block, packet_information);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::ExtendedReports::kPacketType: &#123;</span><br><span class="line">        <span class="type">bool</span> contains_dlrr = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">uint32_t</span> ssrc = <span class="number">0</span>;</span><br><span class="line">        valid = <span class="built_in">HandleXr</span>(rtcp_block, packet_information, contains_dlrr, ssrc);</span><br><span class="line">        <span class="keyword">if</span> (contains_dlrr) &#123;</span><br><span class="line">          received_blocks[ssrc].dlrr = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> rtcp::Bye::kPacketType:</span><br><span class="line">        valid = <span class="built_in">HandleBye</span>(rtcp_block);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::App::kPacketType:</span><br><span class="line">        valid = <span class="built_in">HandleApp</span>(rtcp_block, packet_information);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::Rtpfb::kPacketType:</span><br><span class="line">        <span class="keyword">switch</span> (rtcp_block.<span class="built_in">fmt</span>()) &#123;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Nack::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandleNack</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Tmmbr::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandleTmmbr</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Tmmbn::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandleTmmbn</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::RapidResyncRequest::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandleSrReq</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::TransportFeedback::kFeedbackMessageType:</span><br><span class="line">            <span class="built_in">HandleTransportFeedback</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            ++num_skipped_packets_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rtcp::Psfb::kPacketType:</span><br><span class="line">        <span class="keyword">switch</span> (rtcp_block.<span class="built_in">fmt</span>()) &#123;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Pli::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandlePli</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Fir::kFeedbackMessageType:</span><br><span class="line">            valid = <span class="built_in">HandleFir</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> rtcp::Psfb::kAfbMessageType:</span><br><span class="line">            <span class="built_in">HandlePsfbApp</span>(rtcp_block, packet_information);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            ++num_skipped_packets_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ++num_skipped_packets_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (num_skipped_packets_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - last_skipped_packets_warning_ &gt;= kMaxWarningLogInterval) &#123;</span><br><span class="line">      last_skipped_packets_warning_ = now;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">          &lt;&lt; num_skipped_packets_</span><br><span class="line">          &lt;&lt; <span class="string">&quot; RTCP blocks were skipped due to being malformed or of &quot;</span></span><br><span class="line">             <span class="string">&quot;unrecognized/unsupported type, during the past &quot;</span></span><br><span class="line">          &lt;&lt; kMaxWarningLogInterval &lt;&lt; <span class="string">&quot; period.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">    ++num_skipped_packets_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; rb : received_blocks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rb.second.sender_report &amp;&amp; !rb.second.dlrr) &#123;</span><br><span class="line">      <span class="keyword">auto</span> rtt_stats = non_sender_rtts_.<span class="built_in">find</span>(rb.first);</span><br><span class="line">      <span class="keyword">if</span> (rtt_stats != non_sender_rtts_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        rtt_stats-&gt;second.<span class="built_in">Invalidate</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packet_type_counter_observer_) &#123;</span><br><span class="line">    packet_type_counter_observer_-&gt;<span class="built_in">RtcpPacketTypesCounterUpdated</span>(</span><br><span class="line">        <span class="built_in">local_media_ssrc</span>(), packet_type_counter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对SR和RR包的处理，调用<code>RTCPReceiver::HandleReportBlock</code>其中计算了RTT。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::HandleReportBlock</span><span class="params">(<span class="type">const</span> ReportBlock&amp; report_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     PacketInformation* packet_information,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> remote_ssrc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// SSRC过滤？</span></span><br><span class="line">  <span class="keyword">if</span> (!registered_ssrcs_.<span class="built_in">contains</span>(report_block.<span class="built_in">source_ssrc</span>()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">  last_received_rb_ = now;</span><br><span class="line"></span><br><span class="line">  ReportBlockData* report_block_data =</span><br><span class="line">      &amp;received_report_blocks_[report_block.<span class="built_in">source_ssrc</span>()];</span><br><span class="line">  <span class="keyword">if</span> (report_block.<span class="built_in">extended_high_seq_num</span>() &gt;</span><br><span class="line">      report_block_data-&gt;<span class="built_in">extended_highest_sequence_number</span>()) &#123;</span><br><span class="line">    <span class="comment">// We have successfully delivered new RTP packets to the remote side after</span></span><br><span class="line">    <span class="comment">// the last RR was sent from the remote side.</span></span><br><span class="line">    last_increased_sequence_number_ = last_received_rb_;</span><br><span class="line">  &#125;</span><br><span class="line">  NtpTime now_ntp = clock_-&gt;<span class="built_in">ConvertTimestampToNtpTime</span>(now);</span><br><span class="line">  <span class="comment">// Number of seconds since 1900 January 1 00:00 GMT (see</span></span><br><span class="line">  <span class="comment">// https://tools.ietf.org/html/rfc868).</span></span><br><span class="line">  report_block_data-&gt;<span class="built_in">SetReportBlock</span>(</span><br><span class="line">      remote_ssrc, report_block,</span><br><span class="line">      Timestamp::<span class="built_in">Millis</span>(now_ntp.<span class="built_in">ToMs</span>() - rtc::kNtpJan1970Millisecs));</span><br><span class="line">  <span class="comment">// lsr</span></span><br><span class="line">  <span class="type">uint32_t</span> send_time_ntp = report_block.<span class="built_in">last_sr</span>();</span><br><span class="line">  <span class="comment">// RFC3550, section 6.4.1, LSR field discription states:</span></span><br><span class="line">  <span class="comment">// If no SR has been received yet, the field is set to zero.</span></span><br><span class="line">  <span class="comment">// Receiver rtp_rtcp module is not expected to calculate rtt using</span></span><br><span class="line">  <span class="comment">// Sender Reports even if it accidentally can.</span></span><br><span class="line">  <span class="keyword">if</span> (send_time_ntp != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// dlsr</span></span><br><span class="line">    <span class="type">uint32_t</span> delay_ntp = report_block.<span class="built_in">delay_since_last_sr</span>();</span><br><span class="line">    <span class="comment">// 接收时间T</span></span><br><span class="line">    <span class="type">uint32_t</span> receive_time_ntp = <span class="built_in">CompactNtp</span>(now_ntp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RTT = T-lsr-dlsr，in 1/(2^16) seconds.</span></span><br><span class="line">    <span class="type">uint32_t</span> rtt_ntp = receive_time_ntp - delay_ntp - send_time_ntp;</span><br><span class="line">    <span class="comment">// Convert to 1/1000 seconds (milliseconds).</span></span><br><span class="line">    TimeDelta rtt = <span class="built_in">CompactNtpRttToTimeDelta</span>(rtt_ntp);</span><br><span class="line">    report_block_data-&gt;<span class="built_in">AddRoundTripTimeSample</span>(rtt);</span><br><span class="line">    <span class="keyword">if</span> (report_block.<span class="built_in">source_ssrc</span>() == <span class="built_in">local_media_ssrc</span>()) &#123;</span><br><span class="line">      rtts_[remote_ssrc].<span class="built_in">AddRtt</span>(rtt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RTT赋值</span></span><br><span class="line">    packet_information-&gt;rtt = rtt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  packet_information-&gt;report_block_datas.<span class="built_in">push_back</span>(*report_block_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>根据解析的数据包类型触发不同的回调处理函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::TriggerCallbacksFromRtcpPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketInformation&amp; packet_information)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先处理TMMBR和REMB，以避免多次调用OnNetworkChanged回调。</span></span><br><span class="line">  <span class="keyword">if</span> (packet_information.packet_type_flags &amp; kRtcpTmmbr) &#123;</span><br><span class="line">    <span class="comment">// 可能触发OnReceivedBandwidthEstimateUpdate回调。</span></span><br><span class="line">    <span class="built_in">NotifyTmmbrUpdated</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SR</span></span><br><span class="line">  <span class="keyword">if</span> (!receiver_only_ &amp;&amp; (packet_information.packet_type_flags &amp; kRtcpSrReq)) &#123;</span><br><span class="line">    rtp_rtcp_-&gt;<span class="built_in">OnRequestSendReport</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// nack</span></span><br><span class="line">  <span class="keyword">if</span> (!receiver_only_ &amp;&amp; (packet_information.packet_type_flags &amp; kRtcpNack)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!packet_information.nack_sequence_numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_VERBOSE) &lt;&lt; <span class="string">&quot;Incoming NACK length: &quot;</span></span><br><span class="line">                          &lt;&lt; packet_information.nack_sequence_numbers.<span class="built_in">size</span>();</span><br><span class="line">      rtp_rtcp_-&gt;<span class="built_in">OnReceivedNack</span>(packet_information.nack_sequence_numbers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need feedback that we have received a report block(s) so that we</span></span><br><span class="line">  <span class="comment">// can generate a new packet in a conference relay scenario, one received</span></span><br><span class="line">  <span class="comment">// report can generate several RTCP packets, based on number relayed/mixed</span></span><br><span class="line">  <span class="comment">// a send report block should go out to all receivers.</span></span><br><span class="line">  <span class="comment">// 处理report block(s)</span></span><br><span class="line">  <span class="keyword">if</span> (rtcp_intra_frame_observer_) &#123;</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(!receiver_only_);</span><br><span class="line">    <span class="comment">// pli或FIR</span></span><br><span class="line">    <span class="keyword">if</span> ((packet_information.packet_type_flags &amp; kRtcpPli) ||</span><br><span class="line">        (packet_information.packet_type_flags &amp; kRtcpFir)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (packet_information.packet_type_flags &amp; kRtcpPli) &#123;</span><br><span class="line">        <span class="built_in">RTC_LOG</span>(LS_VERBOSE)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Incoming PLI from SSRC &quot;</span> &lt;&lt; packet_information.remote_ssrc;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">RTC_LOG</span>(LS_VERBOSE)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Incoming FIR from SSRC &quot;</span> &lt;&lt; packet_information.remote_ssrc;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 关键帧请求</span></span><br><span class="line">      rtcp_intra_frame_observer_-&gt;<span class="built_in">OnReceivedIntraFrameRequest</span>(</span><br><span class="line">          <span class="built_in">local_media_ssrc</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 丢包通知</span></span><br><span class="line">  <span class="keyword">if</span> (rtcp_loss_notification_observer_ &amp;&amp;</span><br><span class="line">      (packet_information.packet_type_flags &amp; kRtcpLossNotification)) &#123;</span><br><span class="line">    rtcp::LossNotification* loss_notification =</span><br><span class="line">        packet_information.loss_notification.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(loss_notification);</span><br><span class="line">    <span class="comment">// 如果丢包通知的SSRC与本地媒体SSRC匹配。</span></span><br><span class="line">    <span class="keyword">if</span> (loss_notification-&gt;<span class="built_in">media_ssrc</span>() == <span class="built_in">local_media_ssrc</span>()) &#123;</span><br><span class="line">      <span class="comment">// 处理丢包</span></span><br><span class="line">      rtcp_loss_notification_observer_-&gt;<span class="built_in">OnReceivedLossNotification</span>(</span><br><span class="line">          loss_notification-&gt;<span class="built_in">media_ssrc</span>(), loss_notification-&gt;<span class="built_in">last_decoded</span>(),</span><br><span class="line">          loss_notification-&gt;<span class="built_in">last_received</span>(),</span><br><span class="line">          loss_notification-&gt;<span class="built_in">decodability_flag</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// rtcp观察者NetworkLinkRtcpObserver</span></span><br><span class="line">  <span class="comment">// 发送端BWE及相应的码率调整</span></span><br><span class="line">  <span class="comment">// 通过RtpTransportControllerSend转发给GoogCcNetworkController实现</span></span><br><span class="line">  <span class="keyword">if</span> (network_link_rtcp_observer_) &#123;</span><br><span class="line">    Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">    <span class="comment">// REMB</span></span><br><span class="line">    <span class="keyword">if</span> (packet_information.packet_type_flags &amp; kRtcpRemb) &#123;</span><br><span class="line">      <span class="comment">// 处理接收端估计的最大比特率</span></span><br><span class="line">      <span class="comment">// RtpTransportControllerSend::OnReceiverEstimatedMaxBitrate</span></span><br><span class="line">      <span class="comment">// GoogCcNetworkController::OnRemoteBitrateReport</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReceiverEstimatedMaxBitrate</span>(</span><br><span class="line">          now, DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">                   packet_information.receiver_estimated_max_bitrate_bps));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RR</span></span><br><span class="line">    <span class="keyword">if</span> (!packet_information.report_block_datas.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// RtpTransportControllerSend::OnReport</span></span><br><span class="line">      <span class="comment">// -&gt;GoogCcNetworkController::OnTransportLossReport</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReport</span>(</span><br><span class="line">          now, packet_information.report_block_datas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packet_information.rtt.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="comment">// RtpTransportControllerSend::OnRttUpdate</span></span><br><span class="line">      <span class="comment">// -&gt;GoogCcNetworkController::OnRoundTripTimeUpdate</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnRttUpdate</span>(now, *packet_information.rtt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// twcc反馈</span></span><br><span class="line">    <span class="keyword">if</span> (packet_information.transport_feedback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// RtpTransportControllerSend::OnTransportFeedback</span></span><br><span class="line">      <span class="comment">// -&gt;GoogCcNetworkController::OnTransportPacketsFeedback</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnTransportFeedback</span>(</span><br><span class="line">          now, *packet_information.transport_feedback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SR或者RR包</span></span><br><span class="line">  <span class="keyword">if</span> ((packet_information.packet_type_flags &amp; kRtcpSr) ||</span><br><span class="line">      (packet_information.packet_type_flags &amp; kRtcpRr)) &#123;</span><br><span class="line">    rtp_rtcp_-&gt;<span class="built_in">OnReceivedRtcpReportBlocks</span>(</span><br><span class="line">        packet_information.report_block_datas);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送端带宽估计</span></span><br><span class="line">  <span class="keyword">if</span> (network_state_estimate_observer_ &amp;&amp;</span><br><span class="line">      packet_information.network_state_estimate) &#123;</span><br><span class="line">    network_state_estimate_observer_-&gt;<span class="built_in">OnRemoteNetworkEstimate</span>(</span><br><span class="line">        *packet_information.network_state_estimate);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比特分配</span></span><br><span class="line">  <span class="keyword">if</span> (bitrate_allocation_observer_ &amp;&amp;</span><br><span class="line">      packet_information.target_bitrate_allocation) &#123;</span><br><span class="line">    bitrate_allocation_observer_-&gt;<span class="built_in">OnBitrateAllocationUpdated</span>(</span><br><span class="line">        *packet_information.target_bitrate_allocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!receiver_only_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (report_block_data_observer_) &#123;</span><br><span class="line">      <span class="comment">// 处理报告块</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; report_block_data :</span><br><span class="line">           packet_information.report_block_datas) &#123;</span><br><span class="line">        report_block_data_observer_-&gt;<span class="built_in">OnReportBlockDataUpdated</span>(</span><br><span class="line">            report_block_data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/05/27/Webrtc%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/">https://charstr.github.io/2024/05/27/Webrtc%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/06/01/Webrtc-Pacer%E6%A8%A1%E5%9D%97/">Webrtc Pacer模块</a>
                      
                        
                          <a class="next" rel="next" href="/2024/04/17/TCP-UDP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/">TCP/UDP可靠传输</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>