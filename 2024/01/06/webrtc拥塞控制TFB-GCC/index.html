<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc拥塞控制TFB-GCC | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!-- 通过连接CDN加载MathJax的js代码 -->
<!-- <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> -->


<!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script> -->

<script type="text/javascript" async
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc拥塞控制TFB-GCC
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">1月 6, 2024&nbsp;&nbsp;17:47:27</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/Webrtc/">Webrtc</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/BWE/">BWE</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <blockquote><p>Webrtc GCC拥塞控制算法原理及代码分析</p>
</blockquote>
<p>GCC结合延迟和丢包情况，预测可用带宽来控制发送的码率。Webrtc有NACK、FEC等解决丢包问题，带宽估计对较小的丢包不太敏感，而对基于延迟的抖动更大的灵敏度。当延迟变大时，在忽略掉传输数据大小变化的影响后，可以认为是网络堵塞，需要降低码率；而在延迟变小的情况下，认为网络通常，可以提高码率。所以当网络延迟较大，但没有丢包的情况下，GCC也会对带宽进行很大程度的调整。也就是说，延迟稳定的情况下，即使延迟高也不影响带宽估计；如果延迟小但是抖动大，那就会迅速降低估测的带宽。</p>
<p>REMB-GCC在应对突发峰值流量方面存在一些问题：</p>
<ol>
<li>在初始阶段，系统处于Increase状态，当检测到Decrease状态时，会调整码率为 <script type="math/tex">A_r(t_i) = \alpha R_r(t_{i})</script>，此时，可能会出现 <script type="math/tex">R_r(t_{i})\ll A_r(t_{i-1})</script>的情况，导致在后续中 <script type="math/tex">A_r</script> 较小。如果此时需要发送关键帧，<strong>PacedSender队列中将有大量数据包等待发送，这将造成较大的排队延迟</strong>。</li>
<li>码率估计模块反馈给编码器的码率较低，但当编码器需要编码关键帧时，编码器给出的码率仍然比反馈的码率高，这将增加发送关键帧的数据包量。</li>
</ol>
<p>这样会导致发送端的排队延迟较大，从而导致接收端的jitterBuffer延迟也较大。目前<code>REMB-GCC算法</code>已被废弃，码率估计模块全部放在发送端。<code>TFB-GCC</code>算法进行了以下改进：</p>
<ol>
<li>延迟估算和丢包估算都在发送端处理，接收端只需要定期反馈RTCP包和丢包率。</li>
<li>延迟估算采用TrendLine滤波器代替Kalman滤波器，通过拟合直线计算延迟梯度，从而估算网络拥塞</li>
<li>添加了Transport-CC扩展，在每个RTP包头添加了<strong>transport_sequence_number</strong>扩展字段，标识唯一的RTP包。接收端收到后反馈一个<strong>Transport-CC RR报文</strong>，记录每个transport_sequence_number到达接收端的时间信息，发送端可以用来计算包组间的延迟差，实现基于延迟的带宽估计。</li>
</ol>
<p><img src="01.png" alt="p1" style="zoom:66%;" /></p>
<h2 id="基于延迟的带宽估计"><a href="#基于延迟的带宽估计" class="headerlink" title="基于延迟的带宽估计"></a>基于延迟的带宽估计</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="03.png" alt="p3" style="zoom:22%;" /></p>
<p>网络传输中的<code>单向延时梯度</code>定义为<strong>相邻两个包组的接收时间差与发送时间差之间的差值</strong> <script type="math/tex">d_i = (t_i-t_{i-1})-(T_i-T_{i-1})</script>。这种延迟差的产生主要有三个原因：</p>
<ul>
<li><p>连续包组大小变化带来的时延 <script type="math/tex">\frac{\Delta L_i}{C_i}</script>，其中 <script type="math/tex">\Delta L_i</script> 表示连续两个数据包大小的变化，<script type="math/tex">C_i</script> 是接收第 i 帧时刻的链路容量或传输速率大小</p>
</li>
<li><p>包组在发送队列中的排队时延 <script type="math/tex">m_i</script> </p>
</li>
<li><p>网络抖动等其他延时 <script type="math/tex">z_i</script></p>
</li>
</ul>
<p>所以单向延时梯度可以表示为：</p>
<script type="math/tex; mode=display">
d_i = \frac{\Delta L_i }{C_i}+ m_i+z_i</script><p>在网络传输过程中，数据包在中间网络设备的转发过程中会先被放入排队队列等待处理和发送。排队延迟的变化最能反映出链路负载的变化情况。当某节点的发送速率小于接收速率时，排队延迟会逐渐增大；当发送速率大于接收速率时，排队延迟会逐渐减小甚至为0。因此，<strong>单向排队延迟梯度(one way queuing delay gradient)</strong>可以有效地反映码率的变化。进行拥塞控制的基本思想是:</p>
<ul>
<li>通过检测单向延迟梯度的正向扩张，探测网络负载是否接近饱和</li>
<li>当延迟梯度超过阈值时，降低发送码率，直到延迟梯度收敛，避免网络过载</li>
</ul>
<p>这样可以动态调整发送码率，让网络的负载趋于饱和但避免过载。</p>
<p>根据<a href="#gcc-analysis">GCC论文</a>，排队延迟可以建模为：<script type="math/tex">T_q(t) = \frac{q(t)}{C}</script>。<code>排队延迟梯度被定义为排队延迟的导数</code>，推导过程如下：</p>
<blockquote><script type="math/tex; mode=display">
\begin{align*}  
T_q{'}(t) &= \frac{q^{'}(t)}{C} & \text{(i)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{q(t+\Delta t) - q(t)}{\Delta t} & \text{(ii)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{(q(t) + (r(t + \Delta t) - C)\times\Delta t) - q(t)}{\Delta t}& \text{(iii)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{(r(t + \Delta t) - C)\times\Delta t}{\Delta t}& \text{(iv)} \\
&= \frac{r(t) - C}{C} & \text{(v)}
\end{align*}</script><footer><strong>woder</strong><cite><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ishen/p/15249678.html">www.cnblogs.com/ishen/p/15249678.html</a></cite></footer></blockquote>
<p>上式中，<script type="math/tex">q(t)</script> 为队列长度，<script type="math/tex">C</script> 是链路容量，<script type="math/tex">r(t)</script> 是队列接收速率也就是发送码率。步骤 <script type="math/tex">\text{(ii)} \to \text{(iii)}</script> 是将队列长度 <script type="math/tex">q(t+\Delta t)</script>，表示为初始队列长度 <script type="math/tex">q(t)</script>，加上由于输入速率 <script type="math/tex">r(t+Δt)</script> 超过链路容量 <script type="math/tex">C</script> 导致队列需要排队的码率。式 <script type="math/tex">\text{(i)}</script> 表明，<strong>排队延迟梯度 = 队列长度的变化/最大处理负载</strong>，式 <script type="math/tex">\text{(v)}</script> 表明了<strong>排队延迟梯度和接受码率及链路容量之间的关系</strong></p>
<p><strong>码率 <script type="math/tex">r(t)</script> 应该处于一直波动的状态</strong>。随着码率的增大，延迟梯度也会越高。当码率超过链路容量不再增长，此时延迟梯度不变，排队队列随着时间不断增长，导致排队的延迟升高最终出现网络拥塞。<strong>所以设置了队列延迟梯度阈值</strong>，队列增长一段时间之后，降低码率来清空队列，减小到一定后再继续增长。</p>
<p>函数调用流程如下：</p>
<p><img src="delay-based-BWE.png" alt="delay-based-BWE" style="zoom:27%;" /></p>
<h3 id="包组"><a href="#包组" class="headerlink" title="包组"></a>包组<a name="包组"></a></h3><p>WebRTC是将包进行分组，计算组间的整体计算传播时间差，且必须在发送方开启pacing发送。原因为：</p>
<ol>
<li>发送端的pacer模块的调度一般是5ms一次发送多个数据包。</li>
<li>wifi网络下存在短暂的信道中断现象，造成数据包的堆积，出现突发数据包。</li>
</ol>
<p>分组的实现：</p>
<ol>
<li>当前包的发送时间与当前包组第一个包发送时间差值在<code>5ms</code>内属于同一个组，超过则开始新的分组</li>
<li>一个数据包相当于所在的包组是突发数据包，仍然归到这个组中</li>
<li>同一时间发送的数据，是发送端突发数据包现象，一定是属于同一个组。wifi环境下的中断导致一段时间内的包聚集到达现象。突发数据包现象判断的条件是：延迟梯度 &lt; 0，到达时间间隔 &lt;= 5ms，与当前包组的首包到达时间的差值 &lt; 100ms</li>
</ol>
<p><code>InterArrivalDelta::NewTimestampGroup</code>判断需要创建新组的过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::NewTimestampGroup</span><span class="params">(Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Timestamp send_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_timestamp_group_.<span class="built_in">IsFirstPacket</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">BelongsToBurst</span>(arrival_time, send_time)) &#123;</span><br><span class="line">    <span class="comment">// 突发数据包不创建新的包组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 当前包和该包组首包的发送时刻差 &gt; 5ms</span></span><br><span class="line">    <span class="keyword">return</span> send_time - current_timestamp_group_.first_send_time &gt;</span><br><span class="line">           send_time_group_length_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断数据包是否属于一个突发数据包代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::BelongsToBurst</span><span class="params">(Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Timestamp send_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(current_timestamp_group_.complete_time.<span class="built_in">IsFinite</span>());</span><br><span class="line">  <span class="comment">// 当前包与当前包组最后一个包的接收时间差</span></span><br><span class="line">  TimeDelta arrival_time_delta =</span><br><span class="line">      arrival_time - current_timestamp_group_.complete_time;</span><br><span class="line">  <span class="comment">// 当前包与当前包组最后一个包的发送时间差</span></span><br><span class="line">  TimeDelta send_time_delta = send_time - current_timestamp_group_.send_time;</span><br><span class="line">  <span class="comment">// 发送时间差为零，属于突发数据包</span></span><br><span class="line">  <span class="keyword">if</span> (send_time_delta.<span class="built_in">IsZero</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟梯度 = 到达时间差 - 发送时间差</span></span><br><span class="line">  TimeDelta propagation_delta = arrival_time_delta - send_time_delta;</span><br><span class="line">  <span class="comment">// 延迟梯度 &lt; 0，到达时间间隔 &lt;= 5ms，与当前包组的首包到达时间的差值 &lt; 100ms，属于突发数据包</span></span><br><span class="line">  <span class="keyword">if</span> (propagation_delta &lt; TimeDelta::<span class="built_in">Zero</span>() &amp;&amp;</span><br><span class="line">      arrival_time_delta &lt;= kBurstDeltaThreshold &amp;&amp;</span><br><span class="line">      arrival_time - current_timestamp_group_.first_arrival &lt; kMaxBurstDuration)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="到达时间滤波器"><a href="#到达时间滤波器" class="headerlink" title="到达时间滤波器"></a>到达时间滤波器</h3><p>trend估计部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DelayBasedBwe::Result <span class="title">DelayBasedBwe::IncomingPacketFeedbackVector</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TransportPacketsFeedback&amp; msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; acked_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; probe_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;NetworkStateEstimate&gt; network_estimate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> in_alr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUNS_SERIALIZED</span>(&amp;network_race_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> packet_feedback_vector = msg.<span class="built_in">SortedByReceiveTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_vector.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Very late feedback received.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> DelayBasedBwe::<span class="built_in">Result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uma_recorded_) &#123;</span><br><span class="line">    <span class="built_in">RTC_HISTOGRAM_ENUMERATION</span>(kBweTypeHistogram,</span><br><span class="line">                              BweNames::kSendSideTransportSeqNum,</span><br><span class="line">                              BweNames::kBweNamesMax);</span><br><span class="line">    uma_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> delayed_feedback = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> recovered_from_overuse = <span class="literal">false</span>;</span><br><span class="line">  BandwidthUsage prev_detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  <span class="comment">// 遍历所有接收到的包</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : packet_feedback_vector) &#123;</span><br><span class="line">    delayed_feedback = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 每个包做trendline，基于延迟的带宽估计</span></span><br><span class="line">    <span class="built_in">IncomingPacketFeedback</span>(packet_feedback, msg.feedback_time);</span><br><span class="line">    <span class="keyword">if</span> (prev_detector_state == BandwidthUsage::kBwUnderusing &amp;&amp;</span><br><span class="line">        active_delay_detector_-&gt;<span class="built_in">State</span>() == BandwidthUsage::kBwNormal) &#123;</span><br><span class="line">      recovered_from_overuse = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev_detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delayed_feedback) &#123;</span><br><span class="line">    <span class="comment">// TODO(bugs.webrtc.org/10125): Design a better mechanism to safe-guard</span></span><br><span class="line">    <span class="comment">// against building very large network queues.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  rate_control_.<span class="built_in">SetInApplicationLimitedRegion</span>(in_alr);</span><br><span class="line">  rate_control_.<span class="built_in">SetNetworkStateEstimate</span>(network_estimate);</span><br><span class="line">  <span class="comment">// 更新基于延迟估计的码率</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MaybeUpdateEstimate</span>(acked_bitrate, probe_bitrate,</span><br><span class="line">                             std::<span class="built_in">move</span>(network_estimate),</span><br><span class="line">                             recovered_from_overuse, in_alr, msg.feedback_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>DelayBasedBwe::IncomingPacketFeedback</code>用于处理传入的数据包反馈。根据反馈的内容更新延迟检测器。如果流超时，会重置相关的对象和检测器。如果启用了音频分离，会根据数据包的类型（音频或视频）选择对应的延迟检测器进行更新。最后，根据数据包的发送时间、接收时间和大小，计算出发送间隔、接收间隔和大小间隔，然后更新数据包的延迟检测器。这个函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelayBasedBwe::IncomingPacketFeedback</span><span class="params">(<span class="type">const</span> PacketResult&amp; packet_feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前包和上一个包在feedback的时间相隔太远，重置delay_detector</span></span><br><span class="line">  <span class="keyword">if</span> (last_seen_packet_.<span class="built_in">IsInfinite</span>() ||</span><br><span class="line">      at_time - last_seen_packet_ &gt; kStreamTimeOut) &#123;</span><br><span class="line">    </span><br><span class="line">    video_inter_arrival_delta_ =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;InterArrivalDelta&gt;(kSendTimeGroupLength);</span><br><span class="line">    audio_inter_arrival_delta_ =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;InterArrivalDelta&gt;(kSendTimeGroupLength);</span><br><span class="line">    <span class="comment">// 重置视频和音频的延迟检测器</span></span><br><span class="line">    video_delay_detector_.<span class="built_in">reset</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TrendlineEstimator</span>(key_value_config_, network_state_predictor_));</span><br><span class="line">    audio_delay_detector_.<span class="built_in">reset</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TrendlineEstimator</span>(key_value_config_, network_state_predictor_));</span><br><span class="line">    <span class="comment">// 设置活动的延迟检测器为视频延迟检测器</span></span><br><span class="line">    active_delay_detector_ = video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新最后看到的数据包的时间</span></span><br><span class="line">  last_seen_packet_ = at_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为忽略小数据包的替代方案，我们可以为过度使用检测分离音频和视频数据包</span></span><br><span class="line">  DelayIncreaseDetectorInterface* delay_detector_for_packet =</span><br><span class="line">      video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果将音频和视频的分开码率预估，根据包是audio/video选择对应的delay_dector</span></span><br><span class="line">  <span class="keyword">if</span> (separate_audio_.enabled) &#123;</span><br><span class="line">    <span class="comment">// 如果发送的数据包是音频数据包</span></span><br><span class="line">    <span class="keyword">if</span> (packet_feedback.sent_packet.audio) &#123;</span><br><span class="line">      <span class="comment">// 将音频延迟检测器设置为数据包的延迟检测器</span></span><br><span class="line">      delay_detector_for_packet = audio_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="comment">// 增加自上次视频以来的音频数据包数量</span></span><br><span class="line">      audio_packets_since_last_video_++;</span><br><span class="line">      <span class="comment">// 如果自上次视频以来的音频数据包数量超过阈值，并且从上次视频数据包接收到现在的时间超过时间阈值</span></span><br><span class="line">      <span class="keyword">if</span> (audio_packets_since_last_video_ &gt; separate_audio_.packet_threshold &amp;&amp;</span><br><span class="line">          packet_feedback.receive_time - last_video_packet_recv_time_ &gt;</span><br><span class="line">              separate_audio_.time_threshold) &#123;</span><br><span class="line">        <span class="comment">// 将活动的延迟检测器设置为音频延迟检测器</span></span><br><span class="line">        active_delay_detector_ = audio_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果发送的数据包是视频数据包，重置自上次视频以来的音频数据包数量，并更新上次视频数据包接收的时间</span></span><br><span class="line">      audio_packets_since_last_video_ = <span class="number">0</span>;</span><br><span class="line">      last_video_packet_recv_time_ =</span><br><span class="line">          std::<span class="built_in">max</span>(last_video_packet_recv_time_, packet_feedback.receive_time);</span><br><span class="line">      <span class="comment">// 将活动的延迟检测器设置为视频延迟检测器</span></span><br><span class="line">      active_delay_detector_ = video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数据包大小</span></span><br><span class="line">  DataSize packet_size = packet_feedback.sent_packet.size;</span><br><span class="line">  <span class="comment">// 初始化发送间隔、接收间隔和大小间隔</span></span><br><span class="line">  TimeDelta send_delta = TimeDelta::<span class="built_in">Zero</span>();</span><br><span class="line">  TimeDelta recv_delta = TimeDelta::<span class="built_in">Zero</span>();</span><br><span class="line">  <span class="type">int</span> size_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 根据是否启用音频分离和发送的数据包是否为音频数据包，选择对应的到达间隔差值对象</span></span><br><span class="line">  InterArrivalDelta* inter_arrival_for_packet =</span><br><span class="line">      (separate_audio_.enabled &amp;&amp; packet_feedback.sent_packet.audio)</span><br><span class="line">          ? audio_inter_arrival_delta_.<span class="built_in">get</span>()</span><br><span class="line">          : video_inter_arrival_delta_.<span class="built_in">get</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算两包组的发送间隔(send_delta), 接收间隔(recv_delta)和数据包大小差(size_delta)</span></span><br><span class="line">  <span class="type">bool</span> calculated_deltas = inter_arrival_for_packet-&gt;<span class="built_in">ComputeDeltas</span>(</span><br><span class="line">      packet_feedback.sent_packet.send_time, packet_feedback.receive_time,</span><br><span class="line">      at_time, packet_size.<span class="built_in">bytes</span>(), &amp;send_delta, &amp;recv_delta, &amp;size_delta);</span><br><span class="line">  <span class="comment">// 进行拥塞控制</span></span><br><span class="line">  delay_detector_for_packet-&gt;<span class="built_in">Update</span>(recv_delta.<span class="built_in">ms</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line">                                    send_delta.<span class="built_in">ms</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line">                                    packet_feedback.sent_packet.send_time.<span class="built_in">ms</span>(),</span><br><span class="line">                                    packet_feedback.receive_time.<span class="built_in">ms</span>(),</span><br><span class="line">                                    packet_size.<span class="built_in">bytes</span>(), calculated_deltas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InterArrival::ComputeDeltas</code>函数包组发送和到达的时间差 <script type="math/tex">t_i-t_{i-1}</script> 和 <script type="math/tex">T_i-T_{i-1}</script> 以及包组大小差：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::ComputeDeltas</span><span class="params">(Timestamp send_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Timestamp system_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">size_t</span> packet_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TimeDelta* send_time_delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TimeDelta* arrival_time_delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">int</span>* packet_size_delta)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> calculated_deltas = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 当前包组首个包，存储包组信息，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (current_timestamp_group_.<span class="built_in">IsFirstPacket</span>()) &#123;</span><br><span class="line">    current_timestamp_group_.send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_arrival = arrival_time;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_timestamp_group_.first_send_time &gt; send_time) &#123;</span><br><span class="line">    <span class="comment">// 不是包组的第一个包，但是当前包比第一个包还要早，说明是乱序包，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">NewTimestampGroup</span>(arrival_time, send_time)) &#123;</span><br><span class="line">    <span class="comment">// 判断是新的包组，则使用current_group - prev_group得到delta</span></span><br><span class="line">    <span class="keyword">if</span> (prev_timestamp_group_.complete_time.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      <span class="comment">// 发送时间差</span></span><br><span class="line">      *send_time_delta =</span><br><span class="line">          current_timestamp_group_.send_time - prev_timestamp_group_.send_time;</span><br><span class="line">      <span class="comment">// 接收时间差</span></span><br><span class="line">      *arrival_time_delta = current_timestamp_group_.complete_time -</span><br><span class="line">                            prev_timestamp_group_.complete_time;</span><br><span class="line">      <span class="comment">// 到达时间与系统时钟的偏差，防止系统时间跳变影响计算</span></span><br><span class="line">      TimeDelta system_time_delta = current_timestamp_group_.last_system_time -</span><br><span class="line">                                    prev_timestamp_group_.last_system_time;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (*arrival_time_delta - system_time_delta &gt;=</span><br><span class="line">          kArrivalTimeOffsetThreshold) &#123;</span><br><span class="line">        <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;The arrival time clock offset has changed (diff = &quot;</span></span><br><span class="line">            &lt;&lt; arrival_time_delta-&gt;<span class="built_in">ms</span>() - system_time_delta.<span class="built_in">ms</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; ms), resetting.&quot;</span>;</span><br><span class="line">        <span class="built_in">Reset</span>();<span class="comment">// 重置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包在 socket 接收到 BWE 这段路径中是否被重新排序</span></span><br><span class="line">      <span class="keyword">if</span> (*arrival_time_delta &lt; TimeDelta::<span class="built_in">Zero</span>()) &#123;</span><br><span class="line">        ++num_consecutive_reordered_packets_;</span><br><span class="line">        <span class="comment">// 包组在收到本地到达时间戳后被重新排序（可能是乱序到达的包被重新排序），</span></span><br><span class="line">        <span class="comment">// 连续超过 kReorderedResetThreshold(3) 次会进行重置</span></span><br><span class="line">        <span class="keyword">if</span> (num_consecutive_reordered_packets_ &gt;= kReorderedResetThreshold) &#123;</span><br><span class="line">          <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;Packets between send burst arrived out of order, resetting:&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; arrival_time_delta_ms=&quot;</span> &lt;&lt; arrival_time_delta-&gt;<span class="built_in">ms</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, send_time_delta_ms=&quot;</span> &lt;&lt; send_time_delta-&gt;<span class="built_in">ms</span>();</span><br><span class="line">          <span class="built_in">Reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num_consecutive_reordered_packets_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包组大小差</span></span><br><span class="line">      *packet_size_delta = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(current_timestamp_group_.size) -</span><br><span class="line">                           <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(prev_timestamp_group_.size);</span><br><span class="line">      calculated_deltas = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的包组改为上个包组</span></span><br><span class="line">    prev_timestamp_group_ = current_timestamp_group_;</span><br><span class="line">    <span class="comment">// 当前包组是新的包租</span></span><br><span class="line">    current_timestamp_group_.first_send_time = send_time;</span><br><span class="line">    current_timestamp_group_.send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_arrival = arrival_time;</span><br><span class="line">    current_timestamp_group_.size = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常的数据包更新包组信息</span></span><br><span class="line">    current_timestamp_group_.send_time =</span><br><span class="line">        std::<span class="built_in">max</span>(current_timestamp_group_.send_time, send_time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修正累计包组数据</span></span><br><span class="line">  current_timestamp_group_.size += packet_size;</span><br><span class="line">  current_timestamp_group_.complete_time = arrival_time;</span><br><span class="line">  current_timestamp_group_.last_system_time = system_time;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calculated_deltas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新包组实现见<a href="#包组">包组</a></p>
<h3 id="Trendline-Filter"><a href="#Trendline-Filter" class="headerlink" title="Trendline Filter"></a>Trendline Filter</h3><p>新版本中用<code>Trendline Filter</code>根据到达时间差、发送时间差、数据大小差来估计单向延迟的趋势。在执行了<code>InterArrivalDelta::NewTimestampGroup</code>函数判断是新的包组，才会计算包组之间的delta去做trendline。<code>rendlineEstimator::Update</code>函数是<code>TrendlineEstimator</code>类的接口函数，调用<code>TrendlineEstimator::UpdateTrendline</code>计算基于延迟的带宽估计，进行Trendline Filter滤波，判断当前的网络状态、更新阈值等。</p>
<p>单个包组传输的延迟梯度为: <script type="math/tex">d_i = (t_i-t_{i-1})-(T_i-T_{i-1})</script></p>
<p>每个包组叠加延迟为: <script type="math/tex">acc_{delay_i } = \sum d_i</script></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::Update</span><span class="params">(<span class="type">double</span> recv_delta_ms, <span class="comment">// 包组接收时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">double</span> send_delta_ms, <span class="comment">// 包组发送时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int64_t</span> send_time_ms, <span class="comment">// 当前处理的包的发送时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int64_t</span> arrival_time_ms, <span class="comment">// 当前处理的包的到达时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> packet_size, <span class="comment">// 当前处理的包的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> calculated_deltas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (calculated_deltas) &#123;</span><br><span class="line">    <span class="built_in">UpdateTrendline</span>(recv_delta_ms, send_delta_ms, send_time_ms, arrival_time_ms,</span><br><span class="line">                    packet_size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (network_state_predictor_) &#123;</span><br><span class="line">    hypothesis_predicted_ = network_state_predictor_-&gt;<span class="built_in">Update</span>(</span><br><span class="line">        send_time_ms, arrival_time_ms, hypothesis_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::UpdateTrendline</span><span class="params">(<span class="type">double</span> recv_delta_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">double</span> send_delta_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> send_time_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> arrival_time_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> packet_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单个包组的延迟梯度</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> delta_ms = recv_delta_ms - send_delta_ms;</span><br><span class="line">  ++num_of_deltas_; <span class="comment">// 累计的延迟梯度数据点计数</span></span><br><span class="line">  <span class="comment">// 限制数据点计数不超过最大值1000</span></span><br><span class="line">  num_of_deltas_ = std::<span class="built_in">min</span>(num_of_deltas_, kDeltaCounterMax);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录第一个到达时间点</span></span><br><span class="line">  <span class="keyword">if</span> (first_arrival_time_ms_ == <span class="number">-1</span>)</span><br><span class="line">    first_arrival_time_ms_ = arrival_time_ms;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包组叠加延迟</span></span><br><span class="line">  accumulated_delay_ += delta_ms;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;accumulated_delay_ms&quot;</span>, arrival_time_ms,</span><br><span class="line">                        accumulated_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次指数平滑滤波器对网络叠加延迟进行平滑</span></span><br><span class="line">  <span class="comment">// 平滑系数smoothing_coef_取0.9，意味着新的延迟梯度观测值的变化对平滑值的影响较小，减少了修正幅度</span></span><br><span class="line">  <span class="comment">// 如果时间序列波动不大，比较平稳，则平滑系数应取小一点，</span></span><br><span class="line">  <span class="comment">// 以减少修正幅度，使预测模型能包含较长时间序列的信息。</span></span><br><span class="line">  <span class="comment">// 如果时间序列具有迅速且明显的变动倾向，则平滑系数应取大一点，</span></span><br><span class="line">  <span class="comment">// 以使预测模型灵敏度高些，以便迅速跟上数据的变化。</span></span><br><span class="line">  smoothed_delay_ = smoothing_coef_ * smoothed_delay_ +</span><br><span class="line">                    (<span class="number">1</span> - smoothing_coef_) * accumulated_delay_;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;smoothed_delay_ms&quot;</span>, arrival_time_ms,</span><br><span class="line">                        smoothed_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双端队列维护数据窗口</span></span><br><span class="line">  <span class="comment">// 距离第一个RTP包到达的间距，平滑后的叠加延迟，未平滑的包组叠加延迟</span></span><br><span class="line">  delay_hist_.<span class="built_in">emplace_back</span>(</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(arrival_time_ms - first_arrival_time_ms_),</span><br><span class="line">      smoothed_delay_, accumulated_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启用排序则按到达时间排序。</span></span><br><span class="line">  <span class="keyword">if</span> (settings_.enable_sort) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = delay_hist_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">         i &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         delay_hist_[i].arrival_time_ms &lt; delay_hist_[i - <span class="number">1</span>].arrival_time_ms;</span><br><span class="line">         --i) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(delay_hist_[i], delay_hist_[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护窗口点大小为20，弹出最早的数据</span></span><br><span class="line">  <span class="keyword">if</span> (delay_hist_.<span class="built_in">size</span>() &gt; settings_.window_size)</span><br><span class="line">    delay_hist_.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> trend = prev_trend_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 达到的了窗口的大小根据最小二乘计算trend</span></span><br><span class="line">  <span class="keyword">if</span> (delay_hist_.<span class="built_in">size</span>() == settings_.window_size) &#123;</span><br><span class="line">    <span class="comment">// 最小二乘法计算斜率</span></span><br><span class="line">    <span class="comment">// 延迟趋势可以被视为（发送码率 - 网络容量）/网络容量的估算</span></span><br><span class="line">    <span class="comment">// 0 &lt; trend &lt; 1   -&gt;  延迟增加，队列正在填充</span></span><br><span class="line">    <span class="comment">//   trend == 0    -&gt;  延迟不变，队列长度不变</span></span><br><span class="line">    <span class="comment">//   trend &lt; 0     -&gt;  延迟减少，队列正在排空</span></span><br><span class="line">    trend = <span class="built_in">LinearFitSlope</span>(delay_hist_).<span class="built_in">value_or</span>(trend);</span><br><span class="line">    <span class="comment">// 如果启用了斜率限制，对趋势线的斜率进行限制</span></span><br><span class="line">    <span class="keyword">if</span> (settings_.enable_cap) &#123;</span><br><span class="line">      <span class="comment">// 计算斜率的上限</span></span><br><span class="line">      absl::optional&lt;<span class="type">double</span>&gt; cap = <span class="built_in">ComputeSlopeCap</span>(delay_hist_, settings_);</span><br><span class="line">      <span class="keyword">if</span> (trend &gt;= <span class="number">0</span> &amp;&amp; cap.<span class="built_in">has_value</span>() &amp;&amp; trend &gt; cap.<span class="built_in">value</span>()) &#123;</span><br><span class="line">        trend = cap.<span class="built_in">value</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;trendline_slope&quot;</span>, arrival_time_ms, trend);</span><br><span class="line">  <span class="comment">// 将排队延迟梯度和阈值相比较，判断当前网络情况</span></span><br><span class="line">  <span class="built_in">Detect</span>(trend, send_delta_ms, arrival_time_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最小二乘计算斜率 <script type="math/tex">k</script> 在<code>absl::optional&lt;double&gt; LinearFitSlope</code>函数中计算:</p>
<script type="math/tex; mode=display">
k=\frac{\sum_{i} \left(y_i-\bar{y} \right)\left(x_i-\bar{x} \right)}{\sum_{i}\left(x_i-\bar{x} \right)^2}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;<span class="type">double</span>&gt; <span class="title">LinearFitSlope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::deque&lt;TrendlineEstimator::PacketTiming&gt;&amp; packets)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(packets.<span class="built_in">size</span>() &gt;= <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// Compute the &quot;center of mass&quot;.</span></span><br><span class="line">  <span class="type">double</span> sum_x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> sum_y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet : packets) &#123;</span><br><span class="line">    sum_x += packet.arrival_time_ms;</span><br><span class="line">    sum_y += packet.smoothed_delay_ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> x_avg = sum_x / packets.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">double</span> y_avg = sum_y / packets.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// Compute the slope k = \sum (x_i-x_avg)(y_i-y_avg) / \sum (x_i-x_avg)^2</span></span><br><span class="line">  <span class="type">double</span> numerator = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> denominator = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet : packets) &#123;</span><br><span class="line">    <span class="type">double</span> x = packet.arrival_time_ms;</span><br><span class="line">    <span class="type">double</span> y = packet.smoothed_delay_ms;</span><br><span class="line">    numerator += (x - x_avg) * (y - y_avg);</span><br><span class="line">    denominator += (x - x_avg) * (x - x_avg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (denominator == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用最小二乘法拟合直线 <script type="math/tex">y=kx+b</script>，这里边的 <script type="math/tex">x</script> 是包组的接收时间，<script type="math/tex">y</script> 是<code>smoothed_delay</code>，<script type="math/tex">k</script> 就是<code>trend</code>，反映了网络拥塞状况，作用是检测网络是否过载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;<span class="type">double</span>&gt; <span class="title">ComputeSlopeCap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::deque&lt;TrendlineEstimator::PacketTiming&gt;&amp; packets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TrendlineEstimatorSettings&amp; settings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保设置的起始和结束数据包数是有效的</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(<span class="number">1</span> &lt;= settings.beginning_packets &amp;&amp;</span><br><span class="line">             settings.beginning_packets &lt; packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(<span class="number">1</span> &lt;= settings.end_packets &amp;&amp;</span><br><span class="line">             settings.end_packets &lt; packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(settings.beginning_packets + settings.end_packets &lt;=</span><br><span class="line">             packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// 初始化早期和晚期数据包，用于计算斜率上限。</span></span><br><span class="line">  TrendlineEstimator::PacketTiming early = packets[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; settings.beginning_packets; ++i) &#123;</span><br><span class="line">    <span class="comment">// 找到延迟最小的一个early包</span></span><br><span class="line">    <span class="keyword">if</span> (packets[i].raw_delay_ms &lt; early.raw_delay_ms)</span><br><span class="line">      early = packets[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到延迟最小的一个late包</span></span><br><span class="line">  <span class="type">size_t</span> late_start = packets.<span class="built_in">size</span>() - settings.end_packets;</span><br><span class="line">  TrendlineEstimator::PacketTiming late = packets[late_start];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = late_start + <span class="number">1</span>; i &lt; packets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packets[i].raw_delay_ms &lt; late.raw_delay_ms)</span><br><span class="line">      late = packets[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// early包和late包的到达时间间隔少于1ms,则返回空值</span></span><br><span class="line">  <span class="keyword">if</span> (late.arrival_time_ms - early.arrival_time_ms &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 延迟差除以到达时间间隔,再加上cap_uncertainty,作为容量上限返回</span></span><br><span class="line">  <span class="keyword">return</span> (late.raw_delay_ms - early.raw_delay_ms) /</span><br><span class="line">             (late.arrival_time_ms - early.arrival_time_ms) +</span><br><span class="line">         settings.cap_uncertainty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接线性回归可能会导致，在某些情况下可能会高估网络的实际拥塞程度，导致过多误报。这里引入了网络容量的上限，对trend进行约束。避免了trend被高估，防止对网络状态的估计过于悲观，降低了误报，同时保持了对网络拥塞的响应性。</p>
<h3 id="过载检测器"><a href="#过载检测器" class="headerlink" title="过载检测器"></a>过载检测器</h3><p>最小二乘拟合出来的<code>trend</code>会比较小，需要乘以增益和点的个数进行修正。设置的阈值范围内 <script type="math/tex">[-\gamma,\gamma]</script>，</p>
<ul>
<li><script type="math/tex">trend > \gamma</script>，说明网络网络拥塞队列在增大，网络过载</li>
<li><script type="math/tex">trend <  -\gamma</script>，说明网络拥塞队列在变小，拥塞情况在改善，网络低负载</li>
<li><script type="math/tex">-\gamma \leq trend \leq \gamma</script>，网络正常</li>
</ul>
<p><code>TrendlineEstimator::Detect</code>函数根据<code>trend</code>判断当前带宽的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::Detect</span><span class="params">(<span class="type">double</span> trend, <span class="type">double</span> ts_delta, <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_of_deltas_ &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwNormal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// trend值太小，这里乘以阈值增益和包组数量</span></span><br><span class="line">  <span class="comment">// 最多kMinNumDeltas=60个采样，threshold_gain_=4</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> modified_trend =</span><br><span class="line">      std::<span class="built_in">min</span>(num_of_deltas_, kMinNumDeltas) * trend * threshold_gain_;</span><br><span class="line">  prev_modified_trend_ = modified_trend;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;T&quot;</span>, now_ms, modified_trend);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;threshold&quot;</span>, now_ms, threshold_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修正后和阈值比较，判断当前状态</span></span><br><span class="line">  <span class="comment">// 超过阈值，拥塞加剧</span></span><br><span class="line">  <span class="keyword">if</span> (modified_trend &gt; threshold_) &#123;</span><br><span class="line">    <span class="comment">// 过载时长等于包组发送时间差值的累加</span></span><br><span class="line">    <span class="comment">// 第一次过载，过载时间设置为两包组发送时间差的一半</span></span><br><span class="line">    <span class="comment">// 为什么一半？类似于TCP 的慢启动策略？</span></span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ == <span class="number">-1</span>) &#123;</span><br><span class="line">      time_over_using_ = ts_delta / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 持续过载，加上包组发送时间差</span></span><br><span class="line">      time_over_using_ += ts_delta;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过载计数器</span></span><br><span class="line">    overuse_counter_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过载时间持续时间超过了阈值 10ms，并且累计触发过载的次数大于1</span></span><br><span class="line">    <span class="comment">// 这样为了抗抖动，避免短暂的高延迟导致误判成过载。所以必须是持续过载才可以</span></span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ &gt; overusing_time_threshold_ &amp;&amp; overuse_counter_ &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 比上一次延时梯度还要高，延迟在恶化，才会处于过载</span></span><br><span class="line">      <span class="comment">// 比上次低则认为过载程度减弱，网络在编号，不处于过载状态</span></span><br><span class="line">      <span class="keyword">if</span> (trend &gt;= prev_trend_) &#123;</span><br><span class="line">        <span class="comment">// 清空状态信息，重新开始下一次的检测</span></span><br><span class="line">        time_over_using_ = <span class="number">0</span>;</span><br><span class="line">        overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 满足所有过载触发条件，触发过载，设置过载状态</span></span><br><span class="line">        hypothesis_ = BandwidthUsage::kBwOverusing;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modified_trend &lt; -threshold_) &#123;</span><br><span class="line">    <span class="comment">// 网络低负载，拥塞队列在变小，拥塞情况在改善，处于 underuse 状态</span></span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwUnderusing;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断处于 normal 状态</span></span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwNormal;</span><br><span class="line">  &#125;</span><br><span class="line">  prev_trend_ = trend;</span><br><span class="line">  <span class="comment">// 更新阈值</span></span><br><span class="line">  <span class="built_in">UpdateThreshold</span>(modified_trend, now_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><blockquote><p>为什么不采用固定的阈值：</p>
<ul>
<li>固定阈值过大，在检测到过载信号时，队列延迟可能已经变得非常大，或者无法探测到网络拥塞，算法不够灵敏</li>
<li>固定的阈值太小，导致算法对单向延迟梯度的变化过于敏感，很小的延迟梯度都会被误判为过载，导致过载检测器频繁地检测到过载信号，导致基于时延的控制器因为频繁的过载信号而不断地降低预测的带宽</li>
<li>固定的阈值导致GCC和TCP流（TCP是基于丢包的拥塞控制）共存的竞争中产生问题，。TCP流的高延迟梯度可能会导致GCC产生大量的过载信号，有限状态机总是在降低发送码率，最终导致GCC码率被耗尽。即在和TCP流的竞争中，GCC流量出现饥饿现象</li>
</ul>
</blockquote>
<p>理想状况下，网络的延迟梯度是0，实际的网络中，不同转发路径的延迟梯度有波动且波动大小不同。阈值随着延迟梯度的变化动态调整，可以降低GCC算法对延迟梯度变化的敏感度。WebRTC使用了一种自适应的阈值调节算法：</p>
<script type="math/tex; mode=display">
\gamma_i = \gamma_{i-1} + K*\Delta T *\left(|trend_i|-\gamma_{i-1}\right)</script><p>其中 <script type="math/tex">\Delta T = t_i - t_{i-1}</script> 表示两组包计算延时梯度的时间差，意义就是距上次更新阈值时的时间间隔，每组数据包会触发一次探测，同时更新一次阈值。<script type="math/tex">k</script> 是一个变化率，增长的基值是：当前的<code>trend</code>和上一个阈值的差值：</p>
<script type="math/tex; mode=display">
K = \begin{cases}
   k_d & |trend(t_i)|<\gamma_{i-1} \\
   k_u & otherwise
\end{cases}</script><p>其中 <script type="math/tex">k_d=0.039,k_u=0.0087</script>。梯度小于阈值的时候，值大是为了梯度能够迅速收敛。</p>
<p><strong>这里为什么用延时梯度更新阈值？</strong></p>
<p>过载检测器之后，要进行阈值的更新，在<code>TrendlineEstimator::UpdateThreshold</code>函数实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::UpdateThreshold</span><span class="params">(<span class="type">double</span> modified_trend,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是第一次更新阈值，初始化最后一次更新的时间。</span></span><br><span class="line">  <span class="keyword">if</span> (last_update_ms_ == <span class="number">-1</span>)</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line">  <span class="comment">// 修改后延迟梯度斜率和阈值的差值超过最大偏移量15，不更新阈值</span></span><br><span class="line">  <span class="comment">// 避免网络故障（如容量突然降低）导致的延迟梯度的的瞬时急剧增加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(modified_trend) &gt; threshold_ + kMaxAdaptOffsetMs) &#123;</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择变化率  k_up_(0.0087)，k_down_(0.039)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在拥塞增大时缓慢调整阈值，避免网络抖动;</span></span><br><span class="line">  <span class="comment">// 在拥塞减小时快速调整阈值，使系统更快对网络状态变化作出响应</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> k = <span class="built_in">fabs</span>(modified_trend) &lt; threshold_ ? k_down_ : k_up_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> kMaxTimeDeltaMs = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阈值的调整量与自上次阈值更新以来的时间间隔成正比，时间越长，调整越多</span></span><br><span class="line">  <span class="comment">// 这里使用的是包组的到达时间差，过载检测累计时间使用的是包组发送时间差</span></span><br><span class="line">  <span class="comment">// 限制在最大时间差kMaxTimeDeltaMs=100ms内</span></span><br><span class="line">  <span class="type">int64_t</span> time_delta_ms = std::<span class="built_in">min</span>(now_ms - last_update_ms_, kMaxTimeDeltaMs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据拥塞值的变化（fabs(modified_trend) - threshold_)）、时间差以及选择的变化率，更新阈值</span></span><br><span class="line">  <span class="comment">// 拥塞值不变，阈值保持不变；拥塞值增大，且时间间隔较长，阈值会相应增加；</span></span><br><span class="line">  <span class="comment">// 拥塞值减小，阈值会相应减小。</span></span><br><span class="line">  <span class="comment">// 这样能够更灵敏地感知和适应网络拥塞状况</span></span><br><span class="line"></span><br><span class="line">  threshold_ += k * (<span class="built_in">fabs</span>(modified_trend) - threshold_) * time_delta_ms;</span><br><span class="line">  <span class="comment">// 防止阈值过大或过小导致不稳定的行为</span></span><br><span class="line">  threshold_ = rtc::<span class="built_in">SafeClamp</span>(threshold_, <span class="number">6.f</span>, <span class="number">600.f</span>);</span><br><span class="line">  last_update_ms_ = now_ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="码率调整"><a href="#码率调整" class="headerlink" title="码率调整"></a>码率调整</h3><p>码率控制维护一个状态机，<strong>根据过载探测器输出的信号，估算基于延迟的网络速率</strong> <script type="math/tex">A_r</script>。</p>
<p><img src="02.png" alt="p2" style="zoom:32%;" /></p>
<p>有限状态机的目标是最小化端到端路径上缓冲区中的排队延迟。当网络拥塞时，过载检测器触发overuse信号，状态机处于 Decrase状态，应该降低发送码率，降低为过去 $500 ms$ 时间窗口内的最大 <code>acked_bitrate</code>的0.85倍；当网络中排队的数据包被快速释放时，过载检测器触发underuse信号，状态机进入hold状态；直到缓冲区被清空，网络平稳，过载检测器触发normal信号，状态机进入increase状态，开始探测是否可以增加发送码率。码率的调整根据以下式子：</p>
<script type="math/tex; mode=display">
A_r(t_i) = \begin{cases}
    \eta A_r(t_{i-1}) & \sigma=Increase \\
    \alpha R_r(t_{i}) & \sigma=Decrease \\
    A_r(t_{i-1}) & \sigma=Hold 
\end{cases}</script><p>其中 <script type="math/tex">\eta=1.05, \alpha = 0.85</script>。</p>
<p><code>DelayBasedBwe::IncomingPacketFeedbackVector-&gt;DelayBasedBwe::MaybeUpdateEstimate</code>根据当前的网络状态更新带宽估计。如果当前正在过度使用带宽，尝试降低比特率；如果不在过度使用状态，根据探测的比特率或已确认的比特率来更新带宽估计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DelayBasedBwe::Result <span class="title">DelayBasedBwe::MaybeUpdateEstimate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; acked_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; probe_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;NetworkStateEstimate&gt; state_estimate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> recovered_from_overuse,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> in_alr, <span class="comment">// 是否在应用有限的状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  Result result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前正在过载带宽</span></span><br><span class="line">  <span class="keyword">if</span> (active_delay_detector_-&gt;<span class="built_in">State</span>() == BandwidthUsage::kBwOverusing) &#123;</span><br><span class="line">    <span class="comment">// 如果有已确认的比特率，并且在当前时间需要进一步减少比特率</span></span><br><span class="line">    <span class="keyword">if</span> (acked_bitrate &amp;&amp;</span><br><span class="line">        rate_control_.<span class="built_in">TimeToReduceFurther</span>(at_time, *acked_bitrate)) &#123;</span><br><span class="line">      result.updated =</span><br><span class="line">          <span class="built_in">UpdateEstimate</span>(at_time, acked_bitrate, &amp;result.target_bitrate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!acked_bitrate &amp;&amp; rate_control_.<span class="built_in">ValidEstimate</span>() &amp;&amp;</span><br><span class="line">               rate_control_.<span class="built_in">InitialTimeToReduceFurther</span>(at_time)) &#123;</span><br><span class="line">      <span class="comment">// 在测量到确认的比特率之前就发生过载。每200毫秒减少发送速率50%。</span></span><br><span class="line">      rate_control_.<span class="built_in">SetEstimate</span>(rate_control_.<span class="built_in">LatestEstimate</span>() / <span class="number">2</span>, at_time);</span><br><span class="line">      result.updated = <span class="literal">true</span>;</span><br><span class="line">      result.probe = <span class="literal">false</span>;</span><br><span class="line">      result.target_bitrate = rate_control_.<span class="built_in">LatestEstimate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据probe_bitrate信息进行更新，这通常是在启动阶段的探测阶段。</span></span><br><span class="line">    <span class="keyword">if</span> (probe_bitrate) &#123;</span><br><span class="line">      <span class="comment">// 如果有探测码率，直接使用探测码率</span></span><br><span class="line">      result.probe = <span class="literal">true</span>;</span><br><span class="line">      result.updated = <span class="literal">true</span>;</span><br><span class="line">      rate_control_.<span class="built_in">SetEstimate</span>(*probe_bitrate, at_time);</span><br><span class="line">      result.target_bitrate = rate_control_.<span class="built_in">LatestEstimate</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有的话，根据之前的估计值进行更新</span></span><br><span class="line">      result.updated =</span><br><span class="line">          <span class="built_in">UpdateEstimate</span>(at_time, acked_bitrate, &amp;result.target_bitrate);</span><br><span class="line">      result.recovered_from_overuse = recovered_from_overuse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取延迟检测器的状态</span></span><br><span class="line">  BandwidthUsage detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  <span class="comment">// 如果估算已更新且估算比特率不等于之前的比特率，或者检测器的状态不等于之前的状态</span></span><br><span class="line">  <span class="keyword">if</span> ((result.updated &amp;&amp; prev_bitrate_ != result.target_bitrate) ||</span><br><span class="line">      detector_state != prev_state_) &#123;</span><br><span class="line">    DataRate bitrate = result.updated ? result.target_bitrate : prev_bitrate_;</span><br><span class="line">     <span class="comment">// 记录目标比特率的日志</span></span><br><span class="line">    <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;target_bitrate_bps&quot;</span>, at_time.<span class="built_in">ms</span>(), bitrate.<span class="built_in">bps</span>());</span><br><span class="line">    <span class="comment">// 记录BWE（带宽估算）更新事件</span></span><br><span class="line">    <span class="keyword">if</span> (event_log_) &#123;</span><br><span class="line">      event_log_-&gt;<span class="built_in">Log</span>(std::<span class="built_in">make_unique</span>&lt;RtcEventBweUpdateDelayBased&gt;(</span><br><span class="line">          bitrate.<span class="built_in">bps</span>(), detector_state));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新之前的比特率和状态</span></span><br><span class="line">    prev_bitrate_ = bitrate;</span><br><span class="line">    prev_state_ = detector_state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录之前的预估码率和state</span></span><br><span class="line">  result.delay_detector_state = detector_state;</span><br><span class="line">  <span class="comment">// 返回一个包含更新后的带宽估计和延迟检测器状态的结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新码率调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelayBasedBwe::UpdateEstimate</span><span class="params">(Timestamp at_time, <span class="comment">// 当前时间戳</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   absl::optional&lt;DataRate&gt; acked_bitrate, <span class="comment">// 已确认的比特率</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   DataRate* target_rate)</span> </span>&#123; <span class="comment">// 目标比特率</span></span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="function"><span class="type">const</span> RateControlInput <span class="title">input</span><span class="params">(active_delay_detector_-&gt;State(), acked_bitrate)</span></span>;</span><br><span class="line">  <span class="comment">// 更新目标比特率，AIMD的外部接口函数，实现码率的调整</span></span><br><span class="line">  *target_rate = rate_control_.<span class="built_in">Update</span>(input, at_time);</span><br><span class="line">  <span class="keyword">return</span> rate_control_.<span class="built_in">ValidEstimate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在比特率未初始化时，根据估计的吞吐量来设置当前比特率，并在必要时改变比特率</span></span><br><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::Update</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始带宽在RemoteBitrateEstimatorAbsSendTime中使用Cluster、Probe等对象来探测，Probe是一个超过200字节的包，</span></span><br><span class="line">  <span class="comment">// 包簇Cluster是5ms范围内Probe的集合，使用Cluster的集合来预估初始带宽(调用AimdRateControl::SetEstimate设置)，</span></span><br><span class="line">  <span class="comment">// 这里是为了保证如果5秒之后还没有通过包簇探测到初始带宽的情况下，使用输入的码率来设置初始带宽。</span></span><br><span class="line">  <span class="keyword">if</span> (!bitrate_is_initialized_) &#123;<span class="comment">// 如果码率未初始化</span></span><br><span class="line">    <span class="comment">// 初始化时间为5秒</span></span><br><span class="line">    <span class="type">const</span> TimeDelta kInitializationTime = TimeDelta::<span class="built_in">Seconds</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 检查比特率窗口是否小于等于初始化时间</span></span><br><span class="line">    <span class="built_in">RTC_DCHECK_LE</span>(kBitrateWindow, kInitializationTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个第一个数据</span></span><br><span class="line">    <span class="keyword">if</span> (time_first_throughput_estimate_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">      <span class="comment">// 有输入码率</span></span><br><span class="line">      <span class="keyword">if</span> (input.estimated_throughput)</span><br><span class="line">        <span class="comment">// 设置第一次吞吐量估计的时间为当前时间（第一个发送码率到达）</span></span><br><span class="line">        time_first_throughput_estimate_ = at_time;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (at_time - time_first_throughput_estimate_ &gt;</span><br><span class="line">                   kInitializationTime &amp;&amp;</span><br><span class="line">               input.estimated_throughput) &#123;</span><br><span class="line">      <span class="comment">// 当前时间减去第一次吞吐量估计的时间过去了5秒还初始化过带宽，并且存在估计的吞吐量</span></span><br><span class="line">      <span class="comment">// 使用5秒后的输入码率来初始化带宽</span></span><br><span class="line">      current_bitrate_ = *input.estimated_throughput;</span><br><span class="line">      bitrate_is_initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据状态机调整比特率</span></span><br><span class="line">  <span class="built_in">ChangeBitrate</span>(input, at_time);</span><br><span class="line">  <span class="keyword">return</span> current_bitrate_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AimdRateControl::ChangeBitrate</code>根据当前吞吐量和bw_state进行AIMD，是码率控制的核心实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AimdRateControl::ChangeBitrate</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;DataRate&gt; new_bitrate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取估算的吞吐量，并不一定是当前实际的吞吐量，可能由于各种情况是上一个预测码率，或者是探测码率</span></span><br><span class="line">  DataRate estimated_throughput =</span><br><span class="line">      input.estimated_throughput.<span class="built_in">value_or</span>(latest_estimated_throughput_);</span><br><span class="line">  <span class="comment">// 如果有新的估算吞吐量，更新latest_estimated_throughput_</span></span><br><span class="line">  <span class="keyword">if</span> (input.estimated_throughput)</span><br><span class="line">    latest_estimated_throughput_ = *input.estimated_throughput;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果比特率尚未初始化并且不是带宽超使用状态，则直接返回</span></span><br><span class="line">  <span class="comment">// bitrate_is_initialized_表示的是current_bitrate_是否被初始化</span></span><br><span class="line">  <span class="comment">// current_bitrate_被初始化的场景有两个：</span></span><br><span class="line">  <span class="comment">// 1.初始化时，外部调用SetStartBitrate()初始化current_bitrate_</span></span><br><span class="line">  <span class="comment">// 2.第一探测到overusing，到达两路最大容量，用这个值去初始化aimud的码率</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个判断表示的是current_bitrate_还未被设置，所以不做normal和increase，直接返回</span></span><br><span class="line">  <span class="comment">// 或者检测到kBwOverusing发现链路最大容量 ，要对对current_bitrate_进行初始化,并降低码率</span></span><br><span class="line">  <span class="keyword">if</span> (!bitrate_is_initialized_ &amp;&amp;</span><br><span class="line">      input.bw_state != BandwidthUsage::kBwOverusing)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断当前状态机状态</span></span><br><span class="line">  <span class="built_in">ChangeState</span>(input, at_time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (rate_control_state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcHold:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// kRcIncrease 状态</span></span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcIncrease: &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 估算吞吐量超过链路上限（历史吞吐量的指数平滑），预估的链路容积已经不准确，需要重置容量统计</span></span><br><span class="line">      <span class="comment">// 链路容积就是过载状态下的输入码率的平滑均值(历史值 * 95% + 采样值 * 5%)</span></span><br><span class="line">      <span class="keyword">if</span> (estimated_throughput &gt; link_capacity_.<span class="built_in">UpperBound</span>())</span><br><span class="line">        link_capacity_.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 限制新的比特率增加，以避免无限制的比特率增加</span></span><br><span class="line">      <span class="comment">// 允许在非常低的速率下有更多的滞后性，免编码器输出的码率波动导致的频繁阻塞</span></span><br><span class="line">      DataRate increase_limit =</span><br><span class="line">          <span class="number">1.5</span> * estimated_throughput + DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在ALR（Application-Limited Region）状态下，根据no_bitrate_increase_in_alr_决定是否继续进行码率增长</span></span><br><span class="line">      <span class="comment">// ALR下不要增加延迟基于的估算值，alr状态下持续码率增长，一旦出现码率暴增发送码率就会爆发式增大</span></span><br><span class="line">      <span class="comment">// 因为估算器将无法获得必要的传输反馈来检测新估算是否正确</span></span><br><span class="line">      <span class="keyword">if</span> (send_side_ &amp;&amp; in_alr_ &amp;&amp; no_bitrate_increase_in_alr_) &#123;</span><br><span class="line">        <span class="comment">// 如果先前的增加超过了限制（例如由于探测），则不允许进一步更改</span></span><br><span class="line">        increase_limit = current_bitrate_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前比特率小于增加限制，则进行增加</span></span><br><span class="line">      <span class="comment">// 当前码率是否接近链路容量进行加性或乘性增加</span></span><br><span class="line">      <span class="keyword">if</span> (current_bitrate_ &lt; increase_limit) &#123;</span><br><span class="line">        DataRate increased_bitrate = DataRate::<span class="built_in">MinusInfinity</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链路容量没有在上面被重置说明测量的吞吐量和预估链路容量相差不大</span></span><br><span class="line">        <span class="comment">// 也即计算出链路容量进入加性增加，因为当前瓶颈已知</span></span><br><span class="line">        <span class="keyword">if</span> (link_capacity_.<span class="built_in">has_estimate</span>()) &#123;</span><br><span class="line">          <span class="comment">// 加性增长，按照目前码率每秒增加1个包产生的带宽</span></span><br><span class="line">          DataRate additive_increase =</span><br><span class="line">              <span class="built_in">AdditiveRateIncrease</span>(at_time, time_last_bitrate_change_);</span><br><span class="line">          increased_bitrate = current_bitrate_ + additive_increase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// link_capacity_被重置了，预估的链路不准确</span></span><br><span class="line">          <span class="comment">// 乘性增加，8%的增量</span></span><br><span class="line">          DataRate multiplicative_increase = <span class="built_in">MultiplicativeRateIncrease</span>(</span><br><span class="line">              at_time, time_last_bitrate_change_, current_bitrate_);</span><br><span class="line">          increased_bitrate = current_bitrate_ + multiplicative_increase;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 限制新的比特率，不能超过吞吐量阈值</span></span><br><span class="line">        new_bitrate = std::<span class="built_in">min</span>(increased_bitrate, increase_limit);</span><br><span class="line">      &#125;</span><br><span class="line">      time_last_bitrate_change_ = at_time;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// kRcDecrease 状态</span></span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcDecrease: &#123;</span><br><span class="line">      DataRate decreased_bitrate = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">      <span class="comment">// 乘性减小</span></span><br><span class="line">      <span class="comment">// 输入码率的85% 作为新码率</span></span><br><span class="line">      decreased_bitrate = estimated_throughput * beta_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果减小的比特率大于5 Kbps，并且启用了额外的回退项</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &gt; DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">5</span>) &amp;&amp;</span><br><span class="line">          subtract_additional_backoff_term_) &#123;</span><br><span class="line">        decreased_bitrate -= DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 输入码率的85%仍然大于当前预估码率</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &gt; current_bitrate_) &#123;</span><br><span class="line">        <span class="comment">//  链路容量没有被重置，链路容量 * 0.85 作为新码率</span></span><br><span class="line">        <span class="keyword">if</span> (link_capacity_.<span class="built_in">has_estimate</span>()) &#123;</span><br><span class="line">          decreased_bitrate = beta_ * link_capacity_.<span class="built_in">estimate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 避免在过度使用时增加速率</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &lt; current_bitrate_) &#123;</span><br><span class="line">        new_bitrate = decreased_bitrate;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果比特率已初始化并且估算吞吐量小于当前比特率</span></span><br><span class="line">      <span class="keyword">if</span> (bitrate_is_initialized_ &amp;&amp; estimated_throughput &lt; current_bitrate_) &#123;</span><br><span class="line">        <span class="comment">// 有可能存在过度下降码率的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!new_bitrate.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">          last_decrease_ = DataRate::<span class="built_in">Zero</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 保存最后一次降低的码率</span></span><br><span class="line">          last_decrease_ = current_bitrate_ - *new_bitrate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果估算吞吐量远离估算的链路容量，则清除估算</span></span><br><span class="line">      <span class="comment">// 吞吐量比链路估计下限小太多，波动很大，link_capacity要reset</span></span><br><span class="line">      <span class="comment">// 因为link_capacity内部是一个使用estimated_throughput的指数平滑，</span></span><br><span class="line">      <span class="comment">// 差太多的时候继续做指数平滑被认为没有意义</span></span><br><span class="line">      <span class="keyword">if</span> (estimated_throughput &lt; link_capacity_.<span class="built_in">LowerBound</span>()) &#123;</span><br><span class="line">        link_capacity_.<span class="built_in">Reset</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当码率第一次下下降后认为已经探测到容量上限了，直接设置initialized_的状态</span></span><br><span class="line">      <span class="comment">// 标记比特率已初始化，更新链路容量的过载检测</span></span><br><span class="line">      bitrate_is_initialized_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 使用estimated_throughput做指数平滑</span></span><br><span class="line">      link_capacity_.<span class="built_in">OnOveruseDetected</span>(estimated_throughput);</span><br><span class="line">      rate_control_state_ = RateControlState::kRcHold;</span><br><span class="line">      time_last_bitrate_change_ = at_time;</span><br><span class="line">      time_last_bitrate_decrease_ = at_time;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_DCHECK_NOTREACHED</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 限制当前比特率并更新，避免发送端码率增长过快</span></span><br><span class="line">  current_bitrate_ = <span class="built_in">ClampBitrate</span>(new_bitrate.<span class="built_in">value_or</span>(current_bitrate_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AimdRateControl::ChangeState</code>由过载检测器发出的状态信息<code>kBwNormal/kBwUnderusing/kBwOverusing</code>改变状态机的状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AimdRateControl::ChangeState</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (input.bw_state) &#123;</span><br><span class="line">    <span class="comment">// 改变状态，if多一层判断</span></span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwNormal:</span><br><span class="line">      <span class="keyword">if</span> (rate_control_state_ == RateControlState::kRcHold) &#123;</span><br><span class="line">        time_last_bitrate_change_ = at_time;</span><br><span class="line">        rate_control_state_ = RateControlState::kRcIncrease;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// normal情况，当前状态由decrease提升到hold未实现</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwOverusing:</span><br><span class="line">      <span class="keyword">if</span> (rate_control_state_ != RateControlState::kRcDecrease) &#123;</span><br><span class="line">        rate_control_state_ = RateControlState::kRcDecrease;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwUnderusing:</span><br><span class="line">      rate_control_state_ = RateControlState::kRcHold;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_DCHECK_NOTREACHED</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加性增加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::AdditiveRateIncrease</span><span class="params">(Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Timestamp last_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 距离上次码率改变到现在的时间间隔</span></span><br><span class="line">  <span class="type">double</span> time_period_seconds = (at_time - last_time).<span class="built_in">seconds</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">  <span class="comment">// 加性增大的码率大小 = 距离上次码率改变到现在的时间间隔(s) * 每秒应该增加的码率大小</span></span><br><span class="line">  <span class="type">double</span> data_rate_increase_bps =</span><br><span class="line">      <span class="built_in">GetNearMaxIncreaseRateBpsPerSecond</span>() * time_period_seconds;</span><br><span class="line">  <span class="keyword">return</span> DataRate::<span class="built_in">BitsPerSec</span>(data_rate_increase_bps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在码率接近网络链路容量时，进行加性增大</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AimdRateControl::GetNearMaxIncreaseRateBpsPerSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查当前比特率是否为零</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!current_bitrate_.<span class="built_in">IsZero</span>());</span><br><span class="line">  <span class="comment">// 假设发送30fps，计算每帧的大小</span></span><br><span class="line">  <span class="type">const</span> TimeDelta kFrameInterval = TimeDelta::<span class="built_in">Seconds</span>(<span class="number">1</span>) / <span class="number">30</span>;</span><br><span class="line">  DataSize frame_size = current_bitrate_ * kFrameInterval;  <span class="comment">// 计算帧大小</span></span><br><span class="line">  <span class="comment">// 假设包大小为1200字节</span></span><br><span class="line">  <span class="type">const</span> DataSize kPacketSize = DataSize::<span class="built_in">Bytes</span>(<span class="number">1200</span>); </span><br><span class="line">  <span class="type">double</span> packets_per_frame = std::<span class="built_in">ceil</span>(frame_size / kPacketSize);  <span class="comment">// 计算每帧的包数</span></span><br><span class="line">  <span class="comment">// 计算平均包大小</span></span><br><span class="line">  DataSize avg_packet_size = frame_size / packets_per_frame;  </span><br><span class="line">  <span class="comment">// 假设拥塞控制器的响应时间为100ms</span></span><br><span class="line">  <span class="comment">// 再乘2表示往返时间 </span></span><br><span class="line">  TimeDelta response_time = rtt_ + TimeDelta::<span class="built_in">Millis</span>(<span class="number">100</span>);</span><br><span class="line">  response_time = response_time * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 加性增大的原则是：每一个 response_time 增加一个包的大小</span></span><br><span class="line">  <span class="comment">// avg_packet_size / response_time 得到的是一秒的字节数</span></span><br><span class="line">  <span class="comment">// .bps&lt;double&gt;(); 转化为比特数</span></span><br><span class="line">  <span class="comment">// 也就是 增加速率 = 包大小 / 响应时间</span></span><br><span class="line">  <span class="type">double</span> increase_rate_bps_per_second =</span><br><span class="line">      (avg_packet_size / response_time).<span class="built_in">bps</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">  <span class="comment">// 最少要增长4kbps码率</span></span><br><span class="line">  <span class="type">double</span> kMinIncreaseRateBpsPerSecond = <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(kMinIncreaseRateBpsPerSecond, increase_rate_bps_per_second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>乘性增加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::MultiplicativeRateIncrease</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp last_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate current_bitrate)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> alpha = <span class="number">1.08</span>;</span><br><span class="line">  <span class="comment">// 根据上次码率更新所经过的时间作为指数计算alpha，最大为1.08</span></span><br><span class="line">  <span class="keyword">if</span> (last_time.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> time_since_last_update = at_time - last_time;</span><br><span class="line">    alpha = <span class="built_in">pow</span>(alpha, std::<span class="built_in">min</span>(time_since_last_update.<span class="built_in">seconds</span>&lt;<span class="type">double</span>&gt;(), <span class="number">1.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加量为当前比特率乘以增加比例减1</span></span><br><span class="line">  DataRate multiplicative_increase =</span><br><span class="line">      std::<span class="built_in">max</span>(current_bitrate * (alpha - <span class="number">1.0</span>), DataRate::<span class="built_in">BitsPerSec</span>(<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">return</span> multiplicative_increase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>AimdRateControl期望在前5秒通过外部的5ms包组集来估算初始码率，之后根据当前链路拥塞状态、当前码率控制状态，来判断下一刻的码率控制状态，如果下一刻码率控制状态为增加，则根据当前是否已经探测到链路的容积来决定是“加性”缓慢增速，还是“乘性”快速增速，如果下一刻码率控制状态为减少，则“乘性”降低码率，否则保持码率不变。</p>
<h2 id="基于丢包的带宽估计"><a href="#基于丢包的带宽估计" class="headerlink" title="基于丢包的带宽估计"></a>基于丢包的带宽估计</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>基于延时的算法通过监测网络延时的变化趋势来估计可用带宽，只在网络路径上的缓存队列比较长时才比较可靠。如果缓存队列较短，则可以根据丢包率来判断是否存在过载。相比之下，基于丢包的算法是应对已经发生拥塞情况的紧急措施。在物理链路中，大量丢包通常发生在路由器缓冲区已满时，这时必须降低发送数据量以使网络恢复。</p>
<p>发送端的基于丢包率的带宽估计方法是根据丢包数量评估网络拥塞程度，目的是当延迟估计模块的带宽调整不够及时时，可以用丢包率来进一步调整。丢包越多，表示网络拥塞越严重，需要降低发送码率来减轻拥塞；如果没有丢包，则说明网络状况良好，可以增加发送码率来探测更多可用带宽。该算法的关键是获取接收端的丢包率，并确定降低和提高发送码率的阈值。</p>
<script type="math/tex; mode=display">
A_s(t_k) = \begin{cases}
    1.08\cdot A_s(t_{k-1}) & f_l(t_k)<0.02 \\
    A_s(t_{k-1}) & 0.02 \leq f_l(t_k) \leq 0.1 \\
    A_s(t_{k-1})(1-0.5f_l(t_k)) & f_l(t_k)>0.1

\end{cases}</script><p>当丢包率大于10%时，认为网络拥塞严重，应该主动降低发送码率以减轻拥塞。丢包率越高，发送码率降低的越多，最大可降低到原码率的50%。当丢包率小于2%时，认为网络状况良好，可以适当提高发送码率5%，探测是否有更多带宽可用。当丢包率在2%~10%时,认为网络拥塞一般，此时保持当前发送码率不变。这可以避免网络固有丢包被错判为拥塞导致不必要的码率降低，而这部分丢包则需要通过NACK、FEC等其他机制来进行数据恢复。</p>
<p>接收端通过两个时刻的最大序号之差得到两个时刻之间的期望包数，统计两个时刻之间的实际接收到的包数，计算得到单个流的两个时刻的丢包率(fraction lost)，然后将丢包率(fraction lost)、累计丢包(cumulative packet lost)、最大序列号等字段填到RR包的Report Block中发送给发送端。发送端累计RR包中所有流的所有Report Block的丢包，计算总的丢包率。</p>
<p><code>REB-GCC</code>在发送端实现，主要是<code>SendSideBandwidthEstimation</code>类。<code>SendSideBandwidthEstimation::SetSendBitrate</code>函数设置初始的预估带宽为300kbps。<code>SendSideBandwidthEstimation::UpdateEstimate</code>函数根据丢包、RTT及当前带宽的估计值调整下个时刻的估计带宽，在函数中有三次调用：</p>
<ul>
<li><code>SendSideBandwidthEstimation::UpdatePacketsLost</code>函数</li>
<li><code>SendSideBandwidthEstimation::UpdateLossBasedEstimator</code>函数</li>
<li><code>GoogCcNetworkController::OnProcessInterval</code>函数</li>
</ul>
<p>主要有两种触发方式<font color='red'>要修改</font>：</p>
<ul>
<li>收到RR包，受限于RR包的频率，大概1秒1次，更新了丢包率、RTT之后调用；</li>
<li>定时器，25ms一次，kUpdateIntervalMs=25，这个应该是为了防止RR包丢失或者不及时，更迅速灵敏的进行调整；</li>
</ul>
<p>基于发送端接收对端反馈过来的RR或SR报文，并对报文的发送者报告块进行解析，解析其RTT和丢包率</p>
<p>如果丢包率比较大说明网络状态不大好，将丢包信息和RTT更新到GoogCcNetworkController模块，评估新的发送码率。</p>
<p>最后在RtpTransportControllerSend模块中将新评估出的码率作用到pacer模块</p>
<h3 id="接收端接收处理RTP-RTCP包"><a href="#接收端接收处理RTP-RTCP包" class="headerlink" title="接收端接收处理RTP/RTCP包"></a>接收端接收处理RTP/RTCP包</h3><p>接收端接收并处理RTP包的函数调用过程为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReceiveStatisticsImpl::OnRtpPacket</span><br><span class="line">-&gt;StreamStatisticianImpl::UpdateCounters-&gt;StreamStatisticianImpl::UpdateOutOfOrder-&gt;StreamStatisticianImpl::IsRetransmitOfOldPacket</span><br></pre></td></tr></table></figure></p>
<p>对于每一个接收的RTP包，在更新统计信息时，涉及到乱序、丢包、重传等问题的处理。</p>
<p>当前接收的包是否是乱序包的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamStatisticianImpl::UpdateOutOfOrder</span><span class="params">(<span class="type">const</span> RtpPacketReceived&amp; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> sequence_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              Timestamp now)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 说明上一个包的序列号是乱序的</span></span><br><span class="line">  <span class="keyword">if</span> (received_seq_out_of_order_) &#123;</span><br><span class="line">    <span class="comment">// 抵消掉第二个if中的 ++cumulative_loss_，也就是说不把上一个包计算为丢包</span></span><br><span class="line">    --cumulative_loss_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果序列号的差值不大，那么流重启的可能性就更大。</span></span><br><span class="line">    <span class="comment">// 所以这里会把预期的序列号设置为上一个乱序包的序列号 + 1</span></span><br><span class="line">    <span class="comment">// 序列号差值过大,更可能是丢包或其他问题导致</span></span><br><span class="line">    <span class="type">uint16_t</span> expected_sequence_number = *received_seq_out_of_order_ + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 清除乱序包记录，重置状态</span></span><br><span class="line">    received_seq_out_of_order_ = absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前包的序列号与预期的序列号相同，认为是发生了流重启，忽略序列号的跳变</span></span><br><span class="line">    <span class="keyword">if</span> (packet.<span class="built_in">SequenceNumber</span>() == expected_sequence_number) &#123;</span><br><span class="line">      <span class="comment">// 通过减去2来更新 RR 中的最大序列号，避免将流重启导致的序号跳变计入丢包数中</span></span><br><span class="line">      last_report_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">      received_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//返回false，按照顺序包处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序号差值超过最大乱序阈值，发生序列号的“跳变”现象，</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">abs</span>(sequence_number - received_seq_max_) &gt;</span><br><span class="line">      max_reordering_threshold_) &#123;</span><br><span class="line">    <span class="comment">// 将当前包标记为乱序包，等待下一个包来判断是否为流重启（第一个if）</span></span><br><span class="line">    received_seq_out_of_order_ = packet.<span class="built_in">SequenceNumber</span>();</span><br><span class="line">    <span class="comment">// 暂时将这个包计算为丢包，在下一个包到来的时候，</span></span><br><span class="line">    <span class="comment">// 第一个if中执行（--cumulative_loss_）抵消掉</span></span><br><span class="line">    ++cumulative_loss_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里进行正常顺序包的判断</span></span><br><span class="line">  <span class="keyword">if</span> (sequence_number &gt; received_seq_max_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前包sequence_number &lt;= received_seq_max_，那么这个包就可能是重传的、乱序的</span></span><br><span class="line">  <span class="comment">// 如果启用了重传检测并且这个包是重传的，就把这个包添加到重传计数器中</span></span><br><span class="line">  <span class="keyword">if</span> (enable_retransmit_detection_ &amp;&amp; <span class="built_in">IsRetransmitOfOldPacket</span>(packet, now))</span><br><span class="line">    receive_counters_.retransmitted.<span class="built_in">AddPacket</span>(packet);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true 表示乱序包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行RR包参数信息的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamStatisticianImpl::UpdateCounters</span><span class="params">(<span class="type">const</span> RtpPacketReceived&amp; packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查传入RTP包的SSRC和当前统计的流的SSRC相匹配</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_EQ</span>(ssrc_, packet.<span class="built_in">Ssrc</span>());</span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">  <span class="comment">// 更新接收码率统计信息</span></span><br><span class="line">  incoming_bitrate_.<span class="built_in">Update</span>(packet.<span class="built_in">size</span>(), now); </span><br><span class="line">  <span class="comment">// 更新接收包统计计数器</span></span><br><span class="line">  receive_counters_.transmitted.<span class="built_in">AddPacket</span>(packet);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收到一个包累积丢包数先减一</span></span><br><span class="line">  --cumulative_loss_; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用包序号解包器获取RTP包的序号，但不立即更新解包器状态</span></span><br><span class="line">  <span class="comment">// 这样可以先处理乱序的包，避免更新状态</span></span><br><span class="line">  <span class="type">int64_t</span> sequence_number = seq_unwrapper_.<span class="built_in">PeekUnwrap</span>(packet.<span class="built_in">SequenceNumber</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次接收到 RTP 数据包，记录信息</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReceivedRtpPacket</span>()) &#123;</span><br><span class="line">    received_seq_first_ = sequence_number;</span><br><span class="line">    last_report_seq_max_ = sequence_number - <span class="number">1</span>;</span><br><span class="line">    received_seq_max_ = sequence_number - <span class="number">1</span>;</span><br><span class="line">    receive_counters_.first_packet_time = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UpdateOutOfOrder</span>(packet, sequence_number, now)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查到重传、乱序、重复包，这里会然后直接return，结果是上边的</span></span><br><span class="line">    <span class="comment">// --cumulative_loss_; 没有抵消回去，造成cumulative_loss_ - 1</span></span><br><span class="line">    <span class="comment">// 如果丢失的包后边重传收到了，或者乱序导致晚到，不影响后边计算丢包。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序包直接根据序号差计算丢包数：</span></span><br><span class="line">  <span class="comment">// 1）没有丢包，正常顺序包情况下，sequence_number = received_seq_max_ + 1，</span></span><br><span class="line">  <span class="comment">//    这里执行cumulative_loss_ += sequence_number - received_seq_max_ 就是+1，</span></span><br><span class="line">  <span class="comment">//    把--cumulative_loss_;减少的1补上了，相当于没丢包</span></span><br><span class="line">  <span class="comment">// 2）丢了N个包，顺序包情况下，sequence_number = received_seq_max_ + N + 1，</span></span><br><span class="line">  <span class="comment">//    这里执行cumulative_loss_ += sequence_number - received_seq_max_ 加上的是 N+1，</span></span><br><span class="line">  <span class="comment">//    把开头的--cumulative_loss_;减少的1补上，最终cumulative_loss_加上的是N。</span></span><br><span class="line">  cumulative_loss_ += sequence_number - received_seq_max_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新接收到的最大序号</span></span><br><span class="line">  received_seq_max_ = sequence_number;</span><br><span class="line">  <span class="comment">// 在包序号解包器中更新序号状态</span></span><br><span class="line">  seq_unwrapper_.<span class="built_in">Unwrap</span>(packet.<span class="built_in">SequenceNumber</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果时间戳改变，并且收到了多个顺序包，更新抖动</span></span><br><span class="line">  <span class="keyword">if</span> (packet.<span class="built_in">Timestamp</span>() != last_received_timestamp_ &amp;&amp;</span><br><span class="line">      (receive_counters_.transmitted.packets -</span><br><span class="line">       receive_counters_.retransmitted.packets) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">UpdateJitter</span>(packet, now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最后接收到包的时间戳和接收时间</span></span><br><span class="line">  last_received_timestamp_ = packet.<span class="built_in">Timestamp</span>();</span><br><span class="line">  last_receive_time_ = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR包中，<code>extended highest sequence number received</code>字段用32bits表示，传进来的序列号<code>packet.SequenceNumber()</code>是uint16_t，这里会先得到扩展到int64_t sequence_number，在构建RR包时候，<code>SetExtHighestSeqNum</code>函数会在将其转为<code>uint32_t</code>。</p>
<p>三个例子理解上边的两个函数关系：</p>
<ul>
<li><p>流重启（网络连接中断后重新建立，或者发送端重新启动等情况）导致连续增长序列号出现跳变：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 500, 501, 502…</p>
<ol>
<li>接收到序号500时，<code>cumulative_loss_=-1，received_seq_max_=10</code>，满足<code>std::abs(sequence_number - received_seq_max_) &gt; max_reordering_threshold_</code>，将500标记为乱序包，暂时计为丢包，此时<code>cumulative_loss_=0，received_seq_max_=10</code>。</li>
<li>在下一个包（501）到达的时候，<code>cumulative_loss_=-1，received_seq_max_=10</code>。由于上一个包500是乱序的，执行UpdateOutOfOrder的第一个if，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>。发现这个包的序列号与预期的序列号（500 + 1 = 501）相同，所以认为<strong>发生了流重启</strong>，执行下边的代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last_report_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">received_seq_max_ = sequence_number - <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
将两个参数都置位499。</li>
<li>包<code>501</code>按照正常顺序处理。在<code>UpdateCounters</code>函数中，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-2 += 501 - 499</code>，最终<code>cumulative_loss_=0</code>。就是<code>忽略掉了序列号的跳变，避免计入丢包数</code>。相当于这个跳变是接续这序列号499后边进行传输</li>
</ol>
</li>
<li><p>连续增长出现了最大值又降下来的1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 500, 11, 12…</p>
<ol>
<li>接收到序号500时，<code>cumulative_loss_=-1，received_seq_max_=10</code>，跳变判定条件成立，将500标记为乱序包，暂时计为丢包。此时<code>cumulative_loss_=0，received_seq_max_=10</code></li>
<li>在下一个包（11）到达的时候，<code>cumulative_loss_=-1，received_seq_max_=10</code>。上一个包500是乱序的，执行到UpdateOutOfOrder函数的第一个if，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>。这个包的序列号与预期的序列号（500 + 1 = 501）不同，<strong>不认为发生了流重启，继续处理</strong>，同时不满足第二个if乱序包的判断。因为<code>sequence_number &gt; received_seq_max_</code>，该包按照正常包来处理，UpdateOutOfOrder返回false。</li>
<li><code>UpdateCounters</code>函数继续执行，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-2+=11-10</code>，最终<code>cumulative_loss_=-1</code>，负值会在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中有对应的处理。所以相当于丢1个包。</li>
</ol>
</li>
<li><p>出现了重复的包：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 12…</p>
<ol>
<li>收到第一个序号11的包，<code>cumulative_loss_=-1，received_seq_max_=10</code>，顺序包，<code>UpdateCounters</code>继续执行，此时<code>cumulative_loss_=0，received_seq_max_=11</code>。</li>
<li>第二个序号11的包到达，<code>cumulative_loss_=-1，received_seq_max_=11</code>，执行乱序的判断。UpdateOutOfOrder返回true，不继续执行<code>UpdateCounters</code>函数，保持<code>cumulative_loss_=-1，received_seq_max_=11</code>。</li>
<li>第三个序号11的包达到，<code>cumulative_loss_=-2，received_seq_max_=11</code>，执行乱序的判断，UpdateOutOfOrder返回true，不继续执行<code>UpdateCounters</code>函数，保持<code>cumulative_loss_=-2，received_seq_max_=11</code>。</li>
<li>序号11的包到达，<code>cumulative_loss_=-3，received_seq_max_=11</code>，是正常序列号，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-3 += 12-11</code>，最终<code>cumulative_loss_=-2</code>。负值会在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中有对应的处理。所以相当于丢2个包。</li>
</ol>
</li>
</ul>
<p>关于<code>cumulative_loss_</code>，<code>RFC 3550</code>中有一段描述：</p>
<blockquote><p>This number is defined to be the number of packets expected less the number of packets actually received, where the number of packets received includes any which are late or duplicates. Thus, packets that arrive late are not counted as lost, and the loss may be negative if there are duplicates.  </p>
<footer><strong>RFC3550</strong><cite><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3550#section-6.4.1">datatracker.ietf.org/doc/html/rfc3550#section-6.4.1</a></cite></footer></blockquote>
<p>翻译过来意思是：<strong>这个数字被定义为预期的数据包数量减去实际接收到的数据包数量，其中接收到的数据包数量包括任何延迟或重复的数据包。因此，延迟到达的数据包不会被计算为丢失，如果有重复的数据包，丢失的数量可能为负。</strong></p>
<h3 id="接收端构造RR包"><a href="#接收端构造RR包" class="headerlink" title="接收端构造RR包"></a>接收端构造RR包</h3><p>接收端计算的<code>fraction lost</code>是两个RTCP RR包之间的丢包率。接收端每次可以获取到<code>当前已接收到的最大包序列号</code>以及<code>当前累计丢包数</code>。只需要维护<code>上一次发送RR包时接收到的最大包序列号</code>和<code>上一次发送RR包时的累计丢包数</code>。即只要知道<strong>一个统计间隔内期望收到的包的总数以及丢失的包数量</strong>，就能够计算两个RR报文之间的丢包率。</p>
<p>RR包中<code>fraction lost</code>和<code>cumulative number of packets lost</code>字段用来表明丢包率和累计丢包个数。</p>
<script type="math/tex; mode=display">
fractionlost =\frac{cumulative\_loss\_ - last\_report\_cumulative\_loss\_}{
received\_seq\_max\_ - last\_report\_seq\_max\_}</script><p>上边式子中的变量：</p>
<ul>
<li>received_seq_max_: 目前已接收的最大包序列号</li>
<li>last_report_seq_max_: 上一次发送RR包时接收到的最大包序列号</li>
<li>cumulative_loss_: 目前累计丢包数</li>
<li>last_report_cumulative_loss_: 上一次发送RR包时累计丢包数</li>
</ul>
<p>接收端构造RR包的函数调用过程为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RTCPSender::BuildRR</span><br><span class="line">-&gt;RTCPSender::CreateReportBlocks</span><br><span class="line">-&gt;ReceiveStatisticsImpl::RtcpReportBlocks</span><br><span class="line">-&gt;StreamStatisticianImpl::MaybeAppendReportBlockAndReset</span><br></pre></td></tr></table></figure></p>
<p>丢包计算在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamStatisticianImpl::MaybeAppendReportBlockAndReset</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;rtcp::ReportBlock&gt;&amp; report_blocks)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 之前没有接收到 RTP 数据包</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReceivedRtpPacket</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">  <span class="comment">// 距离上次接收的时间超过了设定的统计超时时间8s，视为不活跃</span></span><br><span class="line">  <span class="keyword">if</span> (now - *last_receive_time_ &gt;= kStatisticsTimeout) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  report_blocks.<span class="built_in">emplace_back</span>();</span><br><span class="line">  rtcp::ReportBlock&amp; stats = report_blocks.<span class="built_in">back</span>();</span><br><span class="line">  stats.<span class="built_in">SetMediaSsrc</span>(ssrc_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个统计间隔内期望收到的包的总数</span></span><br><span class="line">  <span class="type">int64_t</span> exp_since_last = received_seq_max_ - last_report_seq_max_;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_GE</span>(exp_since_last, <span class="number">0</span>); </span><br><span class="line">  <span class="comment">// 一个统计间隔内累计丢包数</span></span><br><span class="line">  <span class="type">int32_t</span> lost_since_last = cumulative_loss_ - last_report_cumulative_loss_;</span><br><span class="line">  <span class="keyword">if</span> (exp_since_last &gt; <span class="number">0</span> &amp;&amp; lost_since_last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 限制在(0,255)范围内，降低精度以8位存储</span></span><br><span class="line">    stats.<span class="built_in">SetFractionLost</span>(<span class="number">255</span> * lost_since_last / exp_since_last);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 累计丢包数进行修正，并处理发送方累计丢包数为负数的情况</span></span><br><span class="line">  <span class="type">int</span> packets_lost = cumulative_loss_ + cumulative_loss_rtcp_offset_;</span><br><span class="line">  <span class="keyword">if</span> (packets_lost &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    packets_lost = <span class="number">0</span>;</span><br><span class="line">    cumulative_loss_rtcp_offset_ = -cumulative_loss_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cumulative number of packets lost是 24 bits有符号数</span></span><br><span class="line">  <span class="keyword">if</span> (packets_lost &gt; <span class="number">0x7fffff</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cumulative_loss_is_capped_) &#123;</span><br><span class="line">      cumulative_loss_is_capped_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Cumulative loss reached maximum value for ssrc &quot;</span></span><br><span class="line">                          &lt;&lt; ssrc_;</span><br><span class="line">    &#125;</span><br><span class="line">    packets_lost = <span class="number">0x7fffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置RR包中的累计丢包数、最大序列号、抖动信息</span></span><br><span class="line">  stats.<span class="built_in">SetCumulativeLost</span>(packets_lost);</span><br><span class="line">  stats.<span class="built_in">SetExtHighestSeqNum</span>(received_seq_max_);</span><br><span class="line">  stats.<span class="built_in">SetJitter</span>(jitter_q4_ &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 更新最大序列号和累计丢包数，下一个统计周期使用</span></span><br><span class="line">  last_report_cumulative_loss_ = cumulative_loss_;</span><br><span class="line">  last_report_seq_max_ = received_seq_max_;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT_WITH_SSRC</span>(<span class="number">1</span>, <span class="string">&quot;cumulative_loss_pkts&quot;</span>, now.<span class="built_in">ms</span>(),</span><br><span class="line">                                  cumulative_loss_, ssrc_);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT_WITH_SSRC</span>(<span class="number">1</span>, <span class="string">&quot;received_seq_max_pkts&quot;</span>, now.<span class="built_in">ms</span>(),</span><br><span class="line">                                  (received_seq_max_ - received_seq_first_),</span><br><span class="line">                                  ssrc_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边计算一段时间窗口内的丢包率，如果发生<code>重传、乱序或者重复包</code>等问题，包的序列号会出现错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... 3 4 5 [6 7 9 11 10] ...</span><br></pre></td></tr></table></figure>
<p>这里计算的丢包率是包括重传包后的丢包率，收到重传包会导致比原始丢包率低，那么Sendside BWE用这个丢包率进行码率估计就有误差。Webrtc中的RTX机制，<strong>重传包用额外SSRC的包发送</strong>，这样重传包就不会算在原始媒体包的统计，就能得到原始的丢包率。</p>
<h3 id="发送端基于丢包估计码率"><a href="#发送端基于丢包估计码率" class="headerlink" title="发送端基于丢包估计码率"></a>发送端基于丢包估计码率</h3><p>基于丢包的带宽估计共有三个实现，分别是<code>SendSideBandwidthEstimation</code>类实现、<code>LossBasedBandwidthEstimation</code>和<code>LossBasedBweV2</code>。这里主要讲第一种。发送端解析接收端发过来的 RTCP RR 报文的lost fraction字段来判断丢包，RTT的计算等，用到基于丢包的BWE中。调用流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RTCPReceiver::IncomingPacket</span><br><span class="line">-&gt;RTCPReceiver::TriggerCallbacksFromRtcpPacket</span><br><span class="line">-&gt;RtpTransportControllerSend::OnReport</span><br><span class="line">-&gt;GoogCcNetworkController::OnTransportLossReport</span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdatePacketsLost  </span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdateEstimate</span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdateTargetBitrate</span><br><span class="line">-&gt;current_target_ = new_bitrate;</span><br></pre></td></tr></table></figure>
<p><code>RTCPReceiver::IncomingPacket</code>函数对接收到的RTCP报文进行处理。<code>RTCPReceiver::ParseCompoundPacket</code>函数解析收到的报文，对SR和RR报文调用<code>RTCPReceiver::HandleReportBlock</code>函数解析计算得到RTT和丢包率，并将解析的结果封装到PacketInformation中，然后调用<code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>进行回调处理。</p>
<blockquote><p>RTT的计算考虑，A发送SR给B，B接收到之后发送RR给A。A发送最后SR包的时间是LSR，B接受SR并处理回复RR包的时间间隔是DLSR，A接收到RR包的时间是T。那么RTT=T-LSR-DLSR。</p>
</blockquote>
<p><code>TriggerCallbacksFromRtcpPacket</code>回调进行带宽估计部分实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::TriggerCallbacksFromRtcpPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketInformation&amp; packet_information)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (network_link_rtcp_observer_) &#123;</span><br><span class="line">    Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (packet_information.packet_type_flags &amp; kRtcpRemb) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReceiverEstimatedMaxBitrate</span>(</span><br><span class="line">          now, DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">                   packet_information.receiver_estimated_max_bitrate_bps));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基于丢包带宽估计</span></span><br><span class="line">    <span class="keyword">if</span> (!packet_information.report_block_datas.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReport</span>(</span><br><span class="line">          now, packet_information.report_block_datas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基于RTT的带宽估计</span></span><br><span class="line">    <span class="keyword">if</span> (packet_information.rtt.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnRttUpdate</span>(now, *packet_information.rtt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基于延迟的带宽估计</span></span><br><span class="line">    <span class="keyword">if</span> (packet_information.transport_feedback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 将包转给RtpTransportControllerSend::OnTransportFeedback处理</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnTransportFeedback</span>(</span><br><span class="line">          now, *packet_information.transport_feedback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::OnReport</code>实现基于丢包的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnReport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    rtc::ArrayView&lt;<span class="type">const</span> ReportBlockData&gt; report_blocks)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="keyword">if</span> (report_blocks.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 丢包数和收到的包数的增量</span></span><br><span class="line">  <span class="type">int</span> total_packets_lost_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> total_packets_delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有的报告块，可能有音频、视频等不同流的报告块，计算丢包数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> ReportBlockData&amp; report_block : report_blocks) &#123;</span><br><span class="line">    <span class="comment">// 报告块已存在，则不会插入</span></span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] =</span><br><span class="line">        last_report_blocks_.<span class="built_in">try_emplace</span>(report_block.<span class="built_in">source_ssrc</span>());</span><br><span class="line"></span><br><span class="line">    LossReport&amp; last_loss_report = it-&gt;second;</span><br><span class="line">    <span class="comment">// 报告块已存在，累加丢包数和收到的包数的增量</span></span><br><span class="line">    <span class="keyword">if</span> (!inserted) &#123;</span><br><span class="line">      total_packets_delta += report_block.<span class="built_in">extended_highest_sequence_number</span>() -</span><br><span class="line">                             last_loss_report.extended_highest_sequence_number;</span><br><span class="line">      total_packets_lost_delta +=</span><br><span class="line">          report_block.<span class="built_in">cumulative_lost</span>() - last_loss_report.cumulative_lost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新报告块的最高序列号和累计丢包数</span></span><br><span class="line">    last_loss_report.extended_highest_sequence_number =</span><br><span class="line">        report_block.<span class="built_in">extended_highest_sequence_number</span>();</span><br><span class="line">    last_loss_report.cumulative_lost = report_block.<span class="built_in">cumulative_lost</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!total_packets_delta)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 计算收到的包数的增量</span></span><br><span class="line">  <span class="type">int</span> packets_received_delta = total_packets_delta - total_packets_lost_delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packets_received_delta &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  TransportLossReport msg;</span><br><span class="line">  <span class="comment">// 得到后续需要的丢包统计信息</span></span><br><span class="line">  msg.packets_lost_delta = total_packets_lost_delta;</span><br><span class="line">  msg.packets_received_delta = packets_received_delta;</span><br><span class="line">  msg.receive_time = receive_time;</span><br><span class="line">  msg.start_time = last_report_block_time_;</span><br><span class="line">  msg.end_time = receive_time;</span><br><span class="line">  <span class="comment">// 将TransportLossReport传递给GoogCcNetworkController模块</span></span><br><span class="line">  <span class="keyword">if</span> (controller_)</span><br><span class="line">    <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnTransportLossReport</span>(msg));</span><br><span class="line">  <span class="comment">// 更新最后一个报告块的时间</span></span><br><span class="line">  last_report_block_time_ = receive_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OnReport处理接收到的RTCP报告块，计算出丢包数和收到的包数，这些统计信息封装成TransportLossReport结构，最后调用<code>PostUpdates(controller_-&gt;OnTransportLossReport(msg))</code>，将TransportLossReport消息传递给GoogCcNetworkController模块进行基于丢包的码率估计，然后调用PostUpdates将新估计的码率作用到pacer模块。</p>
<p><code>OnTransportLossReport</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnTransportLossReport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TransportLossReport msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只使用数据包反馈，直接返回一个空的网络控制更新</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  <span class="comment">// 计算总的数据包增量，包括接收到的数据包（发送成功）和丢失的数据包</span></span><br><span class="line">  <span class="type">int64_t</span> total_packets_delta =</span><br><span class="line">      msg.packets_received_delta + msg.packets_lost_delta;</span><br><span class="line">  <span class="comment">// SendSideBandwidthEstimation::UpdatePacketsLost</span></span><br><span class="line">  <span class="comment">// 更新当前时间差范围内带宽估计，包括丢包数、总的数据包数和接收时间</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdatePacketsLost</span>(</span><br><span class="line">      msg.packets_lost_delta, total_packets_delta, msg.receive_time);</span><br><span class="line">  <span class="comment">// 这里构造了一个NetworkControlUpdate，没有对成员进行赋值。也就是说，</span></span><br><span class="line">  <span class="comment">// 经由RR或者SR报文的丢包情况对GoogCcNetworkController模块的真实作用</span></span><br><span class="line">  <span class="comment">// 是更新SendSideBandwidthEstimation模块中的发包数量、丢包数和接收时间</span></span><br><span class="line">  <span class="comment">// 而在RtpTransportControllerSend模块该阶段的最后调用栈中调用的PostUpdates函数实际上会直接返回，不会做任何事情。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SendSideBandwidthEstimation::UpdatePacketsLost</code>根据收到的丢包报告来更新丢包信息和带宽估计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdatePacketsLost</span><span class="params">(<span class="type">int64_t</span> packets_lost,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">int64_t</span> number_of_packets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新最后一次丢包反馈的时间</span></span><br><span class="line">  last_loss_feedback_ = at_time;</span><br><span class="line">  <span class="comment">// 第一次接收到丢包报告，则记录报告的时间</span></span><br><span class="line">  <span class="keyword">if</span> (first_report_time_.<span class="built_in">IsInfinite</span>())</span><br><span class="line">    first_report_time_ = at_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check sequence number diff and weight loss report</span></span><br><span class="line">  <span class="keyword">if</span> (number_of_packets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期的数据包数</span></span><br><span class="line">    <span class="type">int64_t</span> expected =</span><br><span class="line">        expected_packets_since_last_loss_update_ + number_of_packets;</span><br><span class="line">    <span class="comment">// 上一次处理丢包码率估计到本次处理丢包估计之间</span></span><br><span class="line">    <span class="comment">// 总发包数小于20个，不足以生成丢包率，则累积报告</span></span><br><span class="line">    <span class="keyword">if</span> (expected &lt; kLimitNumPackets) &#123;</span><br><span class="line">      <span class="comment">// 总包数</span></span><br><span class="line">      expected_packets_since_last_loss_update_ = expected;</span><br><span class="line">      <span class="comment">// 丢包数</span></span><br><span class="line">      lost_packets_since_last_loss_update_ += packets_lost;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送端两次统计间隔的包数已经超过20个，可以计算实际的丢包率</span></span><br><span class="line">    has_decreased_since_last_fraction_loss_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算丢包率时乘以了256，避免后面计算使用浮点表示</span></span><br><span class="line">    <span class="type">int64_t</span> lost_q8 =</span><br><span class="line">        std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(lost_packets_since_last_loss_update_ + packets_lost,</span><br><span class="line">                          <span class="number">0</span>)&lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 丢包率限制在(0,255)              </span></span><br><span class="line">    last_fraction_loss_ = std::<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(lost_q8 / expected, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算丢包率之后，重置发送端计数器</span></span><br><span class="line">    <span class="comment">// 每隔20个数据包计算一次丢包统计</span></span><br><span class="line">    <span class="comment">// 自上一次处理基于丢包码率估计到本次处理时间差之间丢包数</span></span><br><span class="line">    lost_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自上一次处理基于丢包码率估计到本次处理时间差之间总共的发包数量</span></span><br><span class="line">    expected_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    last_loss_packet_report_ = at_time;</span><br><span class="line">    <span class="comment">// 更新带宽估计</span></span><br><span class="line">    <span class="built_in">UpdateEstimate</span>(at_time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新丢包的统计信息</span></span><br><span class="line">  <span class="built_in">UpdateUmaStatsPacketsLost</span>(at_time, packets_lost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UpdatePacketsLost函数中，如果预期的数据包数还不足以生成丢包率，则会累积报告，直到有足够的数据包。然后，计算丢包率，并重置累积器。最后，更新带宽估计和丢包的统计信息。</p>
<p><code>SendSideBandwidthEstimation::UpdateEstimate</code>根据当前的网络状况（如丢包率、RTT等）来更新带宽估计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateEstimate</span><span class="params">(Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行RTT退避（可选开启）。RTT超过阈值，认为网络拥堵，降低发送码率</span></span><br><span class="line">  <span class="keyword">if</span> (rtt_backoff_.<span class="built_in">IsRttAboveLimit</span>()) &#123;</span><br><span class="line">    <span class="comment">// 距离上次降低带宽已经超过一个设定的间隔，并且当前目标带宽大于设定的最低带宽</span></span><br><span class="line">    <span class="keyword">if</span> (at_time - time_last_decrease_ &gt;= rtt_backoff_.drop_interval_ &amp;&amp;</span><br><span class="line">        current_target_ &gt; rtt_backoff_.bandwidth_floor_) &#123;</span><br><span class="line">      time_last_decrease_ = at_time;</span><br><span class="line">      <span class="comment">// 每次按照0.8倍退避，退避到的码率下限为5kbps</span></span><br><span class="line">      <span class="comment">// new_bitrate = max(current_target * 0.8, 5kbps)</span></span><br><span class="line">      DataRate new_bitrate =</span><br><span class="line">          std::<span class="built_in">max</span>(current_target_ * rtt_backoff_.drop_fraction_,</span><br><span class="line">                   rtt_backoff_.bandwidth_floor_.<span class="built_in">Get</span>());</span><br><span class="line">      <span class="comment">// 更新链路容量</span></span><br><span class="line">      link_capacity_.<span class="built_in">OnRttBackoff</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="comment">// 更新目标码率</span></span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未满足退避条件，没有降低比特率,直接应用目标比特率限制</span></span><br><span class="line">    <span class="comment">// 注意：在大多数情况下，这可能是多余的。</span></span><br><span class="line">    <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在启动阶段，如果没有报告丢包，我们会信任REMB和/或基于延迟的估计</span></span><br><span class="line">  <span class="keyword">if</span> (last_fraction_loss_ == <span class="number">0</span> &amp;&amp; <span class="built_in">IsInStartPhase</span>(at_time) &amp;&amp;</span><br><span class="line">      !loss_based_bandwidth_estimator_v2_-&gt;<span class="built_in">ReadyToUseInStartPhase</span>()) &#123;</span><br><span class="line">    <span class="comment">// 新的带宽设为当前目标带宽</span></span><br><span class="line">    DataRate new_bitrate = current_target_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取接收端码率限制和基于延时的估计码率的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (receiver_limit_.<span class="built_in">IsFinite</span>())</span><br><span class="line">      new_bitrate = std::<span class="built_in">max</span>(receiver_limit_, new_bitrate);</span><br><span class="line">    <span class="keyword">if</span> (delay_based_limit_.<span class="built_in">IsFinite</span>())</span><br><span class="line">      new_bitrate = std::<span class="built_in">max</span>(delay_based_limit_, new_bitrate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化基于丢包的带宽估计器V1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1Enabled</span>()) &#123;</span><br><span class="line">      loss_based_bandwidth_estimator_v1_.<span class="built_in">Initialize</span>(new_bitrate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标值变化，更新历史最低码率</span></span><br><span class="line">    <span class="keyword">if</span> (new_bitrate != current_target_) &#123;</span><br><span class="line">      min_bitrate_history_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1Enabled</span>()) &#123;</span><br><span class="line">        min_bitrate_history_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(at_time, new_bitrate));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 否则，将当前目标带宽和当前时间加入最小带宽历史</span></span><br><span class="line">        min_bitrate_history_.<span class="built_in">push_back</span>(</span><br><span class="line">            std::<span class="built_in">make_pair</span>(at_time, current_target_));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新历史最小比特率，维护最近1s内的最低估计码率</span></span><br><span class="line">  <span class="built_in">UpdateMinHistory</span>(at_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还没有上报过一次丢包率(可能没有RR包，或者有RR包了，但是累计包数未满20)，那么可以退出.</span></span><br><span class="line">  <span class="keyword">if</span> (last_loss_packet_report_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">    <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于丢包的带宽估计器V1或V2可以使用，就使用它们来更新带宽估计</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1ReadyForUse</span>()) &#123;</span><br><span class="line">    DataRate new_bitrate = loss_based_bandwidth_estimator_v1_.<span class="built_in">Update</span>(</span><br><span class="line">        at_time, min_bitrate_history_.<span class="built_in">front</span>().second, delay_based_limit_,</span><br><span class="line">        last_round_trip_time_);</span><br><span class="line">    <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV2ReadyForUse</span>()) &#123;</span><br><span class="line">    LossBasedBweV2::Result result =</span><br><span class="line">        loss_based_bandwidth_estimator_v2_-&gt;<span class="built_in">GetLossBasedResult</span>();</span><br><span class="line">    loss_based_state_ = result.state;</span><br><span class="line">    <span class="built_in">UpdateTargetBitrate</span>(result.bandwidth_estimate, at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次处理丢包统计和上次处理丢包统计的时间差</span></span><br><span class="line">  TimeDelta time_since_loss_packet_report = at_time - last_loss_packet_report_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 距离上次收到反馈不超过1.2*5 = 6s认为有效</span></span><br><span class="line">  <span class="keyword">if</span> (time_since_loss_packet_report &lt; <span class="number">1.2</span> * kMaxRtcpFeedbackInterval) &#123;</span><br><span class="line">    <span class="comment">// 丢包率之前扩大了256，现在只是缩减回去</span></span><br><span class="line">    <span class="type">float</span> loss = last_fraction_loss_ / <span class="number">256.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前目标码率小于阈值，或loss &lt; 2%时</span></span><br><span class="line">    <span class="keyword">if</span> (current_target_ &lt; bitrate_threshold_ || loss &lt;= low_loss_threshold_) &#123;</span><br><span class="line">      <span class="comment">// 以1s内最小带宽的1.08倍增加估计带宽，最小带宽通过UpdateMinHistory函数维护</span></span><br><span class="line">      DataRate new_bitrate = DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">          min_bitrate_history_.<span class="built_in">front</span>().second.<span class="built_in">bps</span>() * <span class="number">1.08</span> + <span class="number">0.5</span>);</span><br><span class="line">      <span class="comment">// 增加1kbps，确保码率低的时候不会增加太慢</span></span><br><span class="line">      new_bitrate += DataRate::<span class="built_in">BitsPerSec</span>(<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_target_ &gt; bitrate_threshold_) &#123;</span><br><span class="line">      <span class="comment">// 当前目标带宽大于带宽阈值</span></span><br><span class="line">      <span class="keyword">if</span> (loss &lt;= high_loss_threshold_) &#123;</span><br><span class="line">        <span class="comment">// 丢包率在2%到10%之间，保持当前速率</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Loss &gt; 10%</span></span><br><span class="line">        <span class="comment">// 自上次上报丢包以来，没有降低过码率，且上次降低码率已经过去了rtt + 300ms的时间</span></span><br><span class="line">        <span class="comment">// 以rtt + 300ms为频率，每次降低丢包率 * 50%的带宽</span></span><br><span class="line">        <span class="keyword">if</span> (!has_decreased_since_last_fraction_loss_ &amp;&amp;</span><br><span class="line">            (at_time - time_last_decrease_) &gt;=</span><br><span class="line">                (kBweDecreaseInterval + last_round_trip_time_)) &#123;</span><br><span class="line">          <span class="comment">// 记录降低码率的时间</span></span><br><span class="line">          time_last_decrease_ = at_time;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// newRate = rate * (1 - 0.5*lossRate)。</span></span><br><span class="line">          DataRate new_bitrate = DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">              (current_target_.<span class="built_in">bps</span>() *</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">512</span> - last_fraction_loss_)) /</span><br><span class="line">              <span class="number">512.0</span>);</span><br><span class="line">          <span class="comment">// 置位这个标记，直到下次上报丢包的时候再次清除,</span></span><br><span class="line">          <span class="comment">// 也就是两个限制，一个是需要上报丢包，这个需要两个RR的时间间隔，1个控制降速的时间间隔在rtt + 300ms,</span></span><br><span class="line">          <span class="comment">// 在丢包比较严重的时候以这个策略为主降低码率，如果抖动比较厉害则以REMB为主降低码率.</span></span><br><span class="line">          has_decreased_since_last_fraction_loss_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 应用目标带宽的限制</span></span><br><span class="line">  <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UpdateEstimate主要用于更新带宽估计。它会根据当前的网络状况，如RTT（Round-Trip Time）、丢包率等，来调整带宽估计。</p>
<ol>
<li>函数开始会进行RTT退避。TWCC反馈需要累计一定的报文或等待超时才会发送，这个延迟可能会导致TWCC计算的RTT不准。因此，会基于发包间隔检查RTT是否超过了设定的限制，RTT过高说明网络延迟大，需要降低带宽以减少网络拥塞。</li>
<li>在启动阶段，如果没有报告丢包，函数会信任REMB和/或基于延迟的估计，因为在启动阶段，网络状况通常相对稳定，REMB和延迟估计能够提供较为准确的带宽估计。</li>
<li>如果基于丢包的带宽估计器可以使用，函数会使用它们来更新带宽估计，因为丢包率是网络质量的重要指标，基于丢包的带宽估计器能够更准确地反映网络状况。</li>
<li>最后，函数会根据丢包率来调整带宽。如果丢包率过高，说明网络拥塞严重，此时需要降低带宽以减少丢包。反之，如果丢包率较低，说明网络状况良好，可以适当提高带宽以提高传输效率。</li>
</ol>
<p><code>SendSideBandwidthEstimation::UpdateTargetBitrate</code>函数更新码率：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataRate <span class="title">SendSideBandwidthEstimation::GetUpperLimit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// upper_limit为min[delay_based_limit_, receiver_limit_]</span></span><br><span class="line">  DataRate upper_limit = delay_based_limit_;</span><br><span class="line">  <span class="keyword">if</span> (disable_receiver_limit_caps_only_)</span><br><span class="line">    upper_limit = std::<span class="built_in">min</span>(upper_limit, receiver_limit_);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">min</span>(upper_limit, max_bitrate_configured_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateTargetBitrate</span><span class="params">(DataRate new_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新码率低于延迟预估码率(delay_based_limit_)                                                  </span></span><br><span class="line">  new_bitrate = std::<span class="built_in">min</span>(new_bitrate, <span class="built_in">GetUpperLimit</span>());</span><br><span class="line">  <span class="keyword">if</span> (new_bitrate &lt; min_bitrate_configured_) &#123;</span><br><span class="line">    <span class="comment">// 设置了最小目标码率，使用最小目标码率</span></span><br><span class="line">    <span class="built_in">MaybeLogLowBitrateWarning</span>(new_bitrate, at_time);</span><br><span class="line">    new_bitrate = min_bitrate_configured_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新当前目标码率</span></span><br><span class="line">  current_target_ = new_bitrate;</span><br><span class="line">  <span class="built_in">MaybeLogLossBasedEvent</span>(at_time);</span><br><span class="line">  <span class="comment">// 更新链路预估容量</span></span><br><span class="line">  link_capacity_.<span class="built_in">OnRateUpdate</span>(acknowledged_rate_, current_target_, at_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::OnRttUpdate</code>函数实现基于RTT的带宽估计。封装RoundTripTimeUpdate消息，最后调用<code>PostUpdates(controller_-&gt;OnRoundTripTimeUpdate(report));</code>，首先将RoundTripTimeUpdate消息发送给GoogCcNetworkController模块计算基于RTT的码率，然后调用PostUpdates刷新码率，作用到pacer发送模块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnRttUpdate</span><span class="params">(Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             TimeDelta rtt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  RoundTripTimeUpdate report;</span><br><span class="line">  report.receive_time = receive_time;</span><br><span class="line">  report.round_trip_time = rtt.<span class="built_in">RoundTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">  report.smoothed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (controller_ &amp;&amp; !report.round_trip_time.<span class="built_in">IsZero</span>())</span><br><span class="line">    <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnRoundTripTimeUpdate</span>(report));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnRoundTripTimeUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RoundTripTimeUpdate msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_ || msg.smoothed)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!msg.round_trip_time.<span class="built_in">IsZero</span>());</span><br><span class="line">  <span class="comment">// 基于延迟的BWE</span></span><br><span class="line">  <span class="keyword">if</span> (delay_based_bwe_)</span><br><span class="line">    delay_based_bwe_-&gt;<span class="built_in">OnRttUpdate</span>(msg.round_trip_time);</span><br><span class="line">  <span class="comment">// 更新RTT</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateRtt</span>(msg.round_trip_time, msg.receive_time);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateRtt</span><span class="params">(TimeDelta rtt, Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新RTT</span></span><br><span class="line">  <span class="keyword">if</span> (rtt &gt; TimeDelta::<span class="built_in">Zero</span>())</span><br><span class="line">    last_round_trip_time_ = rtt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsInStartPhase</span>(at_time) &amp;&amp; uma_rtt_state_ == kNoUpdate) &#123;</span><br><span class="line">    uma_rtt_state_ = kDone;</span><br><span class="line">    <span class="built_in">RTC_HISTOGRAM_COUNTS</span>(<span class="string">&quot;WebRTC.BWE.InitialRtt&quot;</span>, rtt.<span class="built_in">ms</span>&lt;<span class="type">int</span>&gt;(), <span class="number">0</span>, <span class="number">2000</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a name="gcc-analysis"></a> <a target="_blank" rel="noopener" href="https://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf">Analysis and Design of the Google Congestion Control for Web Real-time Communication (WebRTC)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab32a8a3552f">WebRTC基于TransportCC和Trendline Filter的发送端码率估计(Sendside-BWE)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rtcbits.com/2017/01/bandwidth-estimation-in-webrtc-and-new.html">Bandwidth Estimation in WebRTC (and the new Sender Side BWE)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sonysuqin/article/details/106186374">WebRTC GCC拥塞控制算法详解</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.jianchihu.net/webrtc-research-stats-loss-fraction-html.html">WebRTC研究：统计参数之丢包率</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqq_419/article/details/122282823">rtcp中的持续性丢包统计</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qw225967/article/details/125910410">流媒体学习之路(WebRTC)——GCC分析（1）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/490481512">WebRTC GCC代码深度解读(4) 基于Loss的带宽估计</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3MTUyNDUzMA==&amp;mid=2247483861&amp;idx=1&amp;sn=dda20ebd8af7837f106fb085bd8d8cd7">​WebRTC 拥塞控制 | 计算包组时间差-InterArrival</a></li>
</ol>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6TFB-GCC/">https://charstr.github.io/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6TFB-GCC/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/Webrtc/"># Webrtc</a>
                            
                            <a href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"># 拥塞控制</a>
                            
                            <a href="/tags/BWE/"># BWE</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/01/06/RTMP%E5%8D%8F%E8%AE%AE/">RTMP协议</a>
                      
                        
                          <a class="next" rel="next" href="/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6REMB-GCC/">Webrtc拥塞控制REMB-GCC</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>