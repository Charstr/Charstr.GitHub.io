<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc拥塞控制TFB-GCC | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!-- 通过连接CDN加载MathJax的js代码 -->
<!-- <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> -->


<!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script> -->

<script type="text/javascript" async
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc拥塞控制TFB-GCC
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">1月 6, 2024&nbsp;&nbsp;17:47:27</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/Webrtc/">Webrtc</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/BWE/">BWE</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <blockquote><p>Webrtc GCC拥塞控制算法原理及代码分析</p>
</blockquote>
<p>GCC结合延迟、丢包、抖动等网络参数情况，预测可用带宽来控制发送的码率，避免出现延迟、丢包、抖动等情况，是一个反馈过程。Webrtc有NACK、FEC等解决丢包问题，带宽估计对较小的丢包不太敏感，而对基于延迟的抖动更大的灵敏度。当延迟变大时，在忽略掉传输数据大小变化的影响后，可以认为是网络堵塞，需要降低码率；而在延迟变小的情况下，认为网络通常，可以提高码率。所以当网络延迟较大，但没有丢包的情况下，GCC也会对带宽进行很大程度的调整。也就是说，延迟稳定的情况下，即使延迟高也不影响带宽估计；如果延迟小但是抖动大，那就会迅速降低估测的带宽。</p>
<p>REMB-GCC在应对突发峰值流量方面存在一些问题：</p>
<ol>
<li>在初始阶段，系统处于Increase状态，当检测到Decrease状态时，会调整码率为 <script type="math/tex">A_r(t_i) = \alpha R_r(t_{i})</script>，此时，可能会出现 <script type="math/tex">R_r(t_{i})\ll A_r(t_{i-1})</script>的情况，导致在后续中 <script type="math/tex">A_r</script> 较小。如果此时需要发送关键帧，<strong>PacedSender队列中将有大量数据包等待发送，这将造成较大的排队延迟</strong>。</li>
<li>码率估计模块反馈给编码器的码率较低，但当编码器需要编码关键帧时，编码器给出的码率仍然比反馈的码率高，这将增加发送关键帧的数据包量。</li>
</ol>
<p>这样会导致发送端的排队延迟较大，从而导致接收端的jitterBuffer延迟也较大。目前<code>REMB-GCC算法</code>已被废弃，码率估计模块全部放在发送端。<code>TFB-GCC</code>算法进行了以下改进：</p>
<ol>
<li>延迟估算和丢包估算都在发送端处理，接收端只需要定期反馈RTCP包和丢包率。</li>
<li>延迟估算采用TrendLine滤波器代替Kalman滤波器，通过拟合直线计算延迟梯度，从而估算网络拥塞</li>
<li>添加了Transport-CC扩展，在每个RTP包头添加了<strong>transport_sequence_number</strong>扩展字段，标识唯一的RTP包。接收端收到后反馈一个<strong>Transport-CC RR报文</strong>，记录每个transport_sequence_number到达接收端的时间信息，发送端可以用来计算包组间的延迟差，实现基于延迟的带宽估计。</li>
</ol>
<p><img src="01.png" alt="p1" style="zoom:66%;" /></p>
<h1 id="发送端获取REMB码率"><a href="#发送端获取REMB码率" class="headerlink" title="发送端获取REMB码率"></a>发送端获取REMB码率</h1><p>发送端的<code>GoogCcNetworkController::OnRemoteBitrateReport</code>处理接收端消息中的REMB码率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnRemoteBitrateReport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RemoteBitrateReport msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_ERROR) &lt;&lt; <span class="string">&quot;Received REMB for packet feedback only GoogCC&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SendSideBandwidthEstimation::UpdateReceiverEstimate更新接收端码率</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateReceiverEstimate</span>(msg.receive_time,</span><br><span class="line">                                                msg.bandwidth);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;REMB_kbps&quot;</span>, msg.receive_time.<span class="built_in">ms</span>(),</span><br><span class="line">                        msg.bandwidth.<span class="built_in">bps</span>() / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新接收端REMB包预估带宽值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateReceiverEstimate</span><span class="params">(Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                         DataRate bandwidth)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接收端REMB反馈的估计带宽，作为发送端调整的上限</span></span><br><span class="line">  receiver_limit_ = bandwidth.<span class="built_in">IsZero</span>() ? DataRate::<span class="built_in">PlusInfinity</span>() : bandwidth;</span><br><span class="line">  <span class="comment">// 限制阈值范围</span></span><br><span class="line">  <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="发送端基于丢包的BWE"><a href="#发送端基于丢包的BWE" class="headerlink" title="发送端基于丢包的BWE"></a>发送端基于丢包的BWE</h1><h2 id="接收端统计信息并构造RR包"><a href="#接收端统计信息并构造RR包" class="headerlink" title="接收端统计信息并构造RR包"></a>接收端统计信息并构造RR包</h2><p>接收端计算的<code>fraction lost</code>是两个RTCP RR包之间的丢包率。接收端每次可以获取到<code>当前已接收到的最大包序列号</code>以及<code>当前累计丢包数</code>。只需要维护<code>上一次发送RR包时接收到的最大包序列号</code>和<code>上一次发送RR包时的累计丢包数</code>。即只要知道<strong>一个统计间隔内期望收到的包的总数以及丢失的包数量</strong>，就能够计算两个RR报文之间的丢包率。</p>
<p>RR包中<code>fraction lost</code>和<code>cumulative number of packets lost</code>字段用来表明丢包率和累计丢包个数。</p>
<script type="math/tex; mode=display">
\begin{equation}
fractionlost =\frac{cumulative\_loss\_ - last\_report\_cumulative\_loss\_}{
received\_seq\_max\_ - last\_report\_seq\_max\_}
\end{equation}</script><p>上边式子中的变量：</p>
<ul>
<li>received_seq_max_: 目前已接收的最大包序列号</li>
<li>last_report_seq_max_: 上一次发送RR包时接收到的最大包序列号</li>
<li>cumulative_loss_: 目前累计丢包数</li>
<li>last_report_cumulative_loss_: 上一次发送RR包时累计丢包数</li>
</ul>
<h3 id="统计信息获取"><a href="#统计信息获取" class="headerlink" title="统计信息获取"></a>统计信息获取</h3><p>接收端接收并处理RTP包后统计信息的调用过程为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReceiveStatisticsImpl::OnRtpPacket-&gt;StreamStatisticianImpl::UpdateCounters</span><br></pre></td></tr></table></figure>
<p>处理每个RTP包，更新计数器等统计信息，进行RR包参数信息的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamStatisticianImpl::UpdateCounters</span><span class="params">(<span class="type">const</span> RtpPacketReceived&amp; packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查传入RTP包的SSRC和当前统计的流的SSRC相匹配</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_EQ</span>(ssrc_, packet.<span class="built_in">Ssrc</span>());</span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">  <span class="comment">// 更新接收码率统计信息</span></span><br><span class="line">  incoming_bitrate_.<span class="built_in">Update</span>(packet.<span class="built_in">size</span>(), now); </span><br><span class="line">  <span class="comment">// 更新接收包统计计数器，用于计算丢包</span></span><br><span class="line">  receive_counters_.transmitted.<span class="built_in">AddPacket</span>(packet);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收到一个包累积丢包数先减一</span></span><br><span class="line">  --cumulative_loss_; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用包序号解包器获取RTP包的序号，但不立即更新解包器状态</span></span><br><span class="line">  <span class="comment">// 这样可以先处理乱序的包，避免更新状态</span></span><br><span class="line">  <span class="type">int64_t</span> sequence_number = seq_unwrapper_.<span class="built_in">PeekUnwrap</span>(packet.<span class="built_in">SequenceNumber</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次接收到 RTP 数据包，记录信息</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReceivedRtpPacket</span>()) &#123;</span><br><span class="line">    received_seq_first_ = sequence_number;</span><br><span class="line">    last_report_seq_max_ = sequence_number - <span class="number">1</span>;</span><br><span class="line">    received_seq_max_ = sequence_number - <span class="number">1</span>;</span><br><span class="line">    receive_counters_.first_packet_time = now;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UpdateOutOfOrder</span>(packet, sequence_number, now)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查到重传、乱序、重复包，这里会然后直接return，结果是上边的</span></span><br><span class="line">    <span class="comment">// --cumulative_loss_; 没有抵消回去，造成cumulative_loss_ - 1</span></span><br><span class="line">    <span class="comment">// 如果丢失的包后边重传收到了，或者乱序导致晚到，不影响后边计算丢包。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断包是否是乱序的包，如果是乱序的，可能重传的包，如果是重传的包</span></span><br><span class="line">    <span class="comment">// 则更新receive_counters_.transmitted重传包计数器，用于计算丢包</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序包直接根据序号差计算丢包数：</span></span><br><span class="line">  <span class="comment">// 1）没有丢包，正常顺序包情况下，sequence_number = received_seq_max_ + 1，</span></span><br><span class="line">  <span class="comment">//    这里执行cumulative_loss_ += sequence_number - received_seq_max_ 就是+1，</span></span><br><span class="line">  <span class="comment">//    把--cumulative_loss_;减少的1补上了，相当于没丢包</span></span><br><span class="line">  <span class="comment">// 2）丢了N个包，顺序包情况下，sequence_number = received_seq_max_ + N + 1，</span></span><br><span class="line">  <span class="comment">//    这里执行cumulative_loss_ += sequence_number - received_seq_max_ 加上的是 N+1，</span></span><br><span class="line">  <span class="comment">//    把开头的--cumulative_loss_;减少的1补上，最终cumulative_loss_加上的是N。</span></span><br><span class="line">  cumulative_loss_ += sequence_number - received_seq_max_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新接收到的最大序号</span></span><br><span class="line">  received_seq_max_ = sequence_number;</span><br><span class="line">  <span class="comment">// 在包序号解包器中更新序号状态</span></span><br><span class="line">  seq_unwrapper_.<span class="built_in">Unwrap</span>(packet.<span class="built_in">SequenceNumber</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收到了一个更新的RTP包并且多个包有序，则更新抖动</span></span><br><span class="line">  <span class="keyword">if</span> (packet.<span class="built_in">Timestamp</span>() != last_received_timestamp_ &amp;&amp;</span><br><span class="line">      (receive_counters_.transmitted.packets -</span><br><span class="line">       receive_counters_.retransmitted.packets) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">UpdateJitter</span>(packet, now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最后接收到包的时间戳和接收时间</span></span><br><span class="line">  last_received_timestamp_ = packet.<span class="built_in">Timestamp</span>();</span><br><span class="line">  last_receive_time_ = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个接收的RTP包，在更新统计信息时，涉及到乱序、丢包、重传等问题的处理。</p>
<p>当前接收的包是否是乱序包的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamStatisticianImpl::UpdateOutOfOrder</span><span class="params">(<span class="type">const</span> RtpPacketReceived&amp; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> sequence_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              Timestamp now)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 说明上一个包的序列号是乱序的</span></span><br><span class="line">  <span class="keyword">if</span> (received_seq_out_of_order_) &#123;</span><br><span class="line">    <span class="comment">// 抵消掉第二个if中的 ++cumulative_loss_，也就是说不把上一个包计算为丢包</span></span><br><span class="line">    --cumulative_loss_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果序列号的差值不大，那么流重启的可能性就更大。</span></span><br><span class="line">    <span class="comment">// 所以这里会把预期的序列号设置为上一个乱序包的序列号 + 1</span></span><br><span class="line">    <span class="comment">// 序列号差值过大,更可能是丢包或其他问题导致</span></span><br><span class="line">    <span class="type">uint16_t</span> expected_sequence_number = *received_seq_out_of_order_ + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 清除乱序包记录，重置状态</span></span><br><span class="line">    received_seq_out_of_order_ = absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前包的序列号与预期的序列号相同，认为是发生了流重启，忽略序列号的跳变</span></span><br><span class="line">    <span class="keyword">if</span> (packet.<span class="built_in">SequenceNumber</span>() == expected_sequence_number) &#123;</span><br><span class="line">      <span class="comment">// 通过减去2来更新 RR 中的最大序列号，避免将流重启导致的序号跳变计入丢包数中</span></span><br><span class="line">      last_report_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">      received_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//返回false，按照顺序包处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序号差值超过最大乱序阈值，发生序列号的“跳变”现象，</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">abs</span>(sequence_number - received_seq_max_) &gt;</span><br><span class="line">      max_reordering_threshold_) &#123;</span><br><span class="line">    <span class="comment">// 将当前包标记为乱序包，等待下一个包来判断是否为流重启（第一个if）</span></span><br><span class="line">    received_seq_out_of_order_ = packet.<span class="built_in">SequenceNumber</span>();</span><br><span class="line">    <span class="comment">// 暂时将这个包计算为丢包，在下一个包到来的时候，</span></span><br><span class="line">    <span class="comment">// 第一个if中执行（--cumulative_loss_）抵消掉</span></span><br><span class="line">    ++cumulative_loss_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里进行正常顺序包的判断</span></span><br><span class="line">  <span class="keyword">if</span> (sequence_number &gt; received_seq_max_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前包sequence_number &lt;= received_seq_max_，那么这个包就可能是重传的、乱序的</span></span><br><span class="line">  <span class="comment">// 如果启用了重传检测并且这个包是重传的，就把这个包添加到重传计数器中</span></span><br><span class="line">  <span class="keyword">if</span> (enable_retransmit_detection_ &amp;&amp; <span class="built_in">IsRetransmitOfOldPacket</span>(packet, now))</span><br><span class="line">    receive_counters_.retransmitted.<span class="built_in">AddPacket</span>(packet);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true 表示乱序包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR包中，<code>extended highest sequence number received</code>字段用32bits表示，传进来的序列号<code>packet.SequenceNumber()</code>是uint16_t，这里会先得到扩展到int64_t sequence_number，在构建RR包时候，<code>SetExtHighestSeqNum</code>函数会在将其转为<code>uint32_t</code>。</p>
<p>三个例子理解上边的两个函数关系：</p>
<ul>
<li><p>流重启（网络连接中断后重新建立，或者发送端重新启动等情况）导致连续增长序列号出现跳变：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 500, 501, 502…</p>
<ol>
<li>接收到序号500时，<code>cumulative_loss_=-1，received_seq_max_=10</code>，满足<code>std::abs(sequence_number - received_seq_max_) &gt; max_reordering_threshold_</code>，将500标记为乱序包，暂时计为丢包，此时<code>cumulative_loss_=0，received_seq_max_=10</code>。</li>
<li>在下一个包（501）到达的时候，<code>cumulative_loss_=-1，received_seq_max_=10</code>。由于上一个包500是乱序的，执行UpdateOutOfOrder的第一个if，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>。发现这个包的序列号与预期的序列号（500 + 1 = 501）相同，所以认为<strong>发生了流重启</strong>，执行下边的代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last_report_seq_max_ = sequence_number - <span class="number">2</span>;</span><br><span class="line">received_seq_max_ = sequence_number - <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
将两个参数都置位499。</li>
<li>包<code>501</code>按照正常顺序处理。在<code>UpdateCounters</code>函数中，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-2 += 501 - 499</code>，最终<code>cumulative_loss_=0</code>。就是<code>忽略掉了序列号的跳变，避免计入丢包数</code>。相当于这个跳变是接续这序列号499后边进行传输</li>
</ol>
</li>
<li><p>连续增长出现了最大值又降下来的1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 500, 11, 12…</p>
<ol>
<li>接收到序号500时，<code>cumulative_loss_=-1，received_seq_max_=10</code>，跳变判定条件成立，将500标记为乱序包，暂时计为丢包。此时<code>cumulative_loss_=0，received_seq_max_=10</code></li>
<li>在下一个包（11）到达的时候，<code>cumulative_loss_=-1，received_seq_max_=10</code>。上一个包500是乱序的，执行到UpdateOutOfOrder函数的第一个if，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>。这个包的序列号与预期的序列号（500 + 1 = 501）不同，<strong>不认为发生了流重启，继续处理</strong>，同时不满足第二个if乱序包的判断。因为<code>sequence_number &gt; received_seq_max_</code>，该包按照正常包来处理，UpdateOutOfOrder返回false。</li>
<li><code>UpdateCounters</code>函数继续执行，此时<code>cumulative_loss_=-2，received_seq_max_=10</code>，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-2+=11-10</code>，最终<code>cumulative_loss_=-1</code>，负值会在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中有对应的处理。所以相当于丢1个包。</li>
</ol>
</li>
<li><p>出现了重复的包：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 12…</p>
<ol>
<li>收到第一个序号11的包，<code>cumulative_loss_=-1，received_seq_max_=10</code>，顺序包，<code>UpdateCounters</code>继续执行，此时<code>cumulative_loss_=0，received_seq_max_=11</code>。</li>
<li>第二个序号11的包到达，<code>cumulative_loss_=-1，received_seq_max_=11</code>，执行乱序的判断。UpdateOutOfOrder返回true，不继续执行<code>UpdateCounters</code>函数，保持<code>cumulative_loss_=-1，received_seq_max_=11</code>。</li>
<li>第三个序号11的包达到，<code>cumulative_loss_=-2，received_seq_max_=11</code>，执行乱序的判断，UpdateOutOfOrder返回true，不继续执行<code>UpdateCounters</code>函数，保持<code>cumulative_loss_=-2，received_seq_max_=11</code>。</li>
<li>序号11的包到达，<code>cumulative_loss_=-3，received_seq_max_=11</code>，是正常序列号，执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cumulative_loss_ += sequence_number - received_seq_max_;</span><br></pre></td></tr></table></figure>
<code>-3 += 12-11</code>，最终<code>cumulative_loss_=-2</code>。负值会在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中有对应的处理。所以相当于丢2个包。</li>
</ol>
</li>
</ul>
<p>关于<code>cumulative_loss_</code>，<code>RFC 3550</code>中有一段描述：</p>
<blockquote><p>This number is defined to be the number of packets expected less the number of packets actually received, where the number of packets received includes any which are late or duplicates. Thus, packets that arrive late are not counted as lost, and the loss may be negative if there are duplicates.  </p>
<footer><strong>RFC3550</strong><cite><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3550#section-6.4.1">datatracker.ietf.org/doc/html/rfc3550#section-6.4.1</a></cite></footer></blockquote>
<p>翻译过来意思是：<strong>这个数字被定义为预期的数据包数量减去实际接收到的数据包数量，其中接收到的数据包数量包括任何延迟或重复的数据包。因此，延迟到达的数据包不会被计算为丢失，如果有重复的数据包，丢失的数量可能为负。</strong></p>
<p>接收端计算统计值后构造RR包的函数调用过程为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RTCPSender::BuildRR</span><br><span class="line">-&gt;RTCPSender::CreateReportBlocks</span><br><span class="line">-&gt;ReceiveStatisticsImpl::RtcpReportBlocks</span><br><span class="line">-&gt;StreamStatisticianImpl::MaybeAppendReportBlockAndReset</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造RR包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPSender::BuildRR</span><span class="params">(<span class="type">const</span> RtcpContext&amp; ctx, PacketSender&amp; sender)</span> </span>&#123;</span><br><span class="line">  rtcp::ReceiverReport report;</span><br><span class="line">  report.<span class="built_in">SetSenderSsrc</span>(ssrc_);</span><br><span class="line">  report.<span class="built_in">SetReportBlocks</span>(<span class="built_in">CreateReportBlocks</span>(ctx.feedback_state_));</span><br><span class="line">  <span class="keyword">if</span> (method_ == RtcpMode::kCompound || !report.<span class="built_in">report_blocks</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    sender.<span class="built_in">AppendPacket</span>(report);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RTT统计"><a href="#RTT统计" class="headerlink" title="RTT统计"></a>RTT统计</h3><blockquote><p>RTT的计算考虑，A在lsr时刻发送SR包给B，B在接收到SR并处理后恢复RR给A的时间间隔是dlsr，A收到B发送的RR的时间是T，那么RTT=T-lsr-dlsr。</p>
</blockquote>
<p>接收端对RR包中的ReportBlocks填充lsr和dlsr，然后发送端在<code>RTCPReceiver::HandleReportBlock</code>函数处理RR包计算RTT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;rtcp::ReportBlock&gt; <span class="title">RTCPSender::CreateReportBlocks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FeedbackState&amp; feedback_state)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;rtcp::ReportBlock&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (!receive_statistics_)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  result = receive_statistics_-&gt;<span class="built_in">RtcpReportBlocks</span>(RTCP_MAX_REPORT_BLOCKS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!result.<span class="built_in">empty</span>() &amp;&amp; feedback_state.last_rr.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Get our NTP as late as possible to avoid a race.</span></span><br><span class="line">    <span class="type">uint32_t</span> now = <span class="built_in">CompactNtp</span>(clock_-&gt;<span class="built_in">CurrentNtpTime</span>());</span><br><span class="line">    <span class="comment">// SR包的接收时间？</span></span><br><span class="line">    <span class="type">uint32_t</span> receive_time = <span class="built_in">CompactNtp</span>(feedback_state.last_rr);</span><br><span class="line">    <span class="comment">// 当前时间-接受时间=接收端的处理时间</span></span><br><span class="line">    <span class="type">uint32_t</span> delay_since_last_sr = now - receive_time;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; report_block : result) &#123;</span><br><span class="line">      <span class="comment">// 发送端发送的时间lrr</span></span><br><span class="line">      report_block.<span class="built_in">SetLastSr</span>(feedback_state.remote_sr);</span><br><span class="line">      <span class="comment">// 处理的时间dlsr</span></span><br><span class="line">      report_block.<span class="built_in">SetDelayLastSr</span>(delay_since_last_sr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="丢包统计"><a href="#丢包统计" class="headerlink" title="丢包统计"></a>丢包统计</h3><p>丢包计算在<code>StreamStatisticianImpl::MaybeAppendReportBlockAndReset</code>中实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamStatisticianImpl::MaybeAppendReportBlockAndReset</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;rtcp::ReportBlock&gt;&amp; report_blocks)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 之前没有接收到 RTP 数据包</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReceivedRtpPacket</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">  <span class="comment">// 距离上次接收的时间超过了设定的统计超时时间8s，视为不活跃</span></span><br><span class="line">  <span class="keyword">if</span> (now - *last_receive_time_ &gt;= kStatisticsTimeout) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  report_blocks.<span class="built_in">emplace_back</span>();</span><br><span class="line">  rtcp::ReportBlock&amp; stats = report_blocks.<span class="built_in">back</span>();</span><br><span class="line">  stats.<span class="built_in">SetMediaSsrc</span>(ssrc_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 一个统计间隔内期望收到的包的总数=当前接收到的最大序列号-上一个时刻接收到的最大序列号</span></span><br><span class="line">  <span class="type">int64_t</span> exp_since_last = received_seq_max_ - last_report_seq_max_;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_GE</span>(exp_since_last, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 一个统计间隔内累计丢包数=当前累计的丢包-上一次RR的累计丢包</span></span><br><span class="line">  <span class="type">int32_t</span> lost_since_last = cumulative_loss_ - last_report_cumulative_loss_;</span><br><span class="line">  <span class="keyword">if</span> (exp_since_last &gt; <span class="number">0</span> &amp;&amp; lost_since_last &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 两个RR包之间的丢包率=丢包数/期望收到包数，限制在(0,255)范围内，降低精度以8位存储</span></span><br><span class="line">    stats.<span class="built_in">SetFractionLost</span>(<span class="number">255</span> * lost_since_last / exp_since_last);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 累计丢包数进行修正，并处理发送方累计丢包数为负数的情况</span></span><br><span class="line">  <span class="type">int</span> packets_lost = cumulative_loss_ + cumulative_loss_rtcp_offset_;</span><br><span class="line">  <span class="keyword">if</span> (packets_lost &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    packets_lost = <span class="number">0</span>;</span><br><span class="line">    cumulative_loss_rtcp_offset_ = -cumulative_loss_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cumulative number of packets lost是 24 bits有符号数</span></span><br><span class="line">  <span class="keyword">if</span> (packets_lost &gt; <span class="number">0x7fffff</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cumulative_loss_is_capped_) &#123;</span><br><span class="line">      cumulative_loss_is_capped_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Cumulative loss reached maximum value for ssrc &quot;</span></span><br><span class="line">                          &lt;&lt; ssrc_;</span><br><span class="line">    &#125;</span><br><span class="line">    packets_lost = <span class="number">0x7fffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 将丢包率、累计丢包数、最大序列号等信息填写到RR包的Report Block中发送给发送端</span></span><br><span class="line">  stats.<span class="built_in">SetCumulativeLost</span>(packets_lost);</span><br><span class="line">  stats.<span class="built_in">SetExtHighestSeqNum</span>(received_seq_max_);</span><br><span class="line">  <span class="comment">// 设置抖动</span></span><br><span class="line">  stats.<span class="built_in">SetJitter</span>(jitter_q4_ &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 更新最大序列号和累计丢包数，下一个统计周期使用</span></span><br><span class="line">  last_report_cumulative_loss_ = cumulative_loss_;</span><br><span class="line">  last_report_seq_max_ = received_seq_max_;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT_WITH_SSRC</span>(<span class="number">1</span>, <span class="string">&quot;cumulative_loss_pkts&quot;</span>, now.<span class="built_in">ms</span>(),</span><br><span class="line">                                  cumulative_loss_, ssrc_);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT_WITH_SSRC</span>(<span class="number">1</span>, <span class="string">&quot;received_seq_max_pkts&quot;</span>, now.<span class="built_in">ms</span>(),</span><br><span class="line">                                  (received_seq_max_ - received_seq_first_),</span><br><span class="line">                                  ssrc_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边计算一段时间窗口内的丢包率，如果发生<code>重传、乱序或者重复包</code>等问题，包的序列号会出现错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... 3 4 5 [6 7 9 11 10] ...</span><br></pre></td></tr></table></figure>
<p>这里计算的丢包率是包括重传包后的丢包率，收到重传包会导致比原始丢包率低，那么Sendside BWE用这个丢包率进行码率估计就有误差。Webrtc中的RTX机制，<strong>重传包用额外SSRC的包发送</strong>，这样重传包就不会算在原始媒体包的统计，就能得到原始的丢包率。</p>
<h2 id="发送端获取丢包和RTT"><a href="#发送端获取丢包和RTT" class="headerlink" title="发送端获取丢包和RTT"></a>发送端获取丢包和RTT</h2><p>基于丢包的带宽估计共有三个实现，分别是<code>SendSideBandwidthEstimation</code>类实现、<code>LossBasedBandwidthEstimation</code>和<code>LossBasedBweV2</code>。这里主要讲第一种。发送端解析接收端发过来的 RTCP RR 报文的lost fraction字段来判断丢包，RTT的计算等，用到基于丢包的BWE中。调用流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RTCPReceiver::IncomingPacket</span><br><span class="line">-&gt;RTCPReceiver::TriggerCallbacksFromRtcpPacket</span><br><span class="line">-&gt;RtpTransportControllerSend::OnReport</span><br><span class="line">-&gt;GoogCcNetworkController::OnTransportLossReport</span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdatePacketsLost  </span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdateEstimate</span><br><span class="line">-&gt;SendSideBandwidthEstimation::UpdateTargetBitrate</span><br><span class="line">-&gt;current_target_ = new_bitrate;</span><br></pre></td></tr></table></figure>
<p><code>RTCPReceiver::IncomingPacket</code>函数对接收到的RTCP报文进行处理。<code>RTCPReceiver::ParseCompoundPacket</code>函数解析收到的报文，对SR和RR报文调用<code>RTCPReceiver::HandleReportBlock</code>函数解析计算得到RTT和丢包率，并将解析的结果封装到PacketInformation中，然后调用<code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>回调进行带宽估计部分实现：</p>
<h3 id="RTT计算"><a href="#RTT计算" class="headerlink" title="RTT计算"></a>RTT计算</h3><p>发送端计算完RTT之后，通过<code>RtpTransportControllerSend::OnRttUpdate</code>函数调用<code>GoogCcNetworkController::OnRoundTripTimeUpdate</code>对RTT进行更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnRoundTripTimeUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RoundTripTimeUpdate msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_ || msg.smoothed)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!msg.round_trip_time.<span class="built_in">IsZero</span>());</span><br><span class="line">  <span class="comment">// 基于延迟的BWE</span></span><br><span class="line">  <span class="keyword">if</span> (delay_based_bwe_)</span><br><span class="line">    delay_based_bwe_-&gt;<span class="built_in">OnRttUpdate</span>(msg.round_trip_time);</span><br><span class="line">  <span class="comment">// 更新RTT</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateRtt</span>(msg.round_trip_time, msg.receive_time);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateRtt</span><span class="params">(TimeDelta rtt, Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新RTT</span></span><br><span class="line">  <span class="keyword">if</span> (rtt &gt; TimeDelta::<span class="built_in">Zero</span>())</span><br><span class="line">    last_round_trip_time_ = rtt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsInStartPhase</span>(at_time) &amp;&amp; uma_rtt_state_ == kNoUpdate) &#123;</span><br><span class="line">    uma_rtt_state_ = kDone;</span><br><span class="line">    <span class="built_in">RTC_HISTOGRAM_COUNTS</span>(<span class="string">&quot;WebRTC.BWE.InitialRtt&quot;</span>, rtt.<span class="built_in">ms</span>&lt;<span class="type">int</span>&gt;(), <span class="number">0</span>, <span class="number">2000</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote><p>上边为发送端根据SR、RR包计算RTT的过程，接收端也需要计算RTT，用于带宽估计或者NACK等模块。<br>目前默认是写死的100ms或者200ms，并不能直接通过SR、RR包获取到rtt，如果有需要更新rtt的话，需要借助RFC3611的XR包的两个跟SR、RR包类似的Report Block来处理。处理过程跟通过SR、RR包计算rtt的过程基本相同，但是方向相反，也就是接收端发送带发送时间戳的XR(Receiver Reference Time Report Block)，发送端回复带处理时延的XR(DLRR Report Block)，接收端收到后可以使用相同的方法计算rtt。</p>
<footer><strong>https://blog.csdn.net/sonysuqin/article/details/106186374</strong></footer></blockquote>
<p>实现基于RTT的带宽估计。封装RoundTripTimeUpdate消息，最后调用<code>PostUpdates(controller_-&gt;OnRoundTripTimeUpdate(report));</code>，首先将RoundTripTimeUpdate消息发送给GoogCcNetworkController模块计算基于RTT的码率，然后调用PostUpdates刷新码率，作用到pacer发送模块。</p>
<h3 id="丢包率计算"><a href="#丢包率计算" class="headerlink" title="丢包率计算"></a>丢包率计算</h3><p><code>RtpTransportControllerSend::OnReport</code>统计了发送的数据包数和丢失的数据包数目，封装成<code>TransportLossReport</code>交给GoogCcNetworkController模块实现发送端基于丢包的BWE。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnTransportLossReport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TransportLossReport msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只使用数据包反馈，直接返回一个空的网络控制更新</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  <span class="comment">// 计算总的数据包增量，包括接收到的数据包（发送成功）和丢失的数据包</span></span><br><span class="line">  <span class="type">int64_t</span> total_packets_delta =</span><br><span class="line">      msg.packets_received_delta + msg.packets_lost_delta;</span><br><span class="line">  <span class="comment">// SendSideBandwidthEstimation::UpdatePacketsLost</span></span><br><span class="line">  <span class="comment">// 更新当前时间差范围内带宽估计，包括丢包数、总的数据包数和接收时间</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdatePacketsLost</span>(</span><br><span class="line">      msg.packets_lost_delta, total_packets_delta, msg.receive_time);</span><br><span class="line">  <span class="comment">// 这里构造了一个NetworkControlUpdate，没有对成员进行赋值。也就是说，</span></span><br><span class="line">  <span class="comment">// 经由RR或者SR报文的丢包情况对GoogCcNetworkController模块的真实作用</span></span><br><span class="line">  <span class="comment">// 是更新SendSideBandwidthEstimation模块中的发包数量、丢包数和接收时间</span></span><br><span class="line">  <span class="comment">// 而在RtpTransportControllerSend模块该阶段的最后调用栈中调用的PostUpdates函数实际上会直接返回，不会做任何事情。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SendSideBandwidthEstimation::UpdatePacketsLost</code>根据收到的RR包来更新丢包信息和带宽估计，需要保证包数累计到20个以上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdatePacketsLost</span><span class="params">(<span class="type">int64_t</span> packets_lost,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">int64_t</span> number_of_packets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新最后一次丢包反馈的时间</span></span><br><span class="line">  last_loss_feedback_ = at_time;</span><br><span class="line">  <span class="comment">// 第一次接收到丢包报告，则记录报告的时间</span></span><br><span class="line">  <span class="keyword">if</span> (first_report_time_.<span class="built_in">IsInfinite</span>())</span><br><span class="line">    first_report_time_ = at_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个RR包之间收到的RTP包&gt;0</span></span><br><span class="line">  <span class="keyword">if</span> (number_of_packets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两次统计间隔预期的总包数</span></span><br><span class="line">    <span class="type">int64_t</span> expected =</span><br><span class="line">        expected_packets_since_last_loss_update_ + number_of_packets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总发包数小于20个，不更新丢包，累积reports block</span></span><br><span class="line">    <span class="keyword">if</span> (expected &lt; kLimitNumPackets) &#123;</span><br><span class="line">      <span class="comment">// 总包数</span></span><br><span class="line">      expected_packets_since_last_loss_update_ = expected;</span><br><span class="line">      <span class="comment">// 丢包数</span></span><br><span class="line">      lost_packets_since_last_loss_update_ += packets_lost;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送端两次统计间隔的包数已经超过20个，可以计算实际的丢包率</span></span><br><span class="line">    has_decreased_since_last_fraction_loss_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 丢包率*256，避免浮点计算</span></span><br><span class="line">    <span class="type">int64_t</span> lost_q8 =</span><br><span class="line">        std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(lost_packets_since_last_loss_update_ + packets_lost,</span><br><span class="line">                          <span class="number">0</span>)&lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 丢包率限制在(0,255)              </span></span><br><span class="line">    last_fraction_loss_ = std::<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(lost_q8 / expected, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算丢包率之后，重置发送端计数器</span></span><br><span class="line">    <span class="comment">// 每隔20个数据包计算一次丢包统计</span></span><br><span class="line">    <span class="comment">// 自上一次处理基于丢包码率估计到本次处理时间差之间丢包数</span></span><br><span class="line">    lost_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自上一次处理基于丢包码率估计到本次处理时间差之间总共的发包数量</span></span><br><span class="line">    expected_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    last_loss_packet_report_ = at_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送端带宽估计，用丢包和RTT等调整预估带宽</span></span><br><span class="line">    <span class="built_in">UpdateEstimate</span>(at_time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新丢包的统计信息</span></span><br><span class="line">  <span class="built_in">UpdateUmaStatsPacketsLost</span>(at_time, packets_lost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UpdatePacketsLost函数中，如果预期的数据包数还不足以生成丢包率，则会累积报告，直到有足够的数据包。然后，计算丢包率，并重置累积器。最后，更新带宽估计和丢包的统计信息。发送端已经获得了一段时间的丢包率，UpdateEstimate根据丢包和RTT去调整带宽。</p>
<h2 id="发送端基于丢包和RTT的BWE"><a href="#发送端基于丢包和RTT的BWE" class="headerlink" title="发送端基于丢包和RTT的BWE"></a>发送端基于丢包和RTT的BWE</h2><p>基于延时的算法通过监测网络延时的变化趋势来估计可用带宽，只在网络路径上的缓存队列比较长时才比较可靠。如果缓存队列较短，则可以根据丢包率来判断是否存在过载。相比之下，基于丢包的算法是应对已经发生拥塞情况的紧急措施。在物理链路中，大量丢包通常发生在路由器缓冲区已满时，这时必须降低发送数据量以使网络恢复。</p>
<script type="math/tex; mode=display">
\begin{equation}
A_s(t_k) = \begin{cases}
    1.08\cdot A_s(t_{k-1}) & f_l(t_k)<0.02 \\
    A_s(t_{k-1}) & 0.02 \leq f_l(t_k) \leq 0.1 \\
    A_s(t_{k-1})(1-0.5f_l(t_k)) & f_l(t_k)>0.1
\end{cases}
\end{equation}</script><ol>
<li>丢包率小于2%时，网络状况良好，1s窗口内码率最小值为基准增长8%，探测更多带宽。</li>
<li>丢包率在2%~10%时，网络拥塞一般，保持码率不变。</li>
<li>丢包率大于10%时，网络拥塞严重，以RTT+300ms的间隔，每次降低丢包率 * 50%的带宽。</li>
</ol>
<p><code>SendSideBandwidthEstimation::UpdateEstimate</code>根据当前的网络状况（如丢包率、RTT等）来更新带宽估计，有多次调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateEstimate</span><span class="params">(Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RTT退避，RTT超过阈值3s，则认为网络拥堵，降低发送码率，防止网络过载</span></span><br><span class="line">  <span class="keyword">if</span> (rtt_backoff_.<span class="built_in">IsRttAboveLimit</span>()) &#123;</span><br><span class="line">    <span class="comment">// 距离上次降低带宽已经超过一个设定的间隔，并且当前目标带宽大于设定的最低带宽</span></span><br><span class="line">    <span class="keyword">if</span> (at_time - time_last_decrease_ &gt;= rtt_backoff_.drop_interval_ &amp;&amp;</span><br><span class="line">        current_target_ &gt; rtt_backoff_.bandwidth_floor_) &#123;</span><br><span class="line">      <span class="comment">// 更新码率降低时刻</span></span><br><span class="line">      time_last_decrease_ = at_time;</span><br><span class="line">      <span class="comment">// 每次按照0.8倍退避，退避到的码率下限为5kbps</span></span><br><span class="line">      <span class="comment">// new_bitrate = max(current_target * 0.8, 5kbps)</span></span><br><span class="line">      DataRate new_bitrate =</span><br><span class="line">          std::<span class="built_in">max</span>(current_target_ * rtt_backoff_.drop_fraction_,</span><br><span class="line">                   rtt_backoff_.bandwidth_floor_.<span class="built_in">Get</span>());</span><br><span class="line">      <span class="comment">// 更新链路容量</span></span><br><span class="line">      link_capacity_.<span class="built_in">OnRttBackoff</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="comment">// 更新目标码率</span></span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未满足退避条件，没有降低比特率,直接应用目标比特率限制</span></span><br><span class="line">    <span class="comment">// 注意：在大多数情况下，这可能是多余的。</span></span><br><span class="line">    <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在前2s没有RR的丢包统计，说明处于启动阶段，使用REMB报的接收端估计带宽</span></span><br><span class="line">  <span class="keyword">if</span> (last_fraction_loss_ == <span class="number">0</span> &amp;&amp; <span class="built_in">IsInStartPhase</span>(at_time) &amp;&amp;</span><br><span class="line">      !loss_based_bandwidth_estimator_v2_-&gt;<span class="built_in">ReadyToUseInStartPhase</span>()) &#123;</span><br><span class="line">    <span class="comment">// 新的带宽设为当前目标带宽</span></span><br><span class="line">    DataRate new_bitrate = current_target_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取接收端REMB码率和发送端TWCC 基于延迟估计码率的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (receiver_limit_.<span class="built_in">IsFinite</span>())</span><br><span class="line">      new_bitrate = std::<span class="built_in">max</span>(receiver_limit_, new_bitrate);</span><br><span class="line">    <span class="keyword">if</span> (delay_based_limit_.<span class="built_in">IsFinite</span>())</span><br><span class="line">      new_bitrate = std::<span class="built_in">max</span>(delay_based_limit_, new_bitrate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化基于丢包的带宽估计器V1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1Enabled</span>()) &#123;</span><br><span class="line">      loss_based_bandwidth_estimator_v1_.<span class="built_in">Initialize</span>(new_bitrate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标值变化，更新历史最低码率</span></span><br><span class="line">    <span class="keyword">if</span> (new_bitrate != current_target_) &#123;</span><br><span class="line">      min_bitrate_history_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1Enabled</span>()) &#123;</span><br><span class="line">        min_bitrate_history_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(at_time, new_bitrate));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 否则，将当前目标带宽和当前时间加入最小带宽历史</span></span><br><span class="line">        min_bitrate_history_.<span class="built_in">push_back</span>(</span><br><span class="line">            std::<span class="built_in">make_pair</span>(at_time, current_target_));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新历史最小比特率，维护最近1s内的最低估计码率</span></span><br><span class="line">  <span class="built_in">UpdateMinHistory</span>(at_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还没有上报过一次丢包率(可能没有RR包，或者有RR包了，但是累计包数未满20)，那么可以退出.</span></span><br><span class="line">  <span class="keyword">if</span> (last_loss_packet_report_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">    <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于丢包的带宽估计器V1或V2可以使用，就使用它们来更新带宽估计</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV1ReadyForUse</span>()) &#123;</span><br><span class="line">    DataRate new_bitrate = loss_based_bandwidth_estimator_v1_.<span class="built_in">Update</span>(</span><br><span class="line">        at_time, min_bitrate_history_.<span class="built_in">front</span>().second, delay_based_limit_,</span><br><span class="line">        last_round_trip_time_);</span><br><span class="line">    <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LossBasedBandwidthEstimatorV2ReadyForUse</span>()) &#123;</span><br><span class="line">    LossBasedBweV2::Result result =</span><br><span class="line">        loss_based_bandwidth_estimator_v2_-&gt;<span class="built_in">GetLossBasedResult</span>();</span><br><span class="line">    loss_based_state_ = result.state;</span><br><span class="line">    <span class="built_in">UpdateTargetBitrate</span>(result.bandwidth_estimate, at_time);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自上次feedback以来的时间差</span></span><br><span class="line">  TimeDelta time_since_loss_packet_report = at_time - last_loss_packet_report_;</span><br><span class="line">  <span class="comment">/*---------------根据丢包和RTT调整码率-----------------*/</span></span><br><span class="line">  <span class="comment">// 距离上次收到反馈不超过1.2*5 = 6s时间窗口认为有效</span></span><br><span class="line">  <span class="keyword">if</span> (time_since_loss_packet_report &lt; <span class="number">1.2</span> * kMaxRtcpFeedbackInterval) &#123;</span><br><span class="line">    <span class="comment">// 丢包率之前扩大了256，现在只是缩减回去</span></span><br><span class="line">    <span class="type">float</span> loss = last_fraction_loss_ / <span class="number">256.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前目标码率小于阈值，或loss &lt; 2%时</span></span><br><span class="line">    <span class="keyword">if</span> (current_target_ &lt; bitrate_threshold_ || loss &lt;= low_loss_threshold_) &#123;</span><br><span class="line">      <span class="comment">// 以1s内最小带宽的1.08倍增加估计带宽，最小带宽通过UpdateMinHistory函数维护</span></span><br><span class="line">      <span class="comment">// 此时并没有考虑remb和twcc基于延迟的带宽</span></span><br><span class="line">      DataRate new_bitrate = DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">          min_bitrate_history_.<span class="built_in">front</span>().second.<span class="built_in">bps</span>() * <span class="number">1.08</span> + <span class="number">0.5</span>);</span><br><span class="line">      <span class="comment">// 增加1kbps，防止陷入停滞状态</span></span><br><span class="line">      new_bitrate += DataRate::<span class="built_in">BitsPerSec</span>(<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_target_ &gt; bitrate_threshold_) &#123;</span><br><span class="line">      <span class="comment">// 当前目标带宽大于带宽阈值</span></span><br><span class="line">      <span class="keyword">if</span> (loss &lt;= high_loss_threshold_) &#123;</span><br><span class="line">        <span class="comment">// 丢包率在2%到10%之间，保持当前速率</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Loss &gt; 10%</span></span><br><span class="line">        <span class="comment">// 自上次上报丢包以来，没有降低过码率，且上次降低码率已经过去了rtt + 300ms的时间</span></span><br><span class="line">        <span class="comment">// 限制比特率减少的频率，以rtt + 300ms为最小时间间隔，每次降低丢包率 * 50%的带宽</span></span><br><span class="line">        <span class="keyword">if</span> (!has_decreased_since_last_fraction_loss_ &amp;&amp;</span><br><span class="line">            (at_time - time_last_decrease_) &gt;=</span><br><span class="line">                (kBweDecreaseInterval + last_round_trip_time_)) &#123;</span><br><span class="line">          <span class="comment">// 记录降低码率的时间</span></span><br><span class="line">          time_last_decrease_ = at_time;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// newRate = rate * (1 - 0.5*lossRate)。</span></span><br><span class="line">          DataRate new_bitrate = DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">              (current_target_.<span class="built_in">bps</span>() *</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">512</span> - last_fraction_loss_)) /</span><br><span class="line">              <span class="number">512.0</span>);</span><br><span class="line">          <span class="comment">// 置位这个标记，直到下次上报丢包的时候再次清除,</span></span><br><span class="line">          <span class="comment">// 也就是两个限制，一个是需要上报丢包，这个需要两个RR的时间间隔，1个控制降速的时间间隔在rtt + 300ms,</span></span><br><span class="line">          <span class="comment">// 在丢包比较严重的时候以这个策略为主降低码率，如果抖动比较厉害则以REMB为主降低码率.</span></span><br><span class="line">          has_decreased_since_last_fraction_loss_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">UpdateTargetBitrate</span>(new_bitrate, at_time);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 应用目标带宽的限制</span></span><br><span class="line">  <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UpdateEstimate主要用于更新带宽估计。它会根据当前的网络状况，如RTT（Round-Trip Time）、丢包率等，来调整带宽估计。</p>
<ol>
<li>函数开始会进行RTT退避。TWCC反馈需要累计一定的报文或等待超时才会发送，这个延迟可能会导致TWCC计算的RTT不准。因此，会基于发包间隔检查RTT是否超过了设定的限制，RTT过高说明网络延迟大，需要降低带宽以减少网络拥塞。</li>
<li>在启动阶段，如果没有报告丢包，函数会信任REMB和/或基于延迟的估计，因为在启动阶段，网络状况通常相对稳定，REMB和延迟估计能够提供较为准确的带宽估计。</li>
<li>如果基于丢包的带宽估计器可以使用，函数会使用它们来更新带宽估计，因为丢包率是网络质量的重要指标，基于丢包的带宽估计器能够更准确地反映网络状况。</li>
<li>最后，函数会根据丢包率来调整带宽。如果丢包率过高，说明网络拥塞严重，此时需要降低带宽以减少丢包。反之，如果丢包率较低，说明网络状况良好，可以适当提高带宽以提高传输效率。</li>
</ol>
<h1 id="发送端twcc基于延迟的BWE"><a href="#发送端twcc基于延迟的BWE" class="headerlink" title="发送端twcc基于延迟的BWE"></a>发送端twcc基于延迟的BWE</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于缓冲队列比较大的情况，当网络拥塞时候，RTT会增大，从而基于延迟的BWE能够检测到拥塞并调整码率。在小缓存场景中，无论是初始传输包还是重传包的RTT都不会有明显变化，GCC中基于RTT的带宽估计无法触发，适合采用和基于丢包的BWE。GCC在无丢包时会主动增加带宽探测，在丢包时立即减少带宽，会导致带宽估计频繁波动，进而导致视频播放卡顿。在小缓存或无缓存的情况下，应抑制带宽频繁的上探和下探，避免带宽估计过于波动，从而保证视频流的平稳性和观看体验。<br>发送端接收到TWCC报文更新基于延时的带宽估计。</p>
<p><img src="03.png" alt="p3" style="zoom:22%;" /></p>
<p>网络传输中的<code>单向延时梯度</code>定义为<strong>相邻两个包组的接收时间差与发送时间差之间的差值（下式ii）</strong>，也可以理解为数据往返的时间差（下式i）。</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
d_i &= (t_i-T_i)-( t_{i-1}- T_{i-1}) && \text{(i)}\\
&= (t_i-t_{i-1})-(T_i-T_{i-1}) && \text{(ii)}
\end{aligned}
\end{equation}</script><p>不考虑ntp时间同步和传输路由发生变化，这种延迟差的产生主要有三个原因：</p>
<ul>
<li><p>连续包组大小变化带来的时延 <script type="math/tex">\frac{\Delta L_i}{C_i}</script>，其中 <script type="math/tex">\Delta L_i</script> 表示连续两个数据包大小的变化，<script type="math/tex">C_i</script> 是接收第 i 帧时刻的链路容量或传输速率大小</p>
</li>
<li><p>包组在发送队列中的排队时延 <script type="math/tex">m_i</script> </p>
</li>
<li><p>网络抖动等其他延时 <script type="math/tex">z_i</script></p>
</li>
</ul>
<p>所以单向延时梯度可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation}
d_i = \frac{\Delta L_i }{C_i}+ m_i+z_i
\end{equation}</script><p>在网络传输过程中，数据包在中间网络设备的转发过程中会先被放入排队队列等待处理和发送。排队延迟的变化最能反映出链路负载的变化情况。当某节点的发送速率小于接收速率时，排队延迟会逐渐增大；当发送速率大于接收速率时，排队延迟会逐渐减小甚至为0。因此，<strong>单向排队延迟梯度(one way queuing delay gradient)</strong>可以有效地反映码率的变化。进行拥塞控制的基本思想是:</p>
<ul>
<li>通过检测单向延迟梯度的正向扩张，探测网络负载是否接近饱和</li>
<li>当延迟梯度超过阈值时，降低发送码率，直到延迟梯度收敛，避免网络过载</li>
</ul>
<p>这样可以动态调整发送码率，让网络的负载趋于饱和但避免过载。</p>
<p>根据<a href="#gcc-analysis">GCC论文</a>，排队延迟可以建模为：<script type="math/tex">T_q(t) = \frac{q(t)}{C}</script>。<code>排队延迟梯度被定义为排队延迟的导数</code>，推导过程如下：</p>
<blockquote><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T_q{'}(t) &= \frac{q^{'}(t)}{C} & \text{(i)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{q(t+\Delta t) - q(t)}{\Delta t} & \text{(ii)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{(q(t) + (r(t + \Delta t) - C)\times\Delta t) - q(t)}{\Delta t}& \text{(iii)} \\
&= \frac{1}{C} \lim_{\Delta t \to 0}\frac{(r(t + \Delta t) - C)\times\Delta t}{\Delta t}& \text{(iv)} \\
&= \frac{r(t) - C}{C} & \text{(v)}
\end{aligned}
\end{equation}</script><footer><strong>woder</strong><cite><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ishen/p/15249678.html">www.cnblogs.com/ishen/p/15249678.html</a></cite></footer></blockquote>
<p>上式中，<script type="math/tex">q(t)</script> 为队列长度，<script type="math/tex">C</script> 是链路容量，<script type="math/tex">r(t)</script> 是队列接收速率也就是发送码率。步骤 <script type="math/tex">\text{(ii)} \to \text{(iii)}</script> 是将队列长度 <script type="math/tex">q(t+\Delta t)</script>，表示为初始队列长度 <script type="math/tex">q(t)</script>，加上由于输入速率 <script type="math/tex">r(t+Δt)</script> 超过链路容量 <script type="math/tex">C</script> 导致队列需要排队的码率。式 <script type="math/tex">\text{(i)}</script> 表明，<strong>排队延迟梯度 = 队列长度的变化/最大处理负载</strong>，式 <script type="math/tex">\text{(v)}</script> 表明了<strong>排队延迟梯度和接受码率及链路容量之间的关系</strong></p>
<p><strong>码率 <script type="math/tex">r(t)</script> 应该处于一直波动的状态</strong>。随着码率的增大，延迟梯度也会越高。当码率超过链路容量不再增长，此时延迟梯度不变，排队队列随着时间不断增长，导致排队的延迟升高最终出现网络拥塞。<strong>所以设置了队列延迟梯度阈值</strong>，队列增长一段时间之后，降低码率来清空队列，减小到一定后再继续增长。</p>
<p>函数调用流程如下：</p>
<p><img src="delay-based-BWE.png" alt="delay-based-BWE" style="zoom:27%;" /></p>
<h2 id="包组"><a href="#包组" class="headerlink" title="包组"></a>包组<a name="包组"></a></h2><p>WebRTC是将包进行分组，计算组间的整体计算传播时间差，且必须在发送方开启pacing发送。原因为：</p>
<ol>
<li>单个包的数据存在偶然性，包组数据更稳定</li>
<li>发送端的pacer模块的调度一般是5ms一次发送多个数据包。</li>
<li>wifi网络下存在短暂的信道中断现象，造成数据包的堆积，出现突发数据包。</li>
</ol>
<p>分组的实现：</p>
<ol>
<li>当前包的发送时间与当前包组第一个包发送时间差值在<code>5ms</code>内属于同一个组，超过则开始新的分组</li>
<li>一个数据包相当于所在的包组是突发数据包，仍然归到这个组中</li>
<li>同一时间发送的数据，是发送端突发数据包现象，一定是属于同一个组。wifi环境下的中断导致一段时间内的包聚集到达现象。突发数据包现象判断的条件是：延迟梯度 &lt; 0，到达时间间隔 &lt;= 5ms，与当前包组的首包到达时间的差值 &lt; 100ms</li>
</ol>
<p><code>InterArrivalDelta::NewTimestampGroup</code>判断是否新的包组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::NewTimestampGroup</span><span class="params">(Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Timestamp send_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_timestamp_group_.<span class="built_in">IsFirstPacket</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 第一个包不创建新的包组</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">BelongsToBurst</span>(arrival_time, send_time)) &#123;</span><br><span class="line">    <span class="comment">// 突发数据包不创建新的包组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 当前包和该包组首包的发送时刻差 &gt; 5ms</span></span><br><span class="line">    <span class="keyword">return</span> send_time - current_timestamp_group_.first_send_time &gt;</span><br><span class="line">           send_time_group_length_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以InterArrival=5ms将数据形成包组，计算最近两个包组的发送时间差、接收时间差、数据包大小等，进行是否数据突发的判断并把这些参数给滤波器进行处理。判断RTP包<strong>是否属于一个突发数据包</strong>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::BelongsToBurst</span><span class="params">(Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Timestamp send_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(current_timestamp_group_.complete_time.<span class="built_in">IsFinite</span>());</span><br><span class="line">  <span class="comment">// 当前包与当前包组最后一个包的接收时间差</span></span><br><span class="line">  TimeDelta arrival_time_delta =</span><br><span class="line">      arrival_time - current_timestamp_group_.complete_time;</span><br><span class="line">  <span class="comment">// 当前包与当前包组最后一个包的发送时间差</span></span><br><span class="line">  TimeDelta send_time_delta = send_time - current_timestamp_group_.send_time;</span><br><span class="line">  <span class="comment">// 发送时间差为零，属于突发数据包</span></span><br><span class="line">  <span class="keyword">if</span> (send_time_delta.<span class="built_in">IsZero</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传输延迟梯度 = 到达时间差 - 发送时间差</span></span><br><span class="line">  TimeDelta propagation_delta = arrival_time_delta - send_time_delta;</span><br><span class="line">  <span class="comment">// 传输延迟梯度 &lt; 0，到达时间间隔 &lt;= 5ms，与当前包组的首包到达时间的差值 &lt; 100ms，属于突发数据包</span></span><br><span class="line">  <span class="keyword">if</span> (propagation_delta &lt; TimeDelta::<span class="built_in">Zero</span>() &amp;&amp;</span><br><span class="line">      arrival_time_delta &lt;= kBurstDeltaThreshold &amp;&amp;</span><br><span class="line">      arrival_time - current_timestamp_group_.first_arrival &lt; kMaxBurstDuration)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="twcc基于延迟的BWE"><a href="#twcc基于延迟的BWE" class="headerlink" title="twcc基于延迟的BWE"></a>twcc基于延迟的BWE</h2><p><code>GoogCcNetworkController::OnTransportPacketsFeedback</code>根据TWCC反馈进行基于延迟的BWE，并进一步探测。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTCPReceiver::IncomingPacket接收到数据包</span></span><br><span class="line"><span class="comment">// RTCPReceiver::TriggerCallbacksFromRtcpPacket对不同的rtcp包不同处理</span></span><br><span class="line"><span class="comment">// RtpTransportControllerSend::OnTransportFeedback对twcc进行处理实现delay based BWE</span></span><br><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnTransportPacketsFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TransportPacketsFeedback report)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果反馈中没有数据包，返回一个空的网络控制更新</span></span><br><span class="line">  <span class="keyword">if</span> (report.packet_feedbacks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// TODO(bugs.webrtc.org/10125): Design a better mechanism to safe-guard</span></span><br><span class="line">    <span class="comment">// against building very large network queues.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 根据feedback更新发送数据的大小</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateOutstandingData</span>(</span><br><span class="line">        report.data_in_flight.<span class="built_in">bytes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化最大反馈RTT、最小传播RTT和最大接收时间</span></span><br><span class="line">  TimeDelta max_feedback_rtt = TimeDelta::<span class="built_in">MinusInfinity</span>();</span><br><span class="line">  TimeDelta min_propagation_rtt = TimeDelta::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">  Timestamp max_recv_time = Timestamp::<span class="built_in">MinusInfinity</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取已接收的数据包的反馈</span></span><br><span class="line">  std::vector&lt;PacketResult&gt; feedbacks = report.<span class="built_in">ReceivedWithSendInfo</span>();</span><br><span class="line">  <span class="comment">// 遍历获取最大的包到达时间(feedback.receive_time)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : feedbacks)</span><br><span class="line">    max_recv_time = std::<span class="built_in">max</span>(max_recv_time, feedback.receive_time);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计最大feedback_rtt和propagation_rtt</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : feedbacks) &#123;</span><br><span class="line">    TimeDelta feedback_rtt =</span><br><span class="line">        report.feedback_time - feedback.sent_packet.send_time;</span><br><span class="line">    TimeDelta min_pending_time = max_recv_time - feedback.receive_time;</span><br><span class="line">    TimeDelta propagation_rtt = feedback_rtt - min_pending_time;</span><br><span class="line">    <span class="comment">// 计算最大反馈RTT，包发出去到收到feed包</span></span><br><span class="line">    max_feedback_rtt = std::<span class="built_in">max</span>(max_feedback_rtt, feedback_rtt);</span><br><span class="line">    <span class="comment">// 和最小传播RTT，包在网络中传输的rtt，不包含在服务端pending处理的时间</span></span><br><span class="line">    min_propagation_rtt = std::<span class="built_in">min</span>(min_propagation_rtt, propagation_rtt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max_feedback_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    feedback_max_rtts_.<span class="built_in">push_back</span>(max_feedback_rtt.<span class="built_in">ms</span>());</span><br><span class="line">    <span class="comment">// 维护窗口大小32的最大反馈RTT</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxFeedbackRttWindow = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (feedback_max_rtts_.<span class="built_in">size</span>() &gt; kMaxFeedbackRttWindow)</span><br><span class="line">      feedback_max_rtts_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 更新propagation_rtt</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdatePropagationRtt</span>(report.feedback_time,</span><br><span class="line">                                                min_propagation_rtt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只使用数据包反馈，更新loss和delay估计的rtt</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!feedback_max_rtts_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算32大小的窗口内最大反馈RTT的均值</span></span><br><span class="line">      <span class="type">int64_t</span> sum_rtt_ms =</span><br><span class="line">          std::<span class="built_in">accumulate</span>(feedback_max_rtts_.<span class="built_in">begin</span>(), feedback_max_rtts_.<span class="built_in">end</span>(),</span><br><span class="line">                          <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">      <span class="type">int64_t</span> mean_rtt_ms = sum_rtt_ms / feedback_max_rtts_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最大反馈RTT的均值更新基于延迟的BWE的码率估计器中的RTT</span></span><br><span class="line">      <span class="keyword">if</span> (delay_based_bwe_)</span><br><span class="line">        delay_based_bwe_-&gt;<span class="built_in">OnRttUpdate</span>(TimeDelta::<span class="built_in">Millis</span>(mean_rtt_ms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小反馈RTT</span></span><br><span class="line">    TimeDelta feedback_min_rtt = TimeDelta::<span class="built_in">PlusInfinity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : feedbacks) &#123;</span><br><span class="line">      TimeDelta pending_time = max_recv_time - packet_feedback.receive_time;</span><br><span class="line">      TimeDelta rtt = report.feedback_time -</span><br><span class="line">                      packet_feedback.sent_packet.send_time - pending_time;</span><br><span class="line">      <span class="comment">// Value used for predicting NACK round trip time in FEC controller.</span></span><br><span class="line">      feedback_min_rtt = std::<span class="built_in">min</span>(rtt, feedback_min_rtt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小反馈RTT</span></span><br><span class="line">    <span class="keyword">if</span> (feedback_min_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">UpdateRtt</span>(feedback_min_rtt, report.feedback_time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-----------更新丢包率---------*/</span></span><br><span class="line">    <span class="comment">// 上次更新丢包后到现在应该收到的包的总数</span></span><br><span class="line">    expected_packets_since_last_loss_update_ +=</span><br><span class="line">        report.<span class="built_in">PacketsWithFeedback</span>().<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//计算丢包数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : report.<span class="built_in">PacketsWithFeedback</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!packet_feedback.<span class="built_in">IsReceived</span>())</span><br><span class="line">        lost_packets_since_last_loss_update_ += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next_loss_update_是更新丢包的时间点</span></span><br><span class="line">    <span class="keyword">if</span> (report.feedback_time &gt; next_loss_update_) &#123;</span><br><span class="line">      <span class="comment">// 更新下一次更新丢包率的时间戳 kLossUpdateInterval=1s</span></span><br><span class="line">      next_loss_update_ = report.feedback_time + kLossUpdateInterval;</span><br><span class="line">      <span class="comment">// 计算丢包并更新到BWE模块</span></span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">UpdatePacketsLost</span>(</span><br><span class="line">          lost_packets_since_last_loss_update_,</span><br><span class="line">          expected_packets_since_last_loss_update_, report.feedback_time);</span><br><span class="line">      <span class="comment">// 重置丢包参数统计</span></span><br><span class="line">      expected_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">      lost_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测当前是否处于alr</span></span><br><span class="line">  absl::optional&lt;<span class="type">int64_t</span>&gt; alr_start_time =</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>();</span><br><span class="line">  <span class="comment">// 之前处于alr但是当前不在alr状态</span></span><br><span class="line">  <span class="keyword">if</span> (previously_in_alr_ &amp;&amp; !alr_start_time.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="type">int64_t</span> now_ms = report.feedback_time.<span class="built_in">ms</span>();</span><br><span class="line">    <span class="comment">// 告知acknowledged_bitrate_estimator_和probe_controller alr的结束时间</span></span><br><span class="line">    acknowledged_bitrate_estimator_-&gt;<span class="built_in">SetAlrEndedTime</span>(report.feedback_time);</span><br><span class="line">    probe_controller_-&gt;<span class="built_in">SetAlrEndedTimeMs</span>(now_ms);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新alr状态</span></span><br><span class="line">  previously_in_alr_ = alr_start_time.<span class="built_in">has_value</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据feedback计算吞吐量，ack码率</span></span><br><span class="line">  <span class="comment">// AcknowledgedBitrateEstimator::IncomingPacketFeedbackVector</span></span><br><span class="line">  acknowledged_bitrate_estimator_-&gt;<span class="built_in">IncomingPacketFeedbackVector</span>(</span><br><span class="line">      report.<span class="built_in">SortedByReceiveTime</span>());</span><br><span class="line">  <span class="keyword">auto</span> acknowledged_bitrate = acknowledged_bitrate_estimator_-&gt;<span class="built_in">bitrate</span>();</span><br><span class="line">  <span class="comment">// 更新链路容量，设置ack码率</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">SetAcknowledgedRate</span>(acknowledged_bitrate,</span><br><span class="line">                                             report.feedback_time);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*------------码率探测-------------*/</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : report.<span class="built_in">SortedByReceiveTime</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (feedback.sent_packet.pacing_info.probe_cluster_id !=</span><br><span class="line">        PacedPacketInfo::kNotAProbe) &#123;</span><br><span class="line">      <span class="comment">// probe_estimator 根据返回的feedback更新带宽探测的计算</span></span><br><span class="line">      <span class="comment">// ProbeBitrateEstimator::HandleProbeAndEstimateBitrate</span></span><br><span class="line">      probe_bitrate_estimator_-&gt;<span class="built_in">HandleProbeAndEstimateBitrate</span>(feedback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (network_estimator_) &#123;</span><br><span class="line">    network_estimator_-&gt;<span class="built_in">OnTransportPacketsFeedback</span>(report);</span><br><span class="line">    <span class="keyword">auto</span> prev_estimate = estimate_;</span><br><span class="line">    estimate_ = network_estimator_-&gt;<span class="built_in">GetCurrentEstimate</span>();</span><br><span class="line">    <span class="comment">// TODO(srte): Make OnTransportPacketsFeedback signal whether the state</span></span><br><span class="line">    <span class="comment">// changed to avoid the need for this check.</span></span><br><span class="line">    <span class="keyword">if</span> (estimate_ &amp;&amp; (!prev_estimate || estimate_-&gt;last_feed_time !=</span><br><span class="line">                                            prev_estimate-&gt;last_feed_time)) &#123;</span><br><span class="line">      event_log_-&gt;<span class="built_in">Log</span>(std::<span class="built_in">make_unique</span>&lt;RtcEventRemoteEstimate&gt;(</span><br><span class="line">          estimate_-&gt;link_capacity_lower, estimate_-&gt;link_capacity_upper));</span><br><span class="line">      probe_controller_-&gt;<span class="built_in">SetNetworkStateEstimate</span>(*estimate_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取上面循环更新probe_estimator的最终的结果</span></span><br><span class="line">  <span class="comment">// ProbeBitrateEstimator::FetchAndResetLastEstimatedBitrate</span></span><br><span class="line">  absl::optional&lt;DataRate&gt; probe_bitrate =</span><br><span class="line">      probe_bitrate_estimator_-&gt;<span class="built_in">FetchAndResetLastEstimatedBitrate</span>();</span><br><span class="line">  <span class="comment">// 如果enable probe &lt; network_estimate时 忽略probe的特性，则忽略probe_bitrate</span></span><br><span class="line">  <span class="keyword">if</span> (ignore_probes_lower_than_network_estimate_ &amp;&amp; probe_bitrate &amp;&amp;</span><br><span class="line">      estimate_ &amp;&amp; *probe_bitrate &lt; delay_based_bwe_-&gt;<span class="built_in">last_estimate</span>() &amp;&amp;</span><br><span class="line">      *probe_bitrate &lt; estimate_-&gt;link_capacity_lower) &#123;</span><br><span class="line">    probe_bitrate.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果enable</span></span><br><span class="line">  <span class="comment">// 将probe略小于throughput_estimate_(预估吞吐量)的特性</span></span><br><span class="line">  <span class="comment">// 对probe现在acknowledged_bitrate(链路吞吐量)下</span></span><br><span class="line">  <span class="keyword">if</span> (limit_probes_lower_than_throughput_estimate_ &amp;&amp; probe_bitrate &amp;&amp;</span><br><span class="line">      acknowledged_bitrate) &#123;</span><br><span class="line">    DataRate limit =</span><br><span class="line">        std::<span class="built_in">min</span>(delay_based_bwe_-&gt;<span class="built_in">last_estimate</span>(),</span><br><span class="line">                 *acknowledged_bitrate * kProbeDropThroughputFraction);</span><br><span class="line">    probe_bitrate = std::<span class="built_in">max</span>(*probe_bitrate, limit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NetworkControlUpdate update;</span><br><span class="line">  <span class="type">bool</span> recovered_from_overuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送端根据延迟进行带宽估计，根据feedback预估网络状态，然后aimd调整码率</span></span><br><span class="line">  DelayBasedBwe::Result result;</span><br><span class="line">  result = delay_based_bwe_-&gt;<span class="built_in">IncomingPacketFeedbackVector</span>(</span><br><span class="line">      report, acknowledged_bitrate, probe_bitrate, estimate_,</span><br><span class="line">      alr_start_time.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于延迟的预估码率更新了</span></span><br><span class="line">  <span class="keyword">if</span> (result.updated) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.probe) &#123;</span><br><span class="line">      <span class="comment">// bwe使用了探测码率进行重设</span></span><br><span class="line">      <span class="comment">// bandwidth_estimation_也进行重设sendbitrate</span></span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">SetSendBitrate</span>(result.target_bitrate,</span><br><span class="line">                                            report.feedback_time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新bandwidth_estimation_中基于延迟的估计码率</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdateDelayBasedEstimate</span>(report.feedback_time,</span><br><span class="line">                                                    result.target_bitrate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于丢包的带宽估计</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateLossBasedEstimator</span>(</span><br><span class="line">      report, result.delay_detector_state, probe_bitrate,</span><br><span class="line">      alr_start_time.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.updated) &#123;</span><br><span class="line">    <span class="comment">// 码率发生变化，将新码率设置到probe_controller, alr_detector等，</span></span><br><span class="line">    <span class="comment">// 并作用给pacing_controller使用</span></span><br><span class="line">    <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, report.feedback_time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  recovered_from_overuse = result.recovered_from_overuse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (recovered_from_overuse) &#123;</span><br><span class="line">    <span class="comment">// 从overuse中恢复了，重设alr开始时间</span></span><br><span class="line">    probe_controller_-&gt;<span class="built_in">SetAlrStartTimeMs</span>(alr_start_time);</span><br><span class="line">    <span class="comment">// probe探测码率</span></span><br><span class="line">    <span class="comment">// 带宽大幅下降，经过一段时间，根据下降前的码率进行一次主动探测</span></span><br><span class="line">    <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">RequestProbe</span>(report.feedback_time);</span><br><span class="line">    <span class="comment">// 添加探测到网络控制更新中</span></span><br><span class="line">    update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                        probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大反馈RTT是有限的</span></span><br><span class="line">  <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindow</span>() &amp;&amp;</span><br><span class="line">      max_feedback_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 根据码率和RTT更新拥塞窗口的大小更新拥塞窗口大小</span></span><br><span class="line">    <span class="built_in">UpdateCongestionWindowSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将拥塞窗口大小设置到congestion_window_pushback_controller</span></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; current_data_window_) &#123;</span><br><span class="line">    <span class="comment">// 如果有congestion_window_pushback_controller_，将当前的窗口放在通知器下回推给编码器</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">SetDataWindow</span>(</span><br><span class="line">        *current_data_window_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，直接放在结果中</span></span><br><span class="line">    update.congestion_window = current_data_window_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>feedback time计算如下:</p>
<p><img src="feedback-time-calc.png" alt="feedback时间计算" style="zoom:60%;" /></p>
<p>函数中调用<code>DelayBasedBwe::IncomingPacketFeedbackVector</code>以此为起点根据反馈信息预估网络的状态，分析延时梯度变化，做trendline，再调用<code>DelayBasedBwe::MaybeUpdateEstimate</code>调整码率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DelayBasedBwe::Result <span class="title">DelayBasedBwe::IncomingPacketFeedbackVector</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TransportPacketsFeedback&amp; msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; acked_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; probe_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;NetworkStateEstimate&gt; network_estimate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> in_alr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUNS_SERIALIZED</span>(&amp;network_race_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> packet_feedback_vector = msg.<span class="built_in">SortedByReceiveTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_vector.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Very late feedback received.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> DelayBasedBwe::<span class="built_in">Result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uma_recorded_) &#123;</span><br><span class="line">    <span class="built_in">RTC_HISTOGRAM_ENUMERATION</span>(kBweTypeHistogram,</span><br><span class="line">                              BweNames::kSendSideTransportSeqNum,</span><br><span class="line">                              BweNames::kBweNamesMax);</span><br><span class="line">    uma_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> delayed_feedback = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> recovered_from_overuse = <span class="literal">false</span>;</span><br><span class="line">  BandwidthUsage prev_detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  <span class="comment">// 遍历所有接收到的包</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : packet_feedback_vector) &#123;</span><br><span class="line">    delayed_feedback = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 对每个包做trendline，基于延迟的带宽估计</span></span><br><span class="line">    <span class="built_in">IncomingPacketFeedback</span>(packet_feedback, msg.feedback_time);</span><br><span class="line">    <span class="keyword">if</span> (prev_detector_state == BandwidthUsage::kBwUnderusing &amp;&amp;</span><br><span class="line">        active_delay_detector_-&gt;<span class="built_in">State</span>() == BandwidthUsage::kBwNormal) &#123;</span><br><span class="line">      recovered_from_overuse = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev_detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delayed_feedback) &#123;</span><br><span class="line">    <span class="comment">// TODO(bugs.webrtc.org/10125): Design a better mechanism to safe-guard</span></span><br><span class="line">    <span class="comment">// against building very large network queues.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用受限</span></span><br><span class="line">  rate_control_.<span class="built_in">SetInApplicationLimitedRegion</span>(in_alr);</span><br><span class="line">  rate_control_.<span class="built_in">SetNetworkStateEstimate</span>(network_estimate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AIMD调整码率</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MaybeUpdateEstimate</span>(acked_bitrate, probe_bitrate,</span><br><span class="line">                             std::<span class="built_in">move</span>(network_estimate),</span><br><span class="line">                             recovered_from_overuse, in_alr, msg.feedback_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DelayBasedBwe::IncomingPacketFeedback</code>用于处理传入的数据包反馈。根据反馈的内容更新延迟检测器。如果流超时，会重置相关的对象和检测器。如果启用了音频分离，会根据数据包的类型（音频或视频）选择对应的延迟检测器进行更新。最后，根据数据包的发送时间、接收时间和大小，计算出发送间隔、接收间隔和大小间隔，然后更新数据包的延迟检测器。这个函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelayBasedBwe::IncomingPacketFeedback</span><span class="params">(<span class="type">const</span> PacketResult&amp; packet_feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前包和上一个包在feedback的时间相隔太远，重置delay_detector</span></span><br><span class="line">  <span class="keyword">if</span> (last_seen_packet_.<span class="built_in">IsInfinite</span>() ||</span><br><span class="line">      at_time - last_seen_packet_ &gt; kStreamTimeOut) &#123;</span><br><span class="line">    </span><br><span class="line">    video_inter_arrival_delta_ =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;InterArrivalDelta&gt;(kSendTimeGroupLength);</span><br><span class="line">    audio_inter_arrival_delta_ =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;InterArrivalDelta&gt;(kSendTimeGroupLength);</span><br><span class="line">    <span class="comment">// 重置视频和音频的延迟检测器</span></span><br><span class="line">    video_delay_detector_.<span class="built_in">reset</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TrendlineEstimator</span>(key_value_config_, network_state_predictor_));</span><br><span class="line">    audio_delay_detector_.<span class="built_in">reset</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TrendlineEstimator</span>(key_value_config_, network_state_predictor_));</span><br><span class="line">    <span class="comment">// 设置活动的延迟检测器为视频延迟检测器</span></span><br><span class="line">    active_delay_detector_ = video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最后看到的数据包的时间</span></span><br><span class="line">  last_seen_packet_ = at_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为忽略小数据包的替代方案，我们可以为过度使用检测分离音频和视频数据包</span></span><br><span class="line">  DelayIncreaseDetectorInterface* delay_detector_for_packet =</span><br><span class="line">      video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果将音频和视频的分开码率预估，根据包是audio/video选择对应的delay_dector</span></span><br><span class="line">  <span class="keyword">if</span> (separate_audio_.enabled) &#123;</span><br><span class="line">    <span class="comment">// 如果发送的数据包是音频数据包</span></span><br><span class="line">    <span class="keyword">if</span> (packet_feedback.sent_packet.audio) &#123;</span><br><span class="line">      <span class="comment">// 将音频延迟检测器设置为数据包的延迟检测器</span></span><br><span class="line">      delay_detector_for_packet = audio_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="comment">// 增加自上次视频以来的音频数据包数量</span></span><br><span class="line">      audio_packets_since_last_video_++;</span><br><span class="line">      <span class="comment">// 如果自上次视频以来的音频数据包数量超过阈值，并且从上次视频数据包接收到现在的时间超过时间阈值</span></span><br><span class="line">      <span class="keyword">if</span> (audio_packets_since_last_video_ &gt; separate_audio_.packet_threshold &amp;&amp;</span><br><span class="line">          packet_feedback.receive_time - last_video_packet_recv_time_ &gt;</span><br><span class="line">              separate_audio_.time_threshold) &#123;</span><br><span class="line">        <span class="comment">// 将活动的延迟检测器设置为音频延迟检测器</span></span><br><span class="line">        active_delay_detector_ = audio_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果发送的数据包是视频数据包，重置自上次视频以来的音频数据包数量，并更新上次视频数据包接收的时间</span></span><br><span class="line">      audio_packets_since_last_video_ = <span class="number">0</span>;</span><br><span class="line">      last_video_packet_recv_time_ =</span><br><span class="line">          std::<span class="built_in">max</span>(last_video_packet_recv_time_, packet_feedback.receive_time);</span><br><span class="line">      <span class="comment">// 将活动的延迟检测器设置为视频延迟检测器</span></span><br><span class="line">      active_delay_detector_ = video_delay_detector_.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数据包大小</span></span><br><span class="line">  DataSize packet_size = packet_feedback.sent_packet.size;</span><br><span class="line">  <span class="comment">// 初始化发送间隔、接收间隔和大小间隔</span></span><br><span class="line">  TimeDelta send_delta = TimeDelta::<span class="built_in">Zero</span>();</span><br><span class="line">  TimeDelta recv_delta = TimeDelta::<span class="built_in">Zero</span>();</span><br><span class="line">  <span class="type">int</span> size_delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据是否启用音频分离和发送的数据包是否为音频数据包，选择对应的到达间隔差值对象</span></span><br><span class="line">  InterArrivalDelta* inter_arrival_for_packet =</span><br><span class="line">      (separate_audio_.enabled &amp;&amp; packet_feedback.sent_packet.audio)</span><br><span class="line">          ? audio_inter_arrival_delta_.<span class="built_in">get</span>()</span><br><span class="line">          : video_inter_arrival_delta_.<span class="built_in">get</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 0x01. 到达时间滤波器，计算两包组的发送间隔(send_delta), 接收间隔(recv_delta)和数据包大小差(size_delta)</span></span><br><span class="line">  <span class="type">bool</span> calculated_deltas = inter_arrival_for_packet-&gt;<span class="built_in">ComputeDeltas</span>(</span><br><span class="line">      packet_feedback.sent_packet.send_time, packet_feedback.receive_time,</span><br><span class="line">      at_time, packet_size.<span class="built_in">bytes</span>(), &amp;send_delta, &amp;recv_delta, &amp;size_delta);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行拥塞状态的判断</span></span><br><span class="line">  delay_detector_for_packet-&gt;<span class="built_in">Update</span>(recv_delta.<span class="built_in">ms</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line">                                    send_delta.<span class="built_in">ms</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line">                                    packet_feedback.sent_packet.send_time.<span class="built_in">ms</span>(),</span><br><span class="line">                                    packet_feedback.receive_time.<span class="built_in">ms</span>(),</span><br><span class="line">                                    packet_size.<span class="built_in">bytes</span>(), calculated_deltas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="到达时间滤波器"><a href="#到达时间滤波器" class="headerlink" title="到达时间滤波器"></a>到达时间滤波器</h3><p><code>InterArrivalDelta::ComputeDeltas</code>函数包组发送时间差 <script type="math/tex">T_i-T_{i-1}</script> 和到达的时间差 <script type="math/tex">t_i-t_{i-1}</script> 以及包组大小差：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InterArrivalDelta::ComputeDeltas</span><span class="params">(Timestamp send_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Timestamp arrival_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Timestamp system_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">size_t</span> packet_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TimeDelta* send_time_delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TimeDelta* arrival_time_delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">int</span>* packet_size_delta)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> calculated_deltas = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 当前包组首个包，存储包组信息，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (current_timestamp_group_.<span class="built_in">IsFirstPacket</span>()) &#123;</span><br><span class="line">    current_timestamp_group_.send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_arrival = arrival_time;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_timestamp_group_.first_send_time &gt; send_time) &#123;</span><br><span class="line">    <span class="comment">// 不是包组的第一个包，但是当前包比第一个包还要早，说明是乱序包，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">NewTimestampGroup</span>(arrival_time, send_time)) &#123;</span><br><span class="line">    <span class="comment">// 判断是新的包组，则使用current_group - prev_group得到delta</span></span><br><span class="line">    <span class="keyword">if</span> (prev_timestamp_group_.complete_time.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      <span class="comment">// 发送时间差 = 当前包组发送时间-上一个包组发送时间</span></span><br><span class="line">      *send_time_delta =</span><br><span class="line">          current_timestamp_group_.send_time - prev_timestamp_group_.send_time;</span><br><span class="line">      <span class="comment">// 接收时间差 = 当前包组接收时间-上一个包组接收时间</span></span><br><span class="line">      *arrival_time_delta = current_timestamp_group_.complete_time -</span><br><span class="line">                            prev_timestamp_group_.complete_time;</span><br><span class="line">      <span class="comment">// 接收时间和处理时间是否偏差过大（3s），防止系统时间跳变影响计算</span></span><br><span class="line">      TimeDelta system_time_delta = current_timestamp_group_.last_system_time -</span><br><span class="line">                                    prev_timestamp_group_.last_system_time;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (*arrival_time_delta - system_time_delta &gt;=</span><br><span class="line">          kArrivalTimeOffsetThreshold) &#123;</span><br><span class="line">        <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;The arrival time clock offset has changed (diff = &quot;</span></span><br><span class="line">            &lt;&lt; arrival_time_delta-&gt;<span class="built_in">ms</span>() - system_time_delta.<span class="built_in">ms</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; ms), resetting.&quot;</span>;</span><br><span class="line">        <span class="built_in">Reset</span>();<span class="comment">// 重置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包在 socket 接收到 BWE 这段路径中是否被重新排序</span></span><br><span class="line">      <span class="keyword">if</span> (*arrival_time_delta &lt; TimeDelta::<span class="built_in">Zero</span>()) &#123;</span><br><span class="line">        ++num_consecutive_reordered_packets_;</span><br><span class="line">        <span class="comment">// 包组在收到本地到达时间戳后被重新排序（可能是乱序到达的包被重新排序），</span></span><br><span class="line">        <span class="comment">// 连续超过 kReorderedResetThreshold(3) 次会进行重置</span></span><br><span class="line">        <span class="keyword">if</span> (num_consecutive_reordered_packets_ &gt;= kReorderedResetThreshold) &#123;</span><br><span class="line">          <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;Packets between send burst arrived out of order, resetting:&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; arrival_time_delta_ms=&quot;</span> &lt;&lt; arrival_time_delta-&gt;<span class="built_in">ms</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, send_time_delta_ms=&quot;</span> &lt;&lt; send_time_delta-&gt;<span class="built_in">ms</span>();</span><br><span class="line">          <span class="built_in">Reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num_consecutive_reordered_packets_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包组大小差 = 当前包组大小-上一个包组大小</span></span><br><span class="line">      *packet_size_delta = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(current_timestamp_group_.size) -</span><br><span class="line">                           <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(prev_timestamp_group_.size);</span><br><span class="line">      calculated_deltas = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的包组改为上个包组</span></span><br><span class="line">    prev_timestamp_group_ = current_timestamp_group_;</span><br><span class="line">    <span class="comment">// 重置当前包组信息</span></span><br><span class="line">    current_timestamp_group_.first_send_time = send_time;</span><br><span class="line">    current_timestamp_group_.send_time = send_time;</span><br><span class="line">    current_timestamp_group_.first_arrival = arrival_time;</span><br><span class="line">    current_timestamp_group_.size = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不满一个包组，设置新的时间戳</span></span><br><span class="line">    current_timestamp_group_.send_time =</span><br><span class="line">        std::<span class="built_in">max</span>(current_timestamp_group_.send_time, send_time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修正累计包组数据</span></span><br><span class="line">  <span class="comment">// 当前包组累计大小</span></span><br><span class="line">  current_timestamp_group_.size += packet_size;</span><br><span class="line">  <span class="comment">// 更新当前包组的最新到达时间</span></span><br><span class="line">  current_timestamp_group_.complete_time = arrival_time;</span><br><span class="line">  <span class="comment">// 更新当前包组的最新处理时间</span></span><br><span class="line">  current_timestamp_group_.last_system_time = system_time;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calculated_deltas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新包组实现见<a href="#包组">包组</a></p>
<h3 id="Trendline-Filter"><a href="#Trendline-Filter" class="headerlink" title="Trendline Filter"></a>Trendline Filter</h3><p>新版本中用<code>Trendline Filter</code>根据到达时间差、发送时间差、数据大小差来估计单向延迟的趋势。在执行了<code>InterArrivalDelta::NewTimestampGroup</code>函数判断是新的包组，才会计算包组之间的delta去做trendline。<code>rendlineEstimator::Update</code>函数是<code>TrendlineEstimator</code>类的接口函数，调用<code>TrendlineEstimator::UpdateTrendline</code>计算基于延迟的带宽估计，进行Trendline Filter滤波，判断当前的网络状态、更新阈值等。</p>
<p>单个包组传输的延迟梯度为: <script type="math/tex">d_i = (t_i-t_{i-1})-(T_i-T_{i-1})</script></p>
<p>每个包组叠加延迟为: <script type="math/tex">acc_{delay_i } = \sum d_i</script></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::Update</span><span class="params">(<span class="type">double</span> recv_delta_ms, <span class="comment">// 包组接收时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">double</span> send_delta_ms, <span class="comment">// 包组发送时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int64_t</span> send_time_ms, <span class="comment">// 当前处理的包的发送时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int64_t</span> arrival_time_ms, <span class="comment">// 当前处理的包的到达时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> packet_size, <span class="comment">// 当前处理的包的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> calculated_deltas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (calculated_deltas) &#123;</span><br><span class="line">    <span class="built_in">UpdateTrendline</span>(recv_delta_ms, send_delta_ms, send_time_ms, arrival_time_ms,</span><br><span class="line">                    packet_size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (network_state_predictor_) &#123;</span><br><span class="line">    hypothesis_predicted_ = network_state_predictor_-&gt;<span class="built_in">Update</span>(</span><br><span class="line">        send_time_ms, arrival_time_ms, hypothesis_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x02 滤波</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::UpdateTrendline</span><span class="params">(<span class="type">double</span> recv_delta_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">double</span> send_delta_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> send_time_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> arrival_time_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> packet_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单个包组的延迟梯度</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> delta_ms = recv_delta_ms - send_delta_ms;</span><br><span class="line">  ++num_of_deltas_; <span class="comment">// 累计的延迟梯度数据点计数</span></span><br><span class="line">  <span class="comment">// 限制数据点计数不超过最大值1000</span></span><br><span class="line">  num_of_deltas_ = std::<span class="built_in">min</span>(num_of_deltas_, kDeltaCounterMax);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录第一个到达时间点</span></span><br><span class="line">  <span class="keyword">if</span> (first_arrival_time_ms_ == <span class="number">-1</span>)</span><br><span class="line">    first_arrival_time_ms_ = arrival_time_ms;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包组累积延迟梯度</span></span><br><span class="line">  accumulated_delay_ += delta_ms;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;accumulated_delay_ms&quot;</span>, arrival_time_ms,</span><br><span class="line">                        accumulated_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次指数平滑滤波器对网络叠加延迟进行平滑</span></span><br><span class="line">  <span class="comment">// 平滑系数smoothing_coef_取0.9，意味着新的延迟梯度观测值的变化对平滑值的影响较小，减少了修正幅度</span></span><br><span class="line">  <span class="comment">// 如果时间序列波动不大，比较平稳，则平滑系数应取小一点，</span></span><br><span class="line">  <span class="comment">// 以减少修正幅度，使预测模型能包含较长时间序列的信息。</span></span><br><span class="line">  <span class="comment">// 如果时间序列具有迅速且明显的变动倾向，则平滑系数应取大一点，</span></span><br><span class="line">  <span class="comment">// 以使预测模型灵敏度高些，以便迅速跟上数据的变化。</span></span><br><span class="line">  smoothed_delay_ = smoothing_coef_ * smoothed_delay_ +</span><br><span class="line">                    (<span class="number">1</span> - smoothing_coef_) * accumulated_delay_;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;smoothed_delay_ms&quot;</span>, arrival_time_ms,</span><br><span class="line">                        smoothed_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双端队列维护数据窗口</span></span><br><span class="line">  <span class="comment">// 距离第一个RTP包到达的间距，平滑后的叠加延迟，未平滑的包组叠加延迟</span></span><br><span class="line">  delay_hist_.<span class="built_in">emplace_back</span>(</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(arrival_time_ms - first_arrival_time_ms_),</span><br><span class="line">      smoothed_delay_, accumulated_delay_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启用排序则按到达时间排序。</span></span><br><span class="line">  <span class="keyword">if</span> (settings_.enable_sort) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = delay_hist_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">         i &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         delay_hist_[i].arrival_time_ms &lt; delay_hist_[i - <span class="number">1</span>].arrival_time_ms;</span><br><span class="line">         --i) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(delay_hist_[i], delay_hist_[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护窗口点大小为20，弹出最早的数据</span></span><br><span class="line">  <span class="keyword">if</span> (delay_hist_.<span class="built_in">size</span>() &gt; settings_.window_size)</span><br><span class="line">    delay_hist_.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> trend = prev_trend_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 达到的了窗口的大小根据最小二乘计算trend</span></span><br><span class="line">  <span class="keyword">if</span> (delay_hist_.<span class="built_in">size</span>() == settings_.window_size) &#123;</span><br><span class="line">    <span class="comment">// 最小二乘法计算斜率</span></span><br><span class="line">    <span class="comment">// 延迟趋势可以被视为（发送码率 - 网络容量）/网络容量的估算</span></span><br><span class="line">    <span class="comment">// 0 &lt; trend &lt; 1   -&gt;  延迟增加，队列正在填充</span></span><br><span class="line">    <span class="comment">//   trend == 0    -&gt;  延迟不变，队列长度不变</span></span><br><span class="line">    <span class="comment">//   trend &lt; 0     -&gt;  延迟减少，队列正在排空</span></span><br><span class="line">    trend = <span class="built_in">LinearFitSlope</span>(delay_hist_).<span class="built_in">value_or</span>(trend);</span><br><span class="line">    <span class="comment">// 如果启用了斜率限制，对趋势线的斜率进行限制</span></span><br><span class="line">    <span class="keyword">if</span> (settings_.enable_cap) &#123;</span><br><span class="line">      <span class="comment">// 计算斜率的上限</span></span><br><span class="line">      absl::optional&lt;<span class="type">double</span>&gt; cap = <span class="built_in">ComputeSlopeCap</span>(delay_hist_, settings_);</span><br><span class="line">      <span class="keyword">if</span> (trend &gt;= <span class="number">0</span> &amp;&amp; cap.<span class="built_in">has_value</span>() &amp;&amp; trend &gt; cap.<span class="built_in">value</span>()) &#123;</span><br><span class="line">        trend = cap.<span class="built_in">value</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;trendline_slope&quot;</span>, arrival_time_ms, trend);</span><br><span class="line">  <span class="comment">// 将排队延迟梯度和阈值相比较，判断当前网络情况</span></span><br><span class="line">  <span class="comment">// 0x03. TrendlineEstimator::Detect 过载检测</span></span><br><span class="line">  <span class="built_in">Detect</span>(trend, send_delta_ms, arrival_time_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最小二乘计算斜率 <script type="math/tex">k</script> 在<code>absl::optional&lt;double&gt; LinearFitSlope</code>函数中计算:</p>
<script type="math/tex; mode=display">
\begin{equation}
k=\frac{\sum_{i} \left(y_i-\bar{y} \right)\left(x_i-\bar{x} \right)}{\sum_{i}\left(x_i-\bar{x} \right)^2}
\end{equation}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;<span class="type">double</span>&gt; <span class="title">LinearFitSlope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::deque&lt;TrendlineEstimator::PacketTiming&gt;&amp; packets)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(packets.<span class="built_in">size</span>() &gt;= <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// Compute the &quot;center of mass&quot;.</span></span><br><span class="line">  <span class="type">double</span> sum_x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> sum_y = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 求和</span></span><br><span class="line">  <span class="comment">// y是平滑得到的累计演示梯度，x是时间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet : packets) &#123;</span><br><span class="line">    sum_x += packet.arrival_time_ms;</span><br><span class="line">    sum_y += packet.smoothed_delay_ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 均值</span></span><br><span class="line">  <span class="type">double</span> x_avg = sum_x / packets.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">double</span> y_avg = sum_y / packets.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// Compute the slope k = \sum (x_i-x_avg)(y_i-y_avg) / \sum (x_i-x_avg)^2</span></span><br><span class="line">  <span class="type">double</span> numerator = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> denominator = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet : packets) &#123;</span><br><span class="line">    <span class="type">double</span> x = packet.arrival_time_ms;</span><br><span class="line">    <span class="type">double</span> y = packet.smoothed_delay_ms;</span><br><span class="line">    numerator += (x - x_avg) * (y - y_avg);</span><br><span class="line">    denominator += (x - x_avg) * (x - x_avg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (denominator == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用最小二乘法拟合直线 <script type="math/tex">y=kx+b</script>，这里边的 <script type="math/tex">x</script> 是包组的接收时间，<script type="math/tex">y</script> 是<code>smoothed_delay</code>，<script type="math/tex">k</script> 就是<code>trend</code>，反映了网络拥塞状况，作用是检测网络是否过载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;<span class="type">double</span>&gt; <span class="title">ComputeSlopeCap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::deque&lt;TrendlineEstimator::PacketTiming&gt;&amp; packets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TrendlineEstimatorSettings&amp; settings)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保设置的起始和结束数据包数是有效的</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(<span class="number">1</span> &lt;= settings.beginning_packets &amp;&amp;</span><br><span class="line">             settings.beginning_packets &lt; packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(<span class="number">1</span> &lt;= settings.end_packets &amp;&amp;</span><br><span class="line">             settings.end_packets &lt; packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(settings.beginning_packets + settings.end_packets &lt;=</span><br><span class="line">             packets.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// 初始化早期和晚期数据包，用于计算斜率上限。</span></span><br><span class="line">  TrendlineEstimator::PacketTiming early = packets[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; settings.beginning_packets; ++i) &#123;</span><br><span class="line">    <span class="comment">// 找到延迟最小的一个early包</span></span><br><span class="line">    <span class="keyword">if</span> (packets[i].raw_delay_ms &lt; early.raw_delay_ms)</span><br><span class="line">      early = packets[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到延迟最小的一个late包</span></span><br><span class="line">  <span class="type">size_t</span> late_start = packets.<span class="built_in">size</span>() - settings.end_packets;</span><br><span class="line">  TrendlineEstimator::PacketTiming late = packets[late_start];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = late_start + <span class="number">1</span>; i &lt; packets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packets[i].raw_delay_ms &lt; late.raw_delay_ms)</span><br><span class="line">      late = packets[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// early包和late包的到达时间间隔少于1ms,则返回空值</span></span><br><span class="line">  <span class="keyword">if</span> (late.arrival_time_ms - early.arrival_time_ms &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 延迟差除以到达时间间隔,再加上cap_uncertainty,作为容量上限返回</span></span><br><span class="line">  <span class="keyword">return</span> (late.raw_delay_ms - early.raw_delay_ms) /</span><br><span class="line">             (late.arrival_time_ms - early.arrival_time_ms) +</span><br><span class="line">         settings.cap_uncertainty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接线性回归可能会导致，在某些情况下可能会高估网络的实际拥塞程度，导致过多误报。这里引入了网络容量的上限，对trend进行约束。避免了trend被高估，防止对网络状态的估计过于悲观，降低了误报，同时保持了对网络拥塞的响应性。</p>
<h3 id="过载检测器"><a href="#过载检测器" class="headerlink" title="过载检测器"></a>过载检测器</h3><p>最小二乘拟合出来的<code>trend</code>会比较小，需要乘以增益和点的个数进行修正。设置的阈值范围内 <script type="math/tex">[-\gamma,\gamma]</script>，</p>
<ul>
<li><script type="math/tex">trend > \gamma</script>，说明网络网络拥塞队列在增大，网络过载</li>
<li><script type="math/tex">trend <  -\gamma</script>，说明网络拥塞队列在变小，拥塞情况在改善，网络低负载</li>
<li><script type="math/tex">-\gamma \leq trend \leq \gamma</script>，网络正常</li>
</ul>
<p><code>TrendlineEstimator::Detect</code>函数根据<code>trend</code>判断当前带宽的状态。出现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::Detect</span><span class="params">(<span class="type">double</span> trend, <span class="type">double</span> ts_delta, <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_of_deltas_ &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwNormal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// trend值太小，这里乘以阈值增益和包组数量</span></span><br><span class="line">  <span class="comment">// 最多kMinNumDeltas=60个采样，threshold_gain_=4</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> modified_trend =</span><br><span class="line">      std::<span class="built_in">min</span>(num_of_deltas_, kMinNumDeltas) * trend * threshold_gain_;</span><br><span class="line">  prev_modified_trend_ = modified_trend;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;T&quot;</span>, now_ms, modified_trend);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;threshold&quot;</span>, now_ms, threshold_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修正后和阈值比较，判断当前状态</span></span><br><span class="line">  <span class="comment">// 过载条件# 4个</span></span><br><span class="line">  <span class="comment">// #1. 超过阈值，拥塞加剧</span></span><br><span class="line">  <span class="keyword">if</span> (modified_trend &gt; threshold_) &#123;</span><br><span class="line">    <span class="comment">// 过载时长等于包组发送时间差值的累加</span></span><br><span class="line">    <span class="comment">// 第一次过载，过载时间设置为两包组发送时间差的一半</span></span><br><span class="line">    <span class="comment">// 为什么一半？类似于TCP 的慢启动策略？</span></span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ == <span class="number">-1</span>) &#123;</span><br><span class="line">      time_over_using_ = ts_delta / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 持续过载，加上包组发送时间差</span></span><br><span class="line">      time_over_using_ += ts_delta;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过载计数器</span></span><br><span class="line">    overuse_counter_++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 过载时间持续时间超过了阈值 10ms</span></span><br><span class="line">    <span class="comment">// #3. 并且累计触发过载的次数大于1</span></span><br><span class="line">    <span class="comment">// 这样为了抗抖动，避免短暂的高延迟导致误判成过载。所以必须是持续过载才可以</span></span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ &gt; overusing_time_threshold_ &amp;&amp; overuse_counter_ &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// #4. 比上一次延时梯度还要高，延迟在恶化，才会处于过载</span></span><br><span class="line">      <span class="comment">// 比上次低则认为过载程度减弱，网络在编号，不处于过载状态</span></span><br><span class="line">      <span class="keyword">if</span> (trend &gt;= prev_trend_) &#123;</span><br><span class="line">        <span class="comment">// 清空状态信息，重新开始下一次的检测</span></span><br><span class="line">        time_over_using_ = <span class="number">0</span>;</span><br><span class="line">        overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 满足所有过载触发条件，触发过载，设置过载状态</span></span><br><span class="line">        hypothesis_ = BandwidthUsage::kBwOverusing;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modified_trend &lt; -threshold_) &#123;</span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwUnderusing;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断处于 normal 状态</span></span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwNormal;</span><br><span class="line">  &#125;</span><br><span class="line">  prev_trend_ = trend;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新阈值</span></span><br><span class="line">  <span class="built_in">UpdateThreshold</span>(modified_trend, now_ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><blockquote><p>为什么不采用固定的阈值：</p>
<ul>
<li>固定阈值过大，在检测到过载信号时，队列延迟可能已经变得非常大，或者无法探测到网络拥塞，算法不够灵敏</li>
<li>固定的阈值太小，导致算法对单向延迟梯度的变化过于敏感，很小的延迟梯度都会被误判为过载，导致过载检测器频繁地检测到过载信号，导致基于时延的控制器因为频繁的过载信号而不断地降低预测的带宽</li>
<li>固定的阈值导致GCC和TCP流（TCP是基于丢包的拥塞控制）共存的竞争中产生问题。TCP流的高延迟梯度可能会导致GCC产生大量的过载信号，有限状态机总是在降低发送码率，最终导致GCC码率被耗尽。即在和TCP流的竞争中，GCC流量出现饥饿现象，所以应该适当提高阈值。</li>
</ul>
</blockquote>
<p>理想状况下，网络的延迟梯度是0，实际的网络中，不同转发路径的延迟梯度有波动且波动大小不同。阈值随着延迟梯度的变化动态调整，可以降低GCC算法对延迟梯度变化的敏感度。WebRTC使用了一种自适应的阈值调节算法：</p>
<script type="math/tex; mode=display">
\begin{equation}
\gamma_i = \gamma_{i-1} + K*\Delta T *\left(|trend_i|-\gamma_{i-1}\right)
\end{equation}</script><p>其中 <script type="math/tex">\Delta T = t_i - t_{i-1}</script> 表示两组包计算延时梯度的时间差，意义就是距上次更新阈值时的时间间隔，每组数据包会触发一次探测，同时更新一次阈值。<script type="math/tex">k</script> 是一个变化率，增长的基值是：当前的<code>trend</code>和上一个阈值的差值：</p>
<script type="math/tex; mode=display">
\begin{equation}
K = \begin{cases}
   k_d & |trend(t_i)|<\gamma_{i-1} \\
   k_u & otherwise
\end{cases}
\end{equation}</script><p>其中 <script type="math/tex">k_d=0.039,k_u=0.0087</script>。梯度小于阈值的时候，值大是为了梯度能够迅速收敛。</p>
<p><strong>这里为什么用延时梯度更新阈值？</strong></p>
<p>过载检测器之后，要进行阈值的更新，在<code>TrendlineEstimator::UpdateThreshold</code>函数实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x04. 更新阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrendlineEstimator::UpdateThreshold</span><span class="params">(<span class="type">double</span> modified_trend,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是第一次更新阈值，初始化最后一次更新的时间。</span></span><br><span class="line">  <span class="keyword">if</span> (last_update_ms_ == <span class="number">-1</span>)</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line">  <span class="comment">// 修改后延迟梯度斜率和阈值的差值超过最大偏移量15，不更新阈值</span></span><br><span class="line">  <span class="comment">// 避免网络故障（如容量突然降低）导致的延迟梯度的的瞬时急剧增加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(modified_trend) &gt; threshold_ + kMaxAdaptOffsetMs) &#123;</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择变化率  k_up_(0.0087)，k_down_(0.039)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在拥塞增大时缓慢调整阈值，避免网络抖动;</span></span><br><span class="line">  <span class="comment">// 在拥塞减小时快速调整阈值，使系统更快对网络状态变化作出响应</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> k = <span class="built_in">fabs</span>(modified_trend) &lt; threshold_ ? k_down_ : k_up_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> kMaxTimeDeltaMs = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阈值的调整量与自上次阈值更新以来的时间间隔成正比，时间越长，调整越多</span></span><br><span class="line">  <span class="comment">// 这里使用的是包组的到达时间差，过载检测累计时间使用的是包组发送时间差</span></span><br><span class="line">  <span class="comment">// 限制在最大时间差kMaxTimeDeltaMs=100ms内</span></span><br><span class="line">  <span class="type">int64_t</span> time_delta_ms = std::<span class="built_in">min</span>(now_ms - last_update_ms_, kMaxTimeDeltaMs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据拥塞值的变化（fabs(modified_trend) - threshold_)）、时间差以及选择的变化率，更新阈值</span></span><br><span class="line">  <span class="comment">// 拥塞值不变，阈值保持不变；拥塞值增大，且时间间隔较长，阈值会相应增加；</span></span><br><span class="line">  <span class="comment">// 拥塞值减小，阈值会相应减小。</span></span><br><span class="line">  <span class="comment">// 这样能够更灵敏地感知和适应网络拥塞状况</span></span><br><span class="line">  threshold_ += k * (<span class="built_in">fabs</span>(modified_trend) - threshold_) * time_delta_ms;</span><br><span class="line">  <span class="comment">// 防止阈值过大或过小导致不稳定的行为</span></span><br><span class="line">  threshold_ = rtc::<span class="built_in">SafeClamp</span>(threshold_, <span class="number">6.f</span>, <span class="number">600.f</span>);</span><br><span class="line">  last_update_ms_ = now_ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="码率调整"><a href="#码率调整" class="headerlink" title="码率调整"></a>码率调整</h3><p>码率控制维护一个状态机，<strong>根据过载探测器输出的信号，估算基于延迟的网络速率</strong> <script type="math/tex">A_r</script>。</p>
<p><img src="02.png" alt="p2" style="zoom:32%;" /></p>
<p>有限状态机的目标是最小化端到端路径上缓冲区中的排队延迟。当网络拥塞时，过载检测器触发overuse信号，状态机处于 Decrase状态，应该降低发送码率，降低为过去 $500 ms$ 时间窗口内的最大 <code>acked_bitrate</code>的0.85倍；当网络中排队的数据包被快速释放时，过载检测器触发underuse信号，状态机进入hold状态；直到缓冲区被清空，网络平稳，过载检测器触发normal信号，状态机进入increase状态，开始探测是否可以增加发送码率。码率的调整根据以下式子：</p>
<script type="math/tex; mode=display">
\begin{equation}
A_r(t_i) = \begin{cases}
    \eta A_r(t_{i-1}) & \sigma=Increase \\
    \alpha R_r(t_{i}) & \sigma=Decrease \\
    A_r(t_{i-1}) & \sigma=Hold 
\end{cases}
\end{equation}</script><p>其中 <script type="math/tex">\eta=1.05, \alpha = 0.85</script>。</p>
<p><code>DelayBasedBwe::IncomingPacketFeedbackVector-&gt;DelayBasedBwe::MaybeUpdateEstimate</code>根据当前的网络状态更新带宽估计。如果当前正在过度使用带宽，尝试降低比特率；如果不在过度使用状态，根据探测的比特率或已确认的比特率来更新带宽估计。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x05. 根据拥塞去估计码率</span></span><br><span class="line"><span class="function">DelayBasedBwe::Result <span class="title">DelayBasedBwe::MaybeUpdateEstimate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; acked_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;DataRate&gt; probe_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;NetworkStateEstimate&gt; state_estimate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> recovered_from_overuse,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> in_alr, <span class="comment">// 是否在应用有限的状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  Result result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前正在过载带宽</span></span><br><span class="line">  <span class="keyword">if</span> (active_delay_detector_-&gt;<span class="built_in">State</span>() == BandwidthUsage::kBwOverusing) &#123;</span><br><span class="line">    <span class="comment">// 如果有已确认的比特率，并且在当前时间需要进一步减少比特率</span></span><br><span class="line">    <span class="comment">// ALR下overuse将码率过程比较特殊，这里是为了解决一个issue：10144</span></span><br><span class="line">    <span class="comment">// 大意也就是说因ALR无法发送足够的码率使得探测带宽上升，完全是依赖周期性的alr probe</span></span><br><span class="line">    <span class="comment">// 当出现overuse假峰值时，不能像正常一样使用ack_bitrate做AIMD，否则会使得码率远低于estimate_bitrate</span></span><br><span class="line">    <span class="comment">// ack rate此时不太可信，所以使用estimate_bitrate去预估然后迅速发一个probe去判断</span></span><br><span class="line">    <span class="comment">// 预估的码率是否准确</span></span><br><span class="line">    <span class="keyword">if</span> (acked_bitrate &amp;&amp;</span><br><span class="line">        rate_control_.<span class="built_in">TimeToReduceFurther</span>(at_time, *acked_bitrate)) &#123;</span><br><span class="line">      result.updated =</span><br><span class="line">          <span class="built_in">UpdateEstimate</span>(at_time, acked_bitrate, &amp;result.target_bitrate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!acked_bitrate &amp;&amp; rate_control_.<span class="built_in">ValidEstimate</span>() &amp;&amp;</span><br><span class="line">               rate_control_.<span class="built_in">InitialTimeToReduceFurther</span>(at_time)) &#123;</span><br><span class="line">      <span class="comment">//ack_bitrate没有测出来，单纯的用时间去判断能否再次降低码率</span></span><br><span class="line">      <span class="comment">// 在测量到确认的比特率之前就发生过载。每200毫秒减少发送速率50%。</span></span><br><span class="line">      rate_control_.<span class="built_in">SetEstimate</span>(rate_control_.<span class="built_in">LatestEstimate</span>() / <span class="number">2</span>, at_time);</span><br><span class="line">      result.updated = <span class="literal">true</span>;</span><br><span class="line">      result.probe = <span class="literal">false</span>;</span><br><span class="line">      result.target_bitrate = rate_control_.<span class="built_in">LatestEstimate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据probe_bitrate信息进行更新，这通常是在启动阶段的探测阶段。</span></span><br><span class="line">    <span class="keyword">if</span> (probe_bitrate) &#123;</span><br><span class="line">      <span class="comment">// 如果有探测码率，直接使用探测码率</span></span><br><span class="line">      result.probe = <span class="literal">true</span>;</span><br><span class="line">      result.updated = <span class="literal">true</span>;</span><br><span class="line">      rate_control_.<span class="built_in">SetEstimate</span>(*probe_bitrate, at_time);</span><br><span class="line">      result.target_bitrate = rate_control_.<span class="built_in">LatestEstimate</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有的话，根据之前的估计值进行更新</span></span><br><span class="line">      result.updated =</span><br><span class="line">          <span class="built_in">UpdateEstimate</span>(at_time, acked_bitrate, &amp;result.target_bitrate);</span><br><span class="line">      result.recovered_from_overuse = recovered_from_overuse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取延迟检测器的状态</span></span><br><span class="line">  BandwidthUsage detector_state = active_delay_detector_-&gt;<span class="built_in">State</span>();</span><br><span class="line">  <span class="comment">// 如果估算已更新且估算比特率不等于之前的比特率，或者检测器的状态不等于之前的状态</span></span><br><span class="line">  <span class="keyword">if</span> ((result.updated &amp;&amp; prev_bitrate_ != result.target_bitrate) ||</span><br><span class="line">      detector_state != prev_state_) &#123;</span><br><span class="line">    DataRate bitrate = result.updated ? result.target_bitrate : prev_bitrate_;</span><br><span class="line">     <span class="comment">// 记录目标比特率的日志</span></span><br><span class="line">    <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;target_bitrate_bps&quot;</span>, at_time.<span class="built_in">ms</span>(), bitrate.<span class="built_in">bps</span>());</span><br><span class="line">    <span class="comment">// 记录BWE（带宽估算）更新事件</span></span><br><span class="line">    <span class="keyword">if</span> (event_log_) &#123;</span><br><span class="line">      event_log_-&gt;<span class="built_in">Log</span>(std::<span class="built_in">make_unique</span>&lt;RtcEventBweUpdateDelayBased&gt;(</span><br><span class="line">          bitrate.<span class="built_in">bps</span>(), detector_state));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新之前的比特率和状态</span></span><br><span class="line">    prev_bitrate_ = bitrate;</span><br><span class="line">    prev_state_ = detector_state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录之前的预估码率和state</span></span><br><span class="line">  result.delay_detector_state = detector_state;</span><br><span class="line">  <span class="comment">// 返回一个包含更新后的带宽估计和延迟检测器状态的结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新码率调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelayBasedBwe::UpdateEstimate</span><span class="params">(Timestamp at_time, <span class="comment">// 当前时间戳</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   absl::optional&lt;DataRate&gt; acked_bitrate, <span class="comment">// 已确认的比特率</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   DataRate* target_rate)</span> </span>&#123; <span class="comment">// 目标比特率</span></span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="function"><span class="type">const</span> RateControlInput <span class="title">input</span><span class="params">(active_delay_detector_-&gt;State(), acked_bitrate)</span></span>;</span><br><span class="line">  <span class="comment">// 更新目标比特率，AIMD的外部接口函数，实现码率的调整</span></span><br><span class="line">  *target_rate = rate_control_.<span class="built_in">Update</span>(input, at_time);</span><br><span class="line">  <span class="keyword">return</span> rate_control_.<span class="built_in">ValidEstimate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在比特率未初始化时，根据估计的吞吐量来设置当前比特率，并在必要时改变比特率</span></span><br><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::Update</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始带宽在RemoteBitrateEstimatorAbsSendTime中使用Cluster、Probe等对象来探测，Probe是一个超过200字节的包，</span></span><br><span class="line">  <span class="comment">// 包簇Cluster是5ms范围内Probe的集合，使用Cluster的集合来预估初始带宽(调用AimdRateControl::SetEstimate设置)，</span></span><br><span class="line">  <span class="comment">// 这里是为了保证如果5秒之后还没有通过包簇探测到初始带宽的情况下，使用输入的码率来设置初始带宽。</span></span><br><span class="line">  <span class="keyword">if</span> (!bitrate_is_initialized_) &#123;<span class="comment">// 如果码率未初始化</span></span><br><span class="line">    <span class="comment">// 初始化时间为5秒</span></span><br><span class="line">    <span class="type">const</span> TimeDelta kInitializationTime = TimeDelta::<span class="built_in">Seconds</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 检查比特率窗口是否小于等于初始化时间</span></span><br><span class="line">    <span class="built_in">RTC_DCHECK_LE</span>(kBitrateWindow, kInitializationTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个第一个数据</span></span><br><span class="line">    <span class="keyword">if</span> (time_first_throughput_estimate_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">      <span class="comment">// 有输入码率</span></span><br><span class="line">      <span class="keyword">if</span> (input.estimated_throughput)</span><br><span class="line">        <span class="comment">// 设置第一次吞吐量估计的时间为当前时间（第一个发送码率到达）</span></span><br><span class="line">        time_first_throughput_estimate_ = at_time;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (at_time - time_first_throughput_estimate_ &gt;</span><br><span class="line">                   kInitializationTime &amp;&amp;</span><br><span class="line">               input.estimated_throughput) &#123;</span><br><span class="line">      <span class="comment">// 当前时间减去第一次吞吐量估计的时间过去了5秒还初始化过带宽，并且存在估计的吞吐量</span></span><br><span class="line">      <span class="comment">// 使用5秒后的输入码率来初始化带宽</span></span><br><span class="line">      current_bitrate_ = *input.estimated_throughput;</span><br><span class="line">      bitrate_is_initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据状态机调整比特率</span></span><br><span class="line">  <span class="built_in">ChangeBitrate</span>(input, at_time);</span><br><span class="line">  <span class="keyword">return</span> current_bitrate_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AimdRateControl::ChangeBitrate</code>根据当前吞吐量和bw_state进行AIMD，是码率控制的核心实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AimdRateControl::ChangeBitrate</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;DataRate&gt; new_bitrate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取估算的吞吐量，并不一定是当前实际的吞吐量，可能由于各种情况是上一个预测码率，或者是探测码率</span></span><br><span class="line">  DataRate estimated_throughput =</span><br><span class="line">      input.estimated_throughput.<span class="built_in">value_or</span>(latest_estimated_throughput_);</span><br><span class="line">  <span class="comment">// 如果有新的估算吞吐量，更新latest_estimated_throughput_</span></span><br><span class="line">  <span class="keyword">if</span> (input.estimated_throughput)</span><br><span class="line">    latest_estimated_throughput_ = *input.estimated_throughput;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果比特率尚未初始化并且不是带宽超使用状态，则直接返回</span></span><br><span class="line">  <span class="comment">// bitrate_is_initialized_表示的是current_bitrate_是否被初始化</span></span><br><span class="line">  <span class="comment">// current_bitrate_被初始化的场景有两个：</span></span><br><span class="line">  <span class="comment">// 1.初始化时，外部调用SetStartBitrate()初始化current_bitrate_</span></span><br><span class="line">  <span class="comment">// 2.第一探测到overusing，到达两路最大容量，用这个值去初始化aimud的码率</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个判断表示的是current_bitrate_还未被设置，所以不做normal和increase，直接返回</span></span><br><span class="line">  <span class="comment">// 或者检测到kBwOverusing发现链路最大容量 ，要对对current_bitrate_进行初始化,并降低码率</span></span><br><span class="line">  <span class="keyword">if</span> (!bitrate_is_initialized_ &amp;&amp;</span><br><span class="line">      input.bw_state != BandwidthUsage::kBwOverusing)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断当前状态机状态</span></span><br><span class="line">  <span class="built_in">ChangeState</span>(input, at_time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (rate_control_state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcHold:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// kRcIncrease 状态</span></span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcIncrease: &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 估算吞吐量超过链路上限（历史吞吐量的指数平滑），预估的链路容积已经不准确，需要重置容量统计</span></span><br><span class="line">      <span class="comment">// 链路容积就是过载状态下的输入码率的平滑均值(历史值 * 95% + 采样值 * 5%)</span></span><br><span class="line">      <span class="keyword">if</span> (estimated_throughput &gt; link_capacity_.<span class="built_in">UpperBound</span>())</span><br><span class="line">        link_capacity_.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 限制新的比特率增加，以避免无限制的比特率增加</span></span><br><span class="line">      <span class="comment">// 允许在非常低的速率下有更多的滞后性，免编码器输出的码率波动导致的频繁阻塞</span></span><br><span class="line">      DataRate increase_limit =</span><br><span class="line">          <span class="number">1.5</span> * estimated_throughput + DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在ALR（Application-Limited Region）状态下，根据no_bitrate_increase_in_alr_决定是否继续进行码率增长</span></span><br><span class="line">      <span class="comment">// ALR下不要增加延迟基于的估算值，alr状态下持续码率增长，一旦出现码率暴增发送码率就会爆发式增大</span></span><br><span class="line">      <span class="comment">// 因为估算器将无法获得必要的传输反馈来检测新估算是否正确</span></span><br><span class="line">      <span class="keyword">if</span> (send_side_ &amp;&amp; in_alr_ &amp;&amp; no_bitrate_increase_in_alr_) &#123;</span><br><span class="line">        <span class="comment">// 如果先前的增加超过了限制（例如由于探测），则不允许进一步更改</span></span><br><span class="line">        increase_limit = current_bitrate_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前比特率小于增加限制，则进行增加</span></span><br><span class="line">      <span class="comment">// 当前码率是否接近链路容量进行加性或乘性增加</span></span><br><span class="line">      <span class="keyword">if</span> (current_bitrate_ &lt; increase_limit) &#123;</span><br><span class="line">        DataRate increased_bitrate = DataRate::<span class="built_in">MinusInfinity</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链路容量没有在上面被重置说明测量的吞吐量和预估链路容量相差不大</span></span><br><span class="line">        <span class="comment">// 也即计算出链路容量进入加性增加，因为当前瓶颈已知</span></span><br><span class="line">        <span class="keyword">if</span> (link_capacity_.<span class="built_in">has_estimate</span>()) &#123;</span><br><span class="line">          <span class="comment">// 加性增长，按照目前码率每秒增加1个包产生的带宽</span></span><br><span class="line">          DataRate additive_increase =</span><br><span class="line">              <span class="built_in">AdditiveRateIncrease</span>(at_time, time_last_bitrate_change_);</span><br><span class="line">          increased_bitrate = current_bitrate_ + additive_increase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// link_capacity_被重置了，预估的链路不准确</span></span><br><span class="line">          <span class="comment">// 乘性增加，8%的增量</span></span><br><span class="line">          DataRate multiplicative_increase = <span class="built_in">MultiplicativeRateIncrease</span>(</span><br><span class="line">              at_time, time_last_bitrate_change_, current_bitrate_);</span><br><span class="line">          increased_bitrate = current_bitrate_ + multiplicative_increase;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 限制新的比特率，不能超过吞吐量阈值</span></span><br><span class="line">        new_bitrate = std::<span class="built_in">min</span>(increased_bitrate, increase_limit);</span><br><span class="line">      &#125;</span><br><span class="line">      time_last_bitrate_change_ = at_time;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// kRcDecrease 状态</span></span><br><span class="line">    <span class="keyword">case</span> RateControlState::kRcDecrease: &#123;</span><br><span class="line">      DataRate decreased_bitrate = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">      <span class="comment">// 乘性减小</span></span><br><span class="line">      <span class="comment">// 输入码率的85% 作为新码率</span></span><br><span class="line">      decreased_bitrate = estimated_throughput * beta_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果减小的比特率大于5 Kbps，并且启用了额外的回退项</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &gt; DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">5</span>) &amp;&amp;</span><br><span class="line">          subtract_additional_backoff_term_) &#123;</span><br><span class="line">        decreased_bitrate -= DataRate::<span class="built_in">KilobitsPerSec</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 输入码率的85%仍然大于当前预估码率</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &gt; current_bitrate_) &#123;</span><br><span class="line">        <span class="comment">//  链路容量没有被重置，链路容量 * 0.85 作为新码率</span></span><br><span class="line">        <span class="keyword">if</span> (link_capacity_.<span class="built_in">has_estimate</span>()) &#123;</span><br><span class="line">          decreased_bitrate = beta_ * link_capacity_.<span class="built_in">estimate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 避免在过度使用时增加速率</span></span><br><span class="line">      <span class="keyword">if</span> (decreased_bitrate &lt; current_bitrate_) &#123;</span><br><span class="line">        new_bitrate = decreased_bitrate;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果比特率已初始化并且估算吞吐量小于当前比特率</span></span><br><span class="line">      <span class="keyword">if</span> (bitrate_is_initialized_ &amp;&amp; estimated_throughput &lt; current_bitrate_) &#123;</span><br><span class="line">        <span class="comment">// 有可能存在过度下降码率的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!new_bitrate.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">          last_decrease_ = DataRate::<span class="built_in">Zero</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 保存最后一次降低的码率</span></span><br><span class="line">          last_decrease_ = current_bitrate_ - *new_bitrate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果估算吞吐量远离估算的链路容量，则清除估算</span></span><br><span class="line">      <span class="comment">// 吞吐量比链路估计下限小太多，波动很大，link_capacity要reset</span></span><br><span class="line">      <span class="comment">// 因为link_capacity内部是一个使用estimated_throughput的指数平滑，</span></span><br><span class="line">      <span class="comment">// 差太多的时候继续做指数平滑被认为没有意义</span></span><br><span class="line">      <span class="keyword">if</span> (estimated_throughput &lt; link_capacity_.<span class="built_in">LowerBound</span>()) &#123;</span><br><span class="line">        link_capacity_.<span class="built_in">Reset</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当码率第一次下下降后认为已经探测到容量上限了，直接设置initialized_的状态</span></span><br><span class="line">      <span class="comment">// 标记比特率已初始化，更新链路容量的过载检测</span></span><br><span class="line">      bitrate_is_initialized_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 使用estimated_throughput做指数平滑</span></span><br><span class="line">      <span class="comment">// 实际使用LinkCapacityEstimator::Update函数</span></span><br><span class="line">      link_capacity_.<span class="built_in">OnOveruseDetected</span>(estimated_throughput);</span><br><span class="line">      rate_control_state_ = RateControlState::kRcHold;</span><br><span class="line">      time_last_bitrate_change_ = at_time;</span><br><span class="line">      time_last_bitrate_decrease_ = at_time;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_DCHECK_NOTREACHED</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 限制当前比特率并更新，避免发送端码率增长过快</span></span><br><span class="line">  current_bitrate_ = <span class="built_in">ClampBitrate</span>(new_bitrate.<span class="built_in">value_or</span>(current_bitrate_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AimdRateControl::ChangeState</code>由过载检测器发出的状态信息<code>kBwNormal/kBwUnderusing/kBwOverusing</code>改变状态机的状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AimdRateControl::ChangeState</span><span class="params">(<span class="type">const</span> RateControlInput&amp; input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (input.bw_state) &#123;</span><br><span class="line">    <span class="comment">// 改变状态，if多一层判断</span></span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwNormal:</span><br><span class="line">      <span class="keyword">if</span> (rate_control_state_ == RateControlState::kRcHold) &#123;</span><br><span class="line">        time_last_bitrate_change_ = at_time;</span><br><span class="line">        rate_control_state_ = RateControlState::kRcIncrease;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// normal情况，当前状态由decrease提升到hold未实现</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwOverusing:</span><br><span class="line">      <span class="keyword">if</span> (rate_control_state_ != RateControlState::kRcDecrease) &#123;</span><br><span class="line">        rate_control_state_ = RateControlState::kRcDecrease;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BandwidthUsage::kBwUnderusing:</span><br><span class="line">      <span class="comment">// 网络低负载，拥塞队列在变小，拥塞情况在改善，处于 underuse 状态</span></span><br><span class="line">      <span class="comment">// 表示正在排空队列，下一个状态应该hold，保证buffer能够排空，</span></span><br><span class="line">      <span class="comment">// 确保测得最大带宽和最小延迟，直到出现normal状态</span></span><br><span class="line">      rate_control_state_ = RateControlState::kRcHold;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_DCHECK_NOTREACHED</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加性增加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::AdditiveRateIncrease</span><span class="params">(Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Timestamp last_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 距离上次码率改变到现在的时间间隔</span></span><br><span class="line">  <span class="type">double</span> time_period_seconds = (at_time - last_time).<span class="built_in">seconds</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">  <span class="comment">// 加性增大的码率大小 = 距离上次码率改变到现在的时间间隔(s) * 每秒应该增加的码率大小</span></span><br><span class="line">  <span class="type">double</span> data_rate_increase_bps =</span><br><span class="line">      <span class="built_in">GetNearMaxIncreaseRateBpsPerSecond</span>() * time_period_seconds;</span><br><span class="line">  <span class="keyword">return</span> DataRate::<span class="built_in">BitsPerSec</span>(data_rate_increase_bps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在码率接近网络链路容量时，进行加性增大</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AimdRateControl::GetNearMaxIncreaseRateBpsPerSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查当前比特率是否为零</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!current_bitrate_.<span class="built_in">IsZero</span>());</span><br><span class="line">  <span class="comment">// 假设发送30fps，计算每帧的大小</span></span><br><span class="line">  <span class="type">const</span> TimeDelta kFrameInterval = TimeDelta::<span class="built_in">Seconds</span>(<span class="number">1</span>) / <span class="number">30</span>;</span><br><span class="line">  DataSize frame_size = current_bitrate_ * kFrameInterval;  <span class="comment">// 计算帧大小</span></span><br><span class="line">  <span class="comment">// 假设包大小为1200字节</span></span><br><span class="line">  <span class="type">const</span> DataSize kPacketSize = DataSize::<span class="built_in">Bytes</span>(<span class="number">1200</span>); </span><br><span class="line">  <span class="comment">// 计算每帧的包数，小于1200字节的也认为每帧一个包</span></span><br><span class="line">  <span class="type">double</span> packets_per_frame = std::<span class="built_in">ceil</span>(frame_size / kPacketSize); </span><br><span class="line">  <span class="comment">// 计算平均包大小</span></span><br><span class="line">  DataSize avg_packet_size = frame_size / packets_per_frame;  </span><br><span class="line">  <span class="comment">// 发送端BWE延迟100ms，乘2表示rtt</span></span><br><span class="line">  TimeDelta response_time = rtt_ + TimeDelta::<span class="built_in">Millis</span>(<span class="number">100</span>);</span><br><span class="line">  response_time = response_time * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 加性增大的原则是：每一个 response_time 增加一个包的大小</span></span><br><span class="line">  <span class="comment">// avg_packet_size / response_time 得到的是一秒的字节数</span></span><br><span class="line">  <span class="comment">// .bps&lt;double&gt;(); 转化为比特数</span></span><br><span class="line">  <span class="comment">// 也就是 增加速率 = 包大小 / 响应时间</span></span><br><span class="line">  <span class="type">double</span> increase_rate_bps_per_second =</span><br><span class="line">      (avg_packet_size / response_time).<span class="built_in">bps</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">  <span class="comment">// 最少要增长4kbps码率，应对低码率场景</span></span><br><span class="line">  <span class="type">double</span> kMinIncreaseRateBpsPerSecond = <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(kMinIncreaseRateBpsPerSecond, increase_rate_bps_per_second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>乘性增加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataRate <span class="title">AimdRateControl::MultiplicativeRateIncrease</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp last_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate current_bitrate)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> alpha = <span class="number">1.08</span>;</span><br><span class="line">  <span class="comment">// 根据上次码率更新所经过的时间作为指数计算alpha，最大为1.08</span></span><br><span class="line">  <span class="keyword">if</span> (last_time.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> time_since_last_update = at_time - last_time;</span><br><span class="line">    alpha = <span class="built_in">pow</span>(alpha, std::<span class="built_in">min</span>(time_since_last_update.<span class="built_in">seconds</span>&lt;<span class="type">double</span>&gt;(), <span class="number">1.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每个RTT增加当前码率的8%</span></span><br><span class="line">  DataRate multiplicative_increase =</span><br><span class="line">      std::<span class="built_in">max</span>(current_bitrate * (alpha - <span class="number">1.0</span>), DataRate::<span class="built_in">BitsPerSec</span>(<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">return</span> multiplicative_increase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LinkCapacityEstimator::Update</span><span class="params">(DataRate capacity_sample, <span class="type">double</span> alpha)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sample_kbps = capacity_sample.<span class="built_in">kbps</span>();</span><br><span class="line">  <span class="keyword">if</span> (!estimate_kbps_.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    estimate_kbps_ = sample_kbps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 一次指数平滑估算最大码率均值</span></span><br><span class="line">    estimate_kbps_ = (<span class="number">1</span> - alpha) * estimate_kbps_.<span class="built_in">value</span>() + alpha * sample_kbps;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Estimate the variance of the link capacity estimate and normalize the</span></span><br><span class="line">  <span class="comment">// variance with the link capacity estimate.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> norm = std::<span class="built_in">max</span>(estimate_kbps_.<span class="built_in">value</span>(), <span class="number">1.0</span>);</span><br><span class="line">  <span class="comment">// 一次指数平滑估算最大码率的方差，这里做归一化值，除以最大码率的均值</span></span><br><span class="line">  <span class="type">double</span> error_kbps = estimate_kbps_.<span class="built_in">value</span>() - sample_kbps;</span><br><span class="line">  deviation_kbps_ =</span><br><span class="line">      (<span class="number">1</span> - alpha) * deviation_kbps_ + alpha * error_kbps * error_kbps / norm;</span><br><span class="line">  <span class="comment">// 0.4 ~= 14 kbit/s at 500 kbit/s</span></span><br><span class="line">  <span class="comment">// 2.5f ~= 35 kbit/s at 500 kbit/s</span></span><br><span class="line">  deviation_kbps_ = rtc::<span class="built_in">SafeClamp</span>(deviation_kbps_, <span class="number">0.4f</span>, <span class="number">2.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AimdRateControl期望在前5秒通过外部的5ms包组集来估算初始码率，之后根据当前链路拥塞状态、当前码率控制状态，来判断下一刻的码率控制状态，如果下一刻码率控制状态为增加，则根据当前是否已经探测到链路的容积来决定是“加性”缓慢增速，还是“乘性”快速增速，如果下一刻码率控制状态为减少，则“乘性”降低码率，否则保持码率不变。</p>
<h2 id="更新基于延时的码率"><a href="#更新基于延时的码率" class="headerlink" title="更新基于延时的码率"></a>更新基于延时的码率</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateDelayBasedEstimate</span><span class="params">(Timestamp at_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                           DataRate bitrate)</span> </span>&#123;</span><br><span class="line">  link_capacity_.<span class="built_in">UpdateDelayBasedEstimate</span>(at_time, bitrate);</span><br><span class="line">  <span class="comment">// delay based估计的码率作为发送端调整的上限</span></span><br><span class="line">  delay_based_limit_ = bitrate.<span class="built_in">IsZero</span>() ? DataRate::<span class="built_in">PlusInfinity</span>() : bitrate;</span><br><span class="line">  <span class="built_in">ApplyTargetLimits</span>(at_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接收端带宽估计"><a href="#接收端带宽估计" class="headerlink" title="接收端带宽估计"></a>接收端带宽估计</h1><h3 id="接收数据包处理"><a href="#接收数据包处理" class="headerlink" title="接收数据包处理"></a>接收数据包处理</h3><p><code>RemoteBitrateEstimatorAbsSendTime::IncomingPacket</code>处理接收到的 RTP 包，提取绝对发送时间信息，并进行带宽估计和拥塞检测。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call::NotifyBweOfReceivedPacket</span></span><br><span class="line"><span class="comment">// ReceiveSideCongestionController::OnReceivedPacket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoteBitrateEstimatorAbsSendTime::IncomingPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RtpPacketReceived&amp; rtp_packet)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> send_time_24bits; <span class="comment">// 发送时间戳abs-send-time</span></span><br><span class="line">  <span class="comment">// 尝试获取 RTP 包的绝对发送时间扩展，如果不存在则记录警告并返回</span></span><br><span class="line">  <span class="keyword">if</span> (!rtp_packet.<span class="built_in">GetExtension</span>&lt;AbsoluteSendTime&gt;(&amp;send_time_24bits)) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;RemoteBitrateEstimatorAbsSendTimeImpl: Incoming packet &quot;</span></span><br><span class="line">           <span class="string">&quot;is missing absolute send time extension!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取包到达时间和负载大小（包括填充数据）</span></span><br><span class="line">  Timestamp arrival_time = rtp_packet.<span class="built_in">arrival_time</span>();</span><br><span class="line">  DataSize payload_size =</span><br><span class="line">      DataSize::<span class="built_in">Bytes</span>(rtp_packet.<span class="built_in">payload_size</span>() + rtp_packet.<span class="built_in">padding_size</span>());</span><br><span class="line">  <span class="comment">// 记录 UMA 数据，只记录一次</span></span><br><span class="line">  <span class="keyword">if</span> (!uma_recorded_) &#123;</span><br><span class="line">    <span class="built_in">RTC_HISTOGRAM_ENUMERATION</span>(kBweTypeHistogram, BweNames::kReceiverAbsSendTime,</span><br><span class="line">                              BweNames::kBweNamesMax);</span><br><span class="line">    uma_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// abs-send-time转时间戳，左移8位以使用完整的 32 位，以便正确处理时间戳回绕</span></span><br><span class="line">  <span class="type">uint32_t</span> timestamp = send_time_24bits &lt;&lt; kAbsSendTimeInterArrivalUpshift;</span><br><span class="line">  <span class="comment">// 转换成ms</span></span><br><span class="line">  Timestamp send_time =</span><br><span class="line">      Timestamp::<span class="built_in">Millis</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(timestamp) * kTimestampToMs);</span><br><span class="line">  <span class="comment">// 当前时间</span></span><br><span class="line">  Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查接收到的比特率估计是否有效，是否需要重置</span></span><br><span class="line">  absl::optional&lt;DataRate&gt; incoming_bitrate =</span><br><span class="line">      incoming_bitrate_.<span class="built_in">Rate</span>(arrival_time);</span><br><span class="line">  <span class="keyword">if</span> (incoming_bitrate) &#123;</span><br><span class="line">    incoming_bitrate_initialized_ = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (incoming_bitrate_initialized_) &#123;</span><br><span class="line">    <span class="comment">// 如果先前有有效的比特率，但现在没有足够的数据点，则重置比特率估计器</span></span><br><span class="line">    incoming_bitrate_.<span class="built_in">Reset</span>();</span><br><span class="line">    incoming_bitrate_initialized_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加当前包到输入码率统计器</span></span><br><span class="line">  incoming_bitrate_.<span class="built_in">Update</span>(payload_size, arrival_time);</span><br><span class="line">  <span class="comment">// 记录收到的第一个包的时间</span></span><br><span class="line">  <span class="keyword">if</span> (first_packet_time_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">    first_packet_time_ = now;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ts_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int64_t</span> t_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> size_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> update_estimate = <span class="literal">false</span>;</span><br><span class="line">  DataRate target_bitrate = DataRate::<span class="built_in">Zero</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TimeoutStreams</span>(now);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(inter_arrival_);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(estimator_);</span><br><span class="line">  ssrcs_.<span class="built_in">insert_or_assign</span>(rtp_packet.<span class="built_in">Ssrc</span>(), now);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For now only try to detect probes while we don&#x27;t have a valid estimate.</span></span><br><span class="line">  <span class="comment">// We currently assume that only packets larger than 200 bytes are paced by</span></span><br><span class="line">  <span class="comment">// the sender.</span></span><br><span class="line">  <span class="comment">// 探测包</span></span><br><span class="line">  <span class="comment">// 这个逻辑用来初始化码率，因为最初的几秒可能其他模块的数据量不够，还没法正常工作。</span></span><br><span class="line">  <span class="comment">// 使用超过200字节的包作为1个探测包(Probe)，保留最近的15个探测包，</span></span><br><span class="line">  <span class="comment">// Probe的集合称为包簇(Cluster)，每个包簇里的包里包簇的平均时间间隔不超过2.5ms，也就是包簇总大小为5ms.</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> DataSize kMinProbePacketSize = DataSize::<span class="built_in">Bytes</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">if</span> (payload_size &gt; kMinProbePacketSize &amp;&amp; <span class="comment">// 探测包大小必须至少200字节</span></span><br><span class="line">      (!remote_rate_.<span class="built_in">ValidEstimate</span>() || <span class="comment">// 如果还没有预估出码率</span></span><br><span class="line">       now - first_packet_time_ &lt; kInitialProbingInterval)) &#123;  <span class="comment">// 或者是最初的2秒</span></span><br><span class="line">    <span class="comment">// TODO(holmer): Use a map instead to get correct order?</span></span><br><span class="line">    <span class="keyword">if</span> (total_probes_received_ &lt; kMaxProbePackets) &#123;</span><br><span class="line">      TimeDelta send_delta = TimeDelta::<span class="built_in">Millis</span>(<span class="number">-1</span>);</span><br><span class="line">      TimeDelta recv_delta = TimeDelta::<span class="built_in">Millis</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!probes_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        send_delta = send_time - probes_.<span class="built_in">back</span>().send_time;</span><br><span class="line">        recv_delta = arrival_time - probes_.<span class="built_in">back</span>().recv_time;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Probe packet received: send time=&quot;</span> &lt;&lt; send_time.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, recv time=&quot;</span> &lt;&lt; arrival_time.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, send delta=&quot;</span> &lt;&lt; send_delta.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, recv delta=&quot;</span> &lt;&lt; recv_delta.<span class="built_in">ms</span>() &lt;&lt; <span class="string">&quot; ms.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存探测包</span></span><br><span class="line">    probes_.<span class="built_in">emplace_back</span>(send_time, arrival_time, payload_size);</span><br><span class="line">    <span class="comment">// 累加探测包计数器</span></span><br><span class="line">    ++total_probes_received_;</span><br><span class="line">    <span class="comment">// 0x00. 处理探测包，检查是否可以计算出初始码率，如果可以的话，内部直接更新到AimdRateControl</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ProcessClusters</span>(now) == ProbeResult::kBitrateUpdated)</span><br><span class="line">      update_estimate = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0x01. 到达时间滤波器，输出5ms包组(跟探测包簇不是一个东西)之间的到达时间差、发送时间差、数据包大小</span></span><br><span class="line">  <span class="comment">// 和发送端基于延迟的带宽估计代码大多相同</span></span><br><span class="line">  <span class="keyword">if</span> (inter_arrival_-&gt;<span class="built_in">ComputeDeltas</span>(timestamp, arrival_time.<span class="built_in">ms</span>(), now.<span class="built_in">ms</span>(),</span><br><span class="line">                                    payload_size.<span class="built_in">bytes</span>(), &amp;ts_delta, &amp;t_delta,</span><br><span class="line">                                    &amp;size_delta)) &#123;</span><br><span class="line">    <span class="type">double</span> ts_delta_ms = (<span class="number">1000.0</span> * ts_delta) / (<span class="number">1</span> &lt;&lt; kInterArrivalShift);</span><br><span class="line">    <span class="comment">// 0x02. 卡尔曼滤波器处理到达时间滤波器的输出，得到到达间隔增量，也就是延迟变化量，或者称拥塞值</span></span><br><span class="line">    estimator_-&gt;<span class="built_in">Update</span>(t_delta, ts_delta_ms, size_delta, detector_.<span class="built_in">State</span>(),</span><br><span class="line">                       arrival_time.<span class="built_in">ms</span>());</span><br><span class="line">    <span class="comment">// 0x03. 过载检测器根据到达间隔增量检测链路过载状态</span></span><br><span class="line">    detector_.<span class="built_in">Detect</span>(estimator_-&gt;<span class="built_in">offset</span>(), ts_delta_ms,</span><br><span class="line">                     estimator_-&gt;<span class="built_in">num_of_deltas</span>(), arrival_time.<span class="built_in">ms</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!update_estimate) &#123;</span><br><span class="line">    <span class="comment">// 检查是否需要周期性更新或因为过度使用而更新</span></span><br><span class="line">    <span class="comment">// 周期性的判断：如果从来没有更新过预估码率，或者距离上次更新过去了一定时间(GetFeedbackInterval),</span></span><br><span class="line">	  <span class="comment">// 该时间为RTCP的发送间隔，大致在5%的预估带宽下，1个80字节的RTCP包的发送间隔，</span></span><br><span class="line">	  <span class="comment">// 并限制在(200ms, 1000ms)范围内.</span></span><br><span class="line">    <span class="keyword">if</span> (last_update_.<span class="built_in">IsInfinite</span>() ||</span><br><span class="line">        now.<span class="built_in">ms</span>() - last_update_.<span class="built_in">ms</span>() &gt;</span><br><span class="line">            remote_rate_.<span class="built_in">GetFeedbackInterval</span>().<span class="built_in">ms</span>()) &#123;</span><br><span class="line">      <span class="comment">// 强制更新一次估算值</span></span><br><span class="line">      update_estimate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (detector_.<span class="built_in">State</span>() == BandwidthUsage::kBwOverusing) &#123;</span><br><span class="line">        <span class="comment">// 时间不到但是已经在过载状态，则需要检查下是否需要提前更新，快速反应。</span></span><br><span class="line">        <span class="comment">// TimeToReduceFurther函数判断有以下两个条件之一则成立：</span></span><br><span class="line">        <span class="comment">//   1.距离上次更新过去了1个rtt的时间;</span></span><br><span class="line">        <span class="comment">//   2.输入码率小于50%的当前预估带宽</span></span><br><span class="line">      absl::optional&lt;DataRate&gt; incoming_rate =</span><br><span class="line">          incoming_bitrate_.<span class="built_in">Rate</span>(arrival_time);</span><br><span class="line">      <span class="keyword">if</span> (incoming_rate.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">          remote_rate_.<span class="built_in">TimeToReduceFurther</span>(now, *incoming_rate)) &#123;</span><br><span class="line">        <span class="comment">// 强制更新一次估算值</span></span><br><span class="line">        update_estimate = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (update_estimate) &#123;</span><br><span class="line">    <span class="comment">// 第一次过度使用应立即触发新估计</span></span><br><span class="line">    <span class="comment">// 输入为当前的输入码率、链路拥塞状态.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> RateControlInput <span class="title">input</span><span class="params">(detector_.State(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                 incoming_bitrate_.Rate(arrival_time))</span></span>;</span><br><span class="line">    <span class="comment">// 估算并返回当前的带宽</span></span><br><span class="line">    target_bitrate = remote_rate_.<span class="built_in">Update</span>(input, now);</span><br><span class="line">    <span class="comment">// 是否估算成功</span></span><br><span class="line">    update_estimate = remote_rate_.<span class="built_in">ValidEstimate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果估算成功</span></span><br><span class="line">  <span class="keyword">if</span> (update_estimate) &#123;</span><br><span class="line">    <span class="comment">// 记录更新时间</span></span><br><span class="line">    last_update_ = now;</span><br><span class="line">    <span class="comment">// 0x04. 通知订阅了这个预估码率的模块</span></span><br><span class="line">    observer_-&gt;<span class="built_in">OnReceiveBitrateChanged</span>(<span class="built_in">Keys</span>(ssrcs_),</span><br><span class="line">                                       target_bitrate.<span class="built_in">bps</span>&lt;<span class="type">uint32_t</span>&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="到达时间滤波器-1"><a href="#到达时间滤波器-1" class="headerlink" title="到达时间滤波器"></a>到达时间滤波器</h3><p>// 0x01. 到达时间滤波器</p>
<p><code>InterArrival::ComputeDeltas</code>分包组计算到达时间差、发送时间差、包组大小差，代码部分和发送端基于延迟的带宽估计类似。</p>
<h3 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h3><p>// 0x02. 卡尔曼滤波</p>
<p>卡尔曼滤波的状态预测方程包括状态预测和误差协方差预测：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
x_k=Ax_{k-1}+B\mu_{k-1} && \text{(i)}\\
P_k= AP_{k-1}A^T+Q && \text{(ii)}
\end{aligned}
\end{equation}</script><p>其中 <script type="math/tex">A</script> 为状态转移矩阵，<script type="math/tex">\mu</script> 为控制输入，<script type="math/tex">B</script> 为控制矩阵，<script type="math/tex">Q</script> 为<strong>过程噪声</strong>协方差矩阵。在接收端带宽估计的实现中，假设状态是线性变化的，即 <script type="math/tex">A</script> 为单位矩阵，且没有控制输入<script type="math/tex">(B\mu_{k-1})</script>。此时的状态预测过程方程为 <script type="math/tex">x_k=x_{k-1} + n_m</script>，可以理解为当前时刻的状态预测等于上一个时刻的状态估计，误差协方差预测方程简化为：</p>
<script type="math/tex; mode=display">
\begin{equation}
  P_k= P_{k-1}+Q 
\end{equation}</script><p>其中 <script type="math/tex">P</script> 为<strong>状态噪声</strong>协方差矩阵，对应代码中 <code>E_</code>，<script type="math/tex">Q</script> 对应代码中 <code>process_noise_</code>。定义状态矩阵  <script type="math/tex">x = \begin{bmatrix} slope\_ \\ offset\_ \end{bmatrix}</script> 为要估计的参数，其中 <script type="math/tex">slope\_=\frac{1}{C}</script>，<script type="math/tex">offset\_</script> 为模块输出，是两包组的延迟差，代表网络中数据包发生堆积还是排空。状态噪声协方差矩阵更新为：</p>
<script type="math/tex; mode=display">
\begin{equation}
  E\_ = \begin{bmatrix}
E_{00} & E_{01} \\
E_{10} & E_{11}
\end{bmatrix} + \begin{bmatrix}
process\_noise\_[0] & 0 \\
0 & process\_noise\_[1] 
\end{bmatrix}
\end{equation}</script><p>定义观测矩阵 <script type="math/tex">H</script>，对应代码实现中的 <script type="math/tex">h=\begin{bmatrix} fs\_delta & 1.0 \end{bmatrix}</script>。观测量表示两包组传输延迟差，定义为：</p>
<script type="math/tex; mode=display">
\begin{equation}

\begin{aligned}
  Z_k&=hx_k+V_k  \\
  &= \begin{bmatrix} fs\_delta & 1.0 \end{bmatrix}  \begin{bmatrix} slope\_ \\ offset\_ \end{bmatrix} + V_k

\end{aligned}

\end{equation}</script><p>其中，<script type="math/tex">V_k</script> 为观测噪声，<script type="math/tex">R</script> 为<strong>观测噪声</strong>方差，是残差 <code>residual</code><script type="math/tex">=t\_ts\_delta-hx_k</script>的方差，代码中用 <code>var_noise_</code> 表示。</p>
<p>卡尔曼增益调整为：</p>
<script type="math/tex; mode=display">
\begin{equation}
  K_k=P_kH^T(HP_kH^T+R)^{-1}
\end{equation}</script><p>上述式子在代码实现中的表示为:</p>
<script type="math/tex; mode=display">
\begin{equation}
  Eh = E\_h^T\\
  k= \frac{Eh}{hEh+var\_noise\_}
\end{equation}</script><p>上式中，<code>Eh</code> 的维度为 <code>2x2 * 2x1 -&gt; 2x1</code>，分母的维度为 <code>1x2 * 2x1 * 1x1 -&gt; 1x1</code> 标量，得到 <code>k</code> 的维度为 <code>2x1</code>，误差协方差矩阵 <script type="math/tex">P</script> 的更新为：</p>
<script type="math/tex; mode=display">
\begin{equation}
  P_k = (I-K_kH)P_{k-1}
\end{equation}</script><p>对应在代码实现中，$IKh = I - kh$，得到 <code>2x2</code> 的矩阵，用于更新 <code>E_</code>。参数的预测值根据残差进行更新:</p>
<script type="math/tex; mode=display">
\begin{equation}
  x_k = x_{k-1} + K_k * residual
\end{equation}</script><p>在论文中简化的系统为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{cases}
   \overline{m}(t_{i+1}) = \overline{m}(t_i) + \omega(t_i) \\
   d_m(t_i) =  \overline{m}(t_i) + n(t_i)
\end{cases}
\end{equation}</script><p>考虑状态噪声和观测噪声，模型表示为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{cases}
  \begin{bmatrix} slope\__k \\ offset\__k \end{bmatrix} = \begin{bmatrix} slope\__{k-1} \\ offset\__{k-1} \end{bmatrix} + \begin{bmatrix} \omega_s \\ \omega_o \end{bmatrix}\\

  d_m(t_i) =  \begin{bmatrix} fs\_delta & 1.0 \end{bmatrix} \begin{bmatrix} slope\__k \\ offset\__k \end{bmatrix} + n_m

\end{cases}
\end{equation}</script><p>其中 <script type="math/tex">\begin{bmatrix} \omega_s \\ \omega_o \end{bmatrix}</script> 对应的是状态噪声，代码中 <code>E_</code> 是其协方差矩阵；<script type="math/tex">n_m</script>是观测噪声，代码中用 <code>var_noise_</code> 表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据发送数据包大小差值和延迟梯度计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OveruseEstimator::Update</span><span class="params">(<span class="type">int64_t</span> t_delta, <span class="comment">// 接收时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">double</span> ts_delta, <span class="comment">// 发送时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> size_delta, <span class="comment">// 数据包大小差值ΔL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              BandwidthUsage current_hypothesis,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 60个发送间隔窗口的最小值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> min_frame_period = <span class="built_in">UpdateMinFramePeriod</span>(ts_delta);</span><br><span class="line">  <span class="comment">// 延迟梯度 d_i</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> t_ts_delta = t_delta - ts_delta;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;dm_ms&quot;</span>, now_ms, t_ts_delta);</span><br><span class="line">  <span class="comment">// 数据包大小差值 ΔL</span></span><br><span class="line">  <span class="type">double</span> fs_delta = size_delta;</span><br><span class="line">  <span class="comment">// 包组统计个数，最大1000个</span></span><br><span class="line">  ++num_of_deltas_;</span><br><span class="line">  <span class="keyword">if</span> (num_of_deltas_ &gt; kDeltaCounterMax) &#123;</span><br><span class="line">    num_of_deltas_ = kDeltaCounterMax;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 状态量 x_k = [slope_</span></span><br><span class="line">  <span class="comment">//              offset_] ，列向量</span></span><br><span class="line">  <span class="comment">// P_k = A * P_&#123;k-1&#125; * A^T + Q</span></span><br><span class="line">  <span class="comment">// 状态噪声协方差 P_k = P_&#123;k-1&#125; + Q</span></span><br><span class="line">  <span class="comment">// P 这里用 E_ 表示，Q 为过程噪声协方差，是固定值，这里用 process_noise_ 表示</span></span><br><span class="line"></span><br><span class="line">  E_[<span class="number">0</span>][<span class="number">0</span>] += process_noise_[<span class="number">0</span>];</span><br><span class="line">  E_[<span class="number">1</span>][<span class="number">1</span>] += process_noise_[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据带宽使用情况调整状态噪声</span></span><br><span class="line">  <span class="keyword">if</span> ((current_hypothesis == BandwidthUsage::kBwOverusing &amp;&amp;</span><br><span class="line">       offset_ &lt; prev_offset_) ||</span><br><span class="line">      (current_hypothesis == BandwidthUsage::kBwUnderusing &amp;&amp;</span><br><span class="line">       offset_ &gt; prev_offset_)) &#123;</span><br><span class="line">    E_[<span class="number">1</span>][<span class="number">1</span>] += <span class="number">10</span> * process_noise_[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 观测矩阵H=&#123;ΔL, 1&#125;，这里用h表示，行向量</span></span><br><span class="line">  <span class="comment">// Eh=P*H^T (矩阵乘法) 2x2 * 2*1 -&gt; 2*1 维度</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> h[<span class="number">2</span>] = &#123;fs_delta, <span class="number">1.0</span>&#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> Eh[<span class="number">2</span>] = &#123;E_[<span class="number">0</span>][<span class="number">0</span>] * h[<span class="number">0</span>] + E_[<span class="number">0</span>][<span class="number">1</span>] * h[<span class="number">1</span>],</span><br><span class="line">                        E_[<span class="number">1</span>][<span class="number">0</span>] * h[<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">1</span>] * h[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;d_ms&quot;</span>, now_ms, slope_ * h[<span class="number">0</span>] - offset_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算残差 z_k - H * x_k  1x1 - 1x2 * 2x1 -&gt; 1x1标量</span></span><br><span class="line">  <span class="comment">// 这里z_k是延迟梯度测量， H * x_k = slope_ * h[0] + offset_ * h[1] (h[1]=1)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> residual = t_ts_delta - slope_ * h[<span class="number">0</span>] - offset_;</span><br><span class="line">  <span class="comment">// 检查是否处于稳定状态</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> in_stable_state =</span><br><span class="line">      (current_hypothesis == BandwidthUsage::kBwNormal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算最大残差 = 3 * sqrt(观测噪声方差)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> max_residual = <span class="number">3.0</span> * <span class="built_in">sqrt</span>(var_noise_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤异常的大残差值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(residual) &lt; max_residual) &#123;</span><br><span class="line">    <span class="built_in">UpdateNoiseEstimate</span>(residual, min_frame_period, in_stable_state);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 该帧太晚到达了，可能是由于某些不满足高斯模型的原因导致，例如周期性的关键帧。</span></span><br><span class="line">    <span class="built_in">UpdateNoiseEstimate</span>(residual &lt; <span class="number">0</span> ? -max_residual : max_residual,</span><br><span class="line">                        min_frame_period, in_stable_state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算卡尔曼增益分母 denom = H * P * H^T + R</span></span><br><span class="line">  <span class="comment">// 观测噪声方差 R 这里用 var_noise_ 表示</span></span><br><span class="line">  <span class="comment">// Eh=P*H，这里 denom = H*Eh + R</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> denom = var_noise_ + h[<span class="number">0</span>] * Eh[<span class="number">0</span>] + h[<span class="number">1</span>] * Eh[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 3. 计算卡尔曼增益 K_k = P * H^T / (H * P * H^T + R)</span></span><br><span class="line">  <span class="comment">// 所以，K_k= Eh/denom = 2x1 维度</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> K[<span class="number">2</span>] = &#123;Eh[<span class="number">0</span>] / denom, Eh[<span class="number">1</span>] / denom&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算 Ikh = I - K * H</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> IKh[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1.0</span> - K[<span class="number">0</span>] * h[<span class="number">0</span>], -K[<span class="number">0</span>] * h[<span class="number">1</span>]&#125;,</span><br><span class="line">                            &#123;-K[<span class="number">1</span>] * h[<span class="number">0</span>], <span class="number">1.0</span> - K[<span class="number">1</span>] * h[<span class="number">1</span>]&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> e00 = E_[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> e01 = E_[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 更新协方差矩阵 P</span></span><br><span class="line">  <span class="comment">// P_k = (I - K * H) * P_&#123;k-1&#125; = Ikh*P_&#123;k-1&#125;</span></span><br><span class="line">  E_[<span class="number">0</span>][<span class="number">0</span>] = e00 * IKh[<span class="number">0</span>][<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">0</span>] * IKh[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  E_[<span class="number">0</span>][<span class="number">1</span>] = e01 * IKh[<span class="number">0</span>][<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">1</span>] * IKh[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  E_[<span class="number">1</span>][<span class="number">0</span>] = e00 * IKh[<span class="number">1</span>][<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">0</span>] * IKh[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  E_[<span class="number">1</span>][<span class="number">1</span>] = e01 * IKh[<span class="number">1</span>][<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">1</span>] * IKh[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保协方差矩阵是半正定的</span></span><br><span class="line">  <span class="type">bool</span> positive_semi_definite =</span><br><span class="line">      E_[<span class="number">0</span>][<span class="number">0</span>] + E_[<span class="number">1</span>][<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      E_[<span class="number">0</span>][<span class="number">0</span>] * E_[<span class="number">1</span>][<span class="number">1</span>] - E_[<span class="number">0</span>][<span class="number">1</span>] * E_[<span class="number">1</span>][<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; E_[<span class="number">0</span>][<span class="number">0</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(positive_semi_definite);</span><br><span class="line">  <span class="keyword">if</span> (!positive_semi_definite) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_ERROR)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;The over-use estimator&#x27;s covariance matrix is no longer &quot;</span></span><br><span class="line">           <span class="string">&quot;semi-definite.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 状态更新方程 x_k = x_&#123;k-1&#125; + K * residual</span></span><br><span class="line">  <span class="comment">// residual = d_i - (1 / C) * ΔL - μ</span></span><br><span class="line">  <span class="comment">// h[2] = &#123;fs_delta, 1.0&#125;;</span></span><br><span class="line">  <span class="comment">// residual = t_ts_delta - slope_ * h[0] - offset_;</span></span><br><span class="line"></span><br><span class="line">  slope_ = slope_ + K[<span class="number">0</span>] * residual; <span class="comment">// 1/C  </span></span><br><span class="line">  prev_offset_ = offset_; <span class="comment">// 用于判断是否拥塞</span></span><br><span class="line">  offset_ = offset_ + K[<span class="number">1</span>] * residual; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;kc&quot;</span>, now_ms, K[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;km&quot;</span>, now_ms, K[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;slope_1/bps&quot;</span>, now_ms, slope_);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;var_noise&quot;</span>, now_ms, var_noise_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>噪声方差的更新需要维护大小为60的窗口内最小的发送间隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">OveruseEstimator::UpdateMinFramePeriod</span><span class="params">(<span class="type">double</span> ts_delta)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化最小帧间隔为当前帧间隔</span></span><br><span class="line">  <span class="type">double</span> min_frame_period = ts_delta;</span><br><span class="line">  <span class="comment">// 如果帧间隔历史记录的大小达到最大长度，移除最早的记录</span></span><br><span class="line">  <span class="keyword">if</span> (ts_delta_hist_.<span class="built_in">size</span>() &gt;= kMinFramePeriodHistoryLength) &#123;</span><br><span class="line">    ts_delta_hist_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历帧间隔历史记录，找到最小的帧间隔</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">double</span> old_ts_delta : ts_delta_hist_) &#123;</span><br><span class="line">    min_frame_period = std::<span class="built_in">min</span>(old_ts_delta, min_frame_period);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将当前帧间隔添加到历史记录中</span></span><br><span class="line">  ts_delta_hist_.<span class="built_in">push_back</span>(ts_delta);</span><br><span class="line">  <span class="keyword">return</span> min_frame_period;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观测噪声方差<code>var_noise_</code>更新根据发送端窗口内最小发送间隔进行更新：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{cases}
   avg\_noise\_ = \beta \cdot avg\_noise\_ + (1-\beta)\cdot residual \\
   var\_noise\_ = \max\left(\beta \cdot var\_noise\_ + (1-\beta)(avg\_noise\_ - residual)^2, 1\right) \\
   \beta = \left(1-\alpha \right)^{\tfrac{30f_{min}}{1000}}
\end{cases}
\end{equation}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 噪声方差自适应化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OveruseEstimator::UpdateNoiseEstimate</span><span class="params">(<span class="type">double</span> residual,<span class="comment">//测量值和预测值之差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">double</span> ts_delta, <span class="comment">//最小发送间隔</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">bool</span> stable_state)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 仅在Normal状态下更新噪声值</span></span><br><span class="line">  <span class="keyword">if</span> (!stable_state) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动阶段更快的滤波以更快适应网络的抖动水平</span></span><br><span class="line">  <span class="comment">// 确定alpha的值</span></span><br><span class="line">  <span class="type">double</span> alpha = <span class="number">0.01</span>; <span class="comment">// [0.1, 0.001]</span></span><br><span class="line">  <span class="comment">// 如果帧间隔数大于 10 * 30，则减小滤波系数 alpha</span></span><br><span class="line">  <span class="keyword">if</span> (num_of_deltas_ &gt; <span class="number">10</span> * <span class="number">30</span>) &#123;</span><br><span class="line">    alpha = <span class="number">0.002</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅在非过度使用状态下更新噪声估计值。`beta` 是 `alpha` 和上次更新以来的时间间隔的函数。</span></span><br><span class="line">  <span class="comment">// 时间差越大，残差的权重越小</span></span><br><span class="line">  <span class="comment">// 计算时间因子 `beta`，`beta` 是 `alpha` 和采样间隔 `ts_delta` 的函数</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> beta = <span class="built_in">pow</span>(<span class="number">1</span> - alpha, ts_delta * <span class="number">30.0</span> / <span class="number">1000.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新观测噪声均值和方差</span></span><br><span class="line">  avg_noise_ = beta * avg_noise_ + (<span class="number">1</span> - beta) * residual;</span><br><span class="line">  var_noise_ = beta * var_noise_ +</span><br><span class="line">               (<span class="number">1</span> - beta) * (avg_noise_ - residual) * (avg_noise_ - residual);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证噪声方差不小于 1</span></span><br><span class="line">  <span class="keyword">if</span> (var_noise_ &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    var_noise_ = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="过载检测器-1"><a href="#过载检测器-1" class="headerlink" title="过载检测器"></a>过载检测器</h3><p>过载检测器根据到达时间滤波器计算的延迟梯度和阈值进行比较判断链路是否过载，过载检测大部分代码和trendline滤波的相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x03. 过载检测器</span></span><br><span class="line"><span class="function">BandwidthUsage <span class="title">OveruseDetector::Detect</span><span class="params">(<span class="type">double</span> offset, <span class="comment">// 链路延迟变化(到达时间间隔增量)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">double</span> ts_delta, <span class="comment">// 发送时间差</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">int</span> num_of_deltas,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_of_deltas &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> BandwidthUsage::kBwNormal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最多使用kMaxNumDeltas=60个采样，网络拥塞=采样数*单个采样的到达时间间隔增量（延迟梯度？）</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> T = std::<span class="built_in">min</span>(num_of_deltas, kMaxNumDeltas) * offset;</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;T&quot;</span>, now_ms, T);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;threshold&quot;</span>, now_ms, threshold_);</span><br><span class="line">  <span class="comment">// 大于阈值，说明拥塞加剧</span></span><br><span class="line">  <span class="keyword">if</span> (T &gt; threshold_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一次过载，过载时间设置为两包组时间差的一半</span></span><br><span class="line">      time_over_using_ = ts_delta / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 增加过载时间</span></span><br><span class="line">      time_over_using_ += ts_delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计过载计数</span></span><br><span class="line">    overuse_counter_++;</span><br><span class="line">    <span class="comment">// 过载的时间超过了阈值，并且累计触发过载的次数大于1</span></span><br><span class="line">    <span class="comment">// 避免短暂高延迟导致误判成过载，所以必须持续的过载才是真实的过载</span></span><br><span class="line">    <span class="keyword">if</span> (time_over_using_ &gt; kOverUsingTimeThreshold &amp;&amp; overuse_counter_ &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 到达时间间隔变大，认为处于过载状态</span></span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= prev_offset_) &#123;</span><br><span class="line">        <span class="comment">// 清空过载的状态</span></span><br><span class="line">        time_over_using_ = <span class="number">0</span>;</span><br><span class="line">        overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置过载状态</span></span><br><span class="line">        hypothesis_ = BandwidthUsage::kBwOverusing;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T &lt; -threshold_) &#123;</span><br><span class="line">    <span class="comment">// 低负载，队列正在排空，处于Underus</span></span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwUnderusing;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal状态</span></span><br><span class="line">    time_over_using_ = <span class="number">-1</span>;</span><br><span class="line">    overuse_counter_ = <span class="number">0</span>;</span><br><span class="line">    hypothesis_ = BandwidthUsage::kBwNormal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存当前的到达间隔增量</span></span><br><span class="line">  prev_offset_ = offset;</span><br><span class="line">  <span class="comment">// 更新阈值</span></span><br><span class="line">  <span class="built_in">UpdateThreshold</span>(T, now_ms);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hypothesis_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自适应阈值-1"><a href="#自适应阈值-1" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><p>根据链路拥塞和国际的阈值偏差更新阈值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x03.2 自适应阈值调整 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OveruseDetector::UpdateThreshold</span><span class="params">(<span class="type">double</span> modified_offset, <span class="type">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次更新阈值，记录时间</span></span><br><span class="line">  <span class="keyword">if</span> (last_update_ms_ == <span class="number">-1</span>)</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修正后的值和阈值差值超过15ms，当作异常不进行处理</span></span><br><span class="line">  <span class="comment">// 避免网络故障（如突然容量降低）时延迟梯度的瞬态急剧增加</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(modified_offset) &gt; threshold_ + kMaxAdaptOffsetMs) &#123;</span><br><span class="line">    last_update_ms_ = now_ms;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择变化率  k_up_(0.0087)，k_down_(0.039)</span></span><br><span class="line">  <span class="comment">// 在拥塞增大时缓慢调整阈值，避免网络抖动;</span></span><br><span class="line">  <span class="comment">// 在拥塞减小时快速调整阈值，使系统更快对网络状态变化作出响应</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> k = <span class="built_in">fabs</span>(modified_offset) &lt; threshold_ ? kDown : kUp;</span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> kMaxTimeDeltaMs = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 阈值的调整量与自上次阈值更新以来的时间间隔成正比，时间越长，调整越多</span></span><br><span class="line">  <span class="comment">// 这里使用的是包组的到达时间差，过载检测累计时间使用的是包组发送时间差</span></span><br><span class="line">  <span class="comment">// 限制在最大时间差kMaxTimeDeltaMs=100ms内</span></span><br><span class="line">  <span class="type">int64_t</span> time_delta_ms = std::<span class="built_in">min</span>(now_ms - last_update_ms_, kMaxTimeDeltaMs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据拥塞值的变化（fabs(modified_trend) - threshold_)）、时间差以及选择的变化率，更新阈值</span></span><br><span class="line">  <span class="comment">// 拥塞值不变，阈值保持不变；拥塞值增大，且时间间隔较长，阈值会相应增加；</span></span><br><span class="line">  <span class="comment">// 拥塞值减小，阈值会相应减小。</span></span><br><span class="line">  <span class="comment">// 这样能够更灵敏地感知和适应网络拥塞状况</span></span><br><span class="line">  threshold_ += k * (<span class="built_in">fabs</span>(modified_offset) - threshold_) * time_delta_ms;</span><br><span class="line">  <span class="comment">// 防止阈值过大或过小导致不稳定的行为</span></span><br><span class="line"></span><br><span class="line">  threshold_ = rtc::<span class="built_in">SafeClamp</span>(threshold_, <span class="number">6.f</span>, <span class="number">600.f</span>);</span><br><span class="line">  last_update_ms_ = now_ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="码率估计"><a href="#码率估计" class="headerlink" title="码率估计"></a>码率估计</h3><p>接收端AIMD码率调整部分代码和发送端基于延迟的带宽估计部分相似。</p>
<h1 id="阈值限制并更新码率"><a href="#阈值限制并更新码率" class="headerlink" title="阈值限制并更新码率"></a>阈值限制并更新码率</h1><p><code>SendSideBandwidthEstimation::ApplyTargetLimits</code>对带宽的范围进行限制，结合remb、delay based bwe、配置的阈值得出最终值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::ApplyTargetLimits</span><span class="params">(Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">UpdateTargetBitrate</span>(current_target_, at_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendSideBandwidthEstimation::UpdateTargetBitrate</span><span class="params">(DataRate new_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制最大值不能大于延迟预估码率(delay_based_limit_)                                      </span></span><br><span class="line">  new_bitrate = std::<span class="built_in">min</span>(new_bitrate, <span class="built_in">GetUpperLimit</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能小于设置的最小码率</span></span><br><span class="line">  <span class="keyword">if</span> (new_bitrate &lt; min_bitrate_configured_) &#123;</span><br><span class="line">    <span class="built_in">MaybeLogLowBitrateWarning</span>(new_bitrate, at_time);</span><br><span class="line">    new_bitrate = min_bitrate_configured_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新当前目标码率</span></span><br><span class="line">  current_target_ = new_bitrate;</span><br><span class="line">  <span class="comment">// 日志</span></span><br><span class="line">  <span class="built_in">MaybeLogLossBasedEvent</span>(at_time);</span><br><span class="line">  <span class="comment">// 更新链路预估容量</span></span><br><span class="line">  link_capacity_.<span class="built_in">OnRateUpdate</span>(acknowledged_rate_, current_target_, at_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DataRate <span class="title">SendSideBandwidthEstimation::GetUpperLimit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// upper_limit为min[delay_based_limit_, receiver_limit_]</span></span><br><span class="line">  DataRate upper_limit = delay_based_limit_;</span><br><span class="line">  <span class="keyword">if</span> (disable_receiver_limit_caps_only_)</span><br><span class="line">    upper_limit = std::<span class="built_in">min</span>(upper_limit, receiver_limit_);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">min</span>(upper_limit, max_bitrate_configured_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wifi穿墙等弱网情况下，丢包会维持在10%以上，基于丢包的BWE会持续降低码率，造成饥渴现象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a name="gcc-analysis"></a> <a target="_blank" rel="noopener" href="https://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf">Analysis and Design of the Google Congestion Control for Web Real-time Communication (WebRTC)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab32a8a3552f">WebRTC基于TransportCC和Trendline Filter的发送端码率估计(Sendside-BWE)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rtcbits.com/2017/01/bandwidth-estimation-in-webrtc-and-new.html">Bandwidth Estimation in WebRTC (and the new Sender Side BWE)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sonysuqin/article/details/106186374">WebRTC GCC拥塞控制算法详解</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.jianchihu.net/webrtc-research-stats-loss-fraction-html.html">WebRTC研究：统计参数之丢包率</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqq_419/article/details/122282823">rtcp中的持续性丢包统计</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qw225967/article/details/125910410">流媒体学习之路(WebRTC)——GCC分析（1）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/490481512">WebRTC GCC代码深度解读(4) 基于Loss的带宽估计</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3MTUyNDUzMA==&amp;mid=2247483861&amp;idx=1&amp;sn=dda20ebd8af7837f106fb085bd8d8cd7">​WebRTC 拥塞控制 | 计算包组时间差-InterArrival</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/beginning1126/article/details/115276534">WebRTC带宽估计</a></li>
</ol>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6TFB-GCC/">https://charstr.github.io/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6TFB-GCC/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/Webrtc/"># Webrtc</a>
                            
                            <a href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"># 拥塞控制</a>
                            
                            <a href="/tags/BWE/"># BWE</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/01/06/RTMP%E5%8D%8F%E8%AE%AE/">RTMP协议</a>
                      
                        
                          <a class="next" rel="next" href="/2024/01/06/webrtc%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6REMB-GCC/">Webrtc拥塞控制REMB-GCC</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>