<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc带宽估计 | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!-- 通过连接CDN加载MathJax的js代码 -->
<!-- <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> -->


<!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script> -->

<script type="text/javascript" async
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc带宽估计
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">1月 18, 2024&nbsp;&nbsp;16:37:35</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/Webrtc/">Webrtc</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/BWE/">BWE</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <p><font color='red'>这部分很多错误，还在修正中!</font><br>Webrtc M121</p>
<p>webrtc中的部分码控结构，从socket层接收到数据后，到transport解析rtcp包处理得到feedback，通过call将feedback转发到对应sendstream上的rtcp处理模块，最终通过RtpTransportControllerSend将feedback转发到GoogCcNetworkController进行码率预估后，把预估的码率(target bitrate)， 探测策略(probe config), congestion windows给pacer，pacer转发给pacingContrller去使用进行发送码率控制</p>
<p>本节分析webrtc中bwe相关的前置函数，具体实现细节见各自小节内容。</p>
<p>若是仅使用WebRTC的BWE带宽估计，决定以多大码率发送报文时，会遇到如下难处：</p>
<p>发送端通过BWE算法，根据网络状态动态调节发送的码率。但是系统启动阶段初始码率应该设置成多大比较合适？<br>BWE估计带宽，这个算法的特点是：快降慢升，网络质量差时能迅速响应衰减带宽；但是网络持续向好时，不能迅速增加对应带宽。<br>网络持续向好，BWE探测码率持续上涨，若直接把码率提升上来，会有风险。</p>
<p>所以需要一种快速探测算法，探测当前网络合适的带宽，保证音视频按照最佳码率值发送数据。WebRTC在探测带宽时，是probe算法和BWE算法配合使用，BWE算法仅仅是一个参考值。实际生效需要根据probe结果决定。</p>
<p>///////////<br>ProbeBitrateEstimator : 根据feedback计算探测码率，PacingController中会将包按照cluster进行划分，transport-CC报文能得到包所属的cluster以及发送和接收信息，通过发送和接收的数据大小比判断是否到达链路上限从而进行带宽探测</p>
<p>AcknowledgedBitrateEstimator : 估算当前的吞吐量<br>BitrateEstimator :使用滑动窗口 + 卡尔曼滤波计算当前发送吞吐量<br>DelayBasedBwe : 基于延迟预估码率<br>TrendlineEstimator : 使用线性回归计算当前网络拥堵情况<br>AimdRateControl : 通过TrendLine预测出来的网络状态对码率进行aimd方式调整<br>SendSideBandwidthEstimation : 基于丢包计算预估码率，结合延迟预估码率，得到最终的目标码率<br>ProbeController : 探测控制器，通过目标码率判断下次是否探测，探测码率大小<br>CongestionWindowPushbackController : 基于当前的rtt设置一个时间窗口，同时基于当前的码率设置当前时间窗口下的数据量，通过判断当前窗口的使用量，如果使用量过大的时候，降低编码时使用的目标码率，加速窗口消退，减少延迟<br>AlrDetector : 应用(码率)受限检测，检测当前的发送码率是否和目标码率由于编码器等原因相差过大受限了，受限情况下会触发带宽预测过程的特殊处理<br>NetworkStateEstimator 、 NetworkStatePredictor ： 此两者属于待开发类，只是在代码中有，但是还没开发完，没用上.</p>
<h1 id="发送端带宽估计"><a href="#发送端带宽估计" class="headerlink" title="发送端带宽估计"></a>发送端带宽估计</h1><p>Call::UpdateAggregateNetworkState<br>RtpTransportControllerSend::OnNetworkAvailability<br>RtpTransportControllerSend::OnNetworkAvailability<br>RtpTransportControllerSend::MaybeCreateControllers</p>
<p>发送端接收对RTCP包进行解析之后，对不同类型的包进行不同的处理。发送端BWE主要以来接收端REMB的码率、丢包率、RTT等信息。数据包在<code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>进行不同的处理。</p>
<p><code>GoogCcNetworkController</code>是带宽估计和调整的核心。在<code>RtpTransportControllerSend::MaybeCreateControllers</code>函数创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::MaybeCreateControllers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 创建GoogCcNetworkController</span></span><br><span class="line">  <span class="keyword">if</span> (controller_factory_override_) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Creating overridden congestion controller&quot;</span>;</span><br><span class="line">    controller_ = controller_factory_override_-&gt;<span class="built_in">Create</span>(initial_config_);</span><br><span class="line">    process_interval_ = controller_factory_override_-&gt;<span class="built_in">GetProcessInterval</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Creating fallback congestion controller&quot;</span>;</span><br><span class="line">    controller_ = controller_factory_fallback_-&gt;<span class="built_in">Create</span>(initial_config_);</span><br><span class="line">    process_interval_ = controller_factory_fallback_-&gt;<span class="built_in">GetProcessInterval</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定时对码率进行检测和更新，并将结果转发给pacer</span></span><br><span class="line">  <span class="built_in">UpdateControllerWithTimeInterval</span>();</span><br><span class="line">  <span class="built_in">StartProcessPeriodicTasks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的部分功能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::UpdateControllerWithTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(controller_);</span><br><span class="line">  ProcessInterval msg;</span><br><span class="line">  msg.at_time = Timestamp::<span class="built_in">Millis</span>(env_.<span class="built_in">clock</span>().<span class="built_in">TimeInMilliseconds</span>());</span><br><span class="line">  <span class="keyword">if</span> (add_pacing_to_cwin_)</span><br><span class="line">    msg.pacer_queue = pacer_.<span class="built_in">QueueSizeData</span>();</span><br><span class="line">  <span class="comment">// 定时对码率进行检测和更新，并将结果转发给pacer</span></span><br><span class="line">  <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnProcessInterval</span>(msg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::StartProcessPeriodicTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// control_handler将GoogCcNetworkController计算的相关码率信息回调给其它模块</span></span><br><span class="line">  <span class="comment">// 调用UpdateControlState</span></span><br><span class="line">  <span class="keyword">if</span> (!pacer_queue_update_task_.<span class="built_in">Running</span>()) &#123;</span><br><span class="line">    pacer_queue_update_task_ = RepeatingTaskHandle::<span class="built_in">DelayedStart</span>(</span><br><span class="line">        task_queue_, kPacerQueueUpdateInterval, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">          <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">          TimeDelta expected_queue_time = pacer_.<span class="built_in">ExpectedQueueTime</span>();</span><br><span class="line">          control_handler_-&gt;<span class="built_in">SetPacerQueue</span>(expected_queue_time);</span><br><span class="line">          <span class="built_in">UpdateControlState</span>();</span><br><span class="line">          <span class="keyword">return</span> kPacerQueueUpdateInterval;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  controller_task_.<span class="built_in">Stop</span>();</span><br><span class="line">  <span class="keyword">if</span> (process_interval_.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 定时任务，定时执行UpdateControllerWithTimeInterval检测更新码率</span></span><br><span class="line">    controller_task_ = RepeatingTaskHandle::<span class="built_in">DelayedStart</span>(</span><br><span class="line">        task_queue_, process_interval_, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">          <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">          <span class="built_in">UpdateControllerWithTimeInterval</span>();</span><br><span class="line">          <span class="keyword">return</span> process_interval_;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GoogCcNetworkController::OnProcessInterval</code>会定时触发进行带宽检测和更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnProcessInterval</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ProcessInterval msg)</span> </span>&#123;</span><br><span class="line">  NetworkControlUpdate update;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GoogCcNetworkController构造时候有传进来的初始的配置，</span></span><br><span class="line">  <span class="comment">// 初次调用的时候进行初始化设置，后边不用每次调用</span></span><br><span class="line">  <span class="keyword">if</span> (initial_config_) &#123;</span><br><span class="line">    <span class="comment">// 重设loss_based和delay_based码率探测器和probe的初始码率</span></span><br><span class="line">    <span class="comment">// 设置SendSideBandwidthEstimation、DelayBasedBwe、ProbeController</span></span><br><span class="line">    <span class="comment">// 的码率，返回码率探测簇配置std::vector&lt;ProbeClusterConfig&gt;，</span></span><br><span class="line">    <span class="comment">// 最终给pacing_controller控制发包码率</span></span><br><span class="line">    update.probe_cluster_configs =</span><br><span class="line">        <span class="built_in">ResetConstraints</span>(initial_config_-&gt;constraints);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前pacing 的发送码率、padding、time_windows等配置</span></span><br><span class="line">    update.pacer_config = <span class="built_in">GetPacingRates</span>(msg.at_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用周期性ALR探测，允许因为alr需要快速恢复码率而继续做probe</span></span><br><span class="line">    <span class="keyword">if</span> (initial_config_-&gt;stream_based_config.requests_alr_probing) &#123;</span><br><span class="line">      probe_controller_-&gt;<span class="built_in">EnablePeriodicAlrProbing</span>(</span><br><span class="line">          *initial_config_-&gt;stream_based_config.requests_alr_probing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有设置最大总分配码率，在ProbeController触发相应事件</span></span><br><span class="line">    absl::optional&lt;DataRate&gt; total_bitrate =</span><br><span class="line">        initial_config_-&gt;stream_based_config.max_total_allocated_bitrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total_bitrate) &#123;</span><br><span class="line">      <span class="comment">// 为ProbeController设置最大的分配码率(MaxTotalAllocatedBitrate)作为探测的上限</span></span><br><span class="line">      <span class="comment">// 探测的码率达到这个值就停止探测</span></span><br><span class="line">      <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">OnMaxTotalAllocatedBitrate</span>(</span><br><span class="line">          *total_bitrate, msg.at_time);</span><br><span class="line">      update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                          probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置initial_config_，不需要每次进行初始化设置</span></span><br><span class="line">    initial_config_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新拥塞窗口中的pacing数据长度</span></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; msg.pacer_queue) &#123;</span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdatePacingQueue</span>(</span><br><span class="line">        msg.pacer_queue-&gt;<span class="built_in">bytes</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送端周期性基于丢包的BWE</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// SendSideBandwidthEstimation基于时间更新码率，其内部是依靠cc-feedback</span></span><br><span class="line">  <span class="comment">// 提供丢包率来预估码率，当没有feedback也会基于时间预估当前的rtt去更新码率</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateEstimate</span>(msg.at_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ALR的开始时间。从AlrDetector获取当前是否处于Application-Limited Region（ALR）状态</span></span><br><span class="line">  <span class="comment">// AlrDetector每次发送数据时(OnSentPacket)都会检测实际发送码率是否与目标码率相差太多，</span></span><br><span class="line">  <span class="comment">// 从而判断是否(受限于编码器等原因而导致)无法达到目标码率，从而设定处于alr状态</span></span><br><span class="line">  <span class="comment">// 带宽预测的核心是需要向链路中发送足够的包去观察链路情况，</span></span><br><span class="line">  <span class="comment">// 如果探测到处于alr状态无法达到这个要求，就需要一些额外手段去处理。</span></span><br><span class="line">  absl::optional&lt;<span class="type">int64_t</span>&gt; start_time_ms =</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>();</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 在ProbeController设置ALR的开始时间。ProbeController内部已经完成了初始的探测过程，</span></span><br><span class="line">  <span class="comment">// 并且在正常的探测完成后，不再主动进行额外的探测。但当网络处于ALR状态或者网络发生变化时，</span></span><br><span class="line">  <span class="comment">// ProbeController要继续探测以便快恢复码率</span></span><br><span class="line">  probe_controller_-&gt;<span class="built_in">SetAlrStartTimeMs</span>(start_time_ms);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出码率过低，且处于alr的状态时，进行周期性探测</span></span><br><span class="line">  <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">Process</span>(msg.at_time);</span><br><span class="line">  update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                      probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用拥塞窗口并且反馈最大RTT不为空，更新拥塞窗口大小</span></span><br><span class="line">  <span class="comment">// (CongestionWindowPushbackController)</span></span><br><span class="line">  <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindow</span>() &amp;&amp;</span><br><span class="line">      !feedback_max_rtts_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">UpdateCongestionWindowSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; current_data_window_) &#123;</span><br><span class="line">    <span class="comment">// 设置拥塞控制窗口大小</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">SetDataWindow</span>(</span><br><span class="line">        *current_data_window_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.congestion_window = current_data_window_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bandwidth_estimation_可能对码率进行了更新，</span></span><br><span class="line">  <span class="comment">// 调用MaybeTriggerOnNetworkChanged()对alr，probe_controller中的码率进行更新，</span></span><br><span class="line">  <span class="comment">// 同时将码率，probe_config等放到update中返回</span></span><br><span class="line">  <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, msg.at_time);</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取接收端码率"><a href="#获取接收端码率" class="headerlink" title="获取接收端码率"></a>获取接收端码率</h2><p><code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>函数解析接收端REMB的带宽，调用<code>RtpTransportControllerSend::OnReceiverEstimatedMaxBitrate</code>函数，并传递给<code>GoogCcNetworkController::OnRemoteBitrateReport</code>进行处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnReceiverEstimatedMaxBitrate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate bitrate)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  RemoteBitrateReport msg;</span><br><span class="line">  msg.receive_time = receive_time;</span><br><span class="line">  msg.bandwidth = bitrate;</span><br><span class="line">  <span class="comment">// 作用到pacer模块</span></span><br><span class="line">  <span class="comment">// GoogCcNetworkController::OnRemoteBitrateReport</span></span><br><span class="line">  <span class="keyword">if</span> (controller_)</span><br><span class="line">    <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnRemoteBitrateReport</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="统计并计算丢包"><a href="#统计并计算丢包" class="headerlink" title="统计并计算丢包"></a>统计并计算丢包</h2><p><code>RtpTransportControllerSend::OnReport</code>统计发送的数据包数和丢失的数据包数目，通过<code>TransportLossReport</code>交给GoogCcNetworkController模块实现发送端基于丢包的BWE，并作用到pace模块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnReport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    rtc::ArrayView&lt;<span class="type">const</span> ReportBlockData&gt; report_blocks)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="keyword">if</span> (report_blocks.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 丢包数和收到的包数的增量</span></span><br><span class="line">  <span class="type">int</span> total_packets_lost_delta = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> total_packets_delta = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 遍历所有来自接收端的报告块，可能有音频、视频等不同流的报告块，计算丢包数</span></span><br><span class="line">  <span class="comment">// 发送端累计RR包中所有流的所有Report Block的丢包，计算总的丢包率。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> ReportBlockData&amp; report_block : report_blocks) &#123;</span><br><span class="line">    <span class="comment">// 通过ssrc查找Report Block是否已经存到了对应的流</span></span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = </span><br><span class="line">        last_report_blocks_.<span class="built_in">try_emplace</span>(report_block.<span class="built_in">source_ssrc</span>());</span><br><span class="line"></span><br><span class="line">    LossReport&amp; last_loss_report = it-&gt;second;</span><br><span class="line">    <span class="comment">// 报告块已存在，累加丢包数和收到的包数的增量</span></span><br><span class="line">    <span class="keyword">if</span> (!inserted) &#123;</span><br><span class="line">      <span class="comment">// 计算单个流</span></span><br><span class="line">      <span class="comment">// 累计接受的包数</span></span><br><span class="line">      total_packets_delta += report_block.<span class="built_in">extended_highest_sequence_number</span>() -</span><br><span class="line">                             last_loss_report.extended_highest_sequence_number;</span><br><span class="line">      <span class="comment">// 累计都是的包数</span></span><br><span class="line">      total_packets_lost_delta +=</span><br><span class="line">          report_block.<span class="built_in">cumulative_lost</span>() - last_loss_report.cumulative_lost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新报告块的最高序列号和累计丢包数</span></span><br><span class="line">    last_loss_report.extended_highest_sequence_number =</span><br><span class="line">        report_block.<span class="built_in">extended_highest_sequence_number</span>();</span><br><span class="line">    last_loss_report.cumulative_lost = report_block.<span class="built_in">cumulative_lost</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!total_packets_delta)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 计算收到的包数的增量</span></span><br><span class="line">  <span class="type">int</span> packets_received_delta = total_packets_delta - total_packets_lost_delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packets_received_delta &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  TransportLossReport msg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到后续需要的丢包统计信息</span></span><br><span class="line">  msg.packets_lost_delta = total_packets_lost_delta;</span><br><span class="line">  msg.packets_received_delta = packets_received_delta;</span><br><span class="line">  msg.receive_time = receive_time;</span><br><span class="line">  msg.start_time = last_report_block_time_;</span><br><span class="line">  msg.end_time = receive_time;</span><br><span class="line">  <span class="comment">// GoogCcNetworkController::OnTransportLossReport</span></span><br><span class="line">  <span class="comment">// 并作用到pacer</span></span><br><span class="line">  <span class="keyword">if</span> (controller_)</span><br><span class="line">    <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnTransportLossReport</span>(msg));</span><br><span class="line">  <span class="comment">// 更新最后一个报告块的时间</span></span><br><span class="line">  last_report_block_time_ = receive_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送端计算RTT"><a href="#发送端计算RTT" class="headerlink" title="发送端计算RTT"></a>发送端计算RTT</h2><p><code>RTCPReceiver::ParseCompoundPacket</code>解析rtcp报文，对RR、SR包的计算了RTT，保存到<code>packet_information</code>，传给<code>RtpTransportControllerSend::OnRttUpdate</code>进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnRttUpdate</span><span class="params">(Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             TimeDelta rtt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  RoundTripTimeUpdate report;</span><br><span class="line">  report.receive_time = receive_time;</span><br><span class="line">  report.round_trip_time = rtt.<span class="built_in">RoundTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">  report.smoothed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (controller_ &amp;&amp; !report.round_trip_time.<span class="built_in">IsZero</span>())</span><br><span class="line">    <span class="comment">// GoogCcNetworkController::OnRoundTripTimeUpdate更新RTT</span></span><br><span class="line">    <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnRoundTripTimeUpdate</span>(report));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送端基于twcc的BME"><a href="#发送端基于twcc的BME" class="headerlink" title="发送端基于twcc的BME"></a>发送端基于twcc的BME</h2><h3 id="RTP扩展支持"><a href="#RTP扩展支持" class="headerlink" title="RTP扩展支持"></a>RTP扩展支持</h3><p>RTP添加的扩展如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0              1                2               3</span><br><span class="line"> 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       0xBE    |    0xDE       |           length=1            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  ID   | L=1   |transport-wide sequence number | zero padding  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>2字节的<code>transport-wide sequence number</code>是传输层序列号，会添加到每个要发送的RTP包，发送端每发送一个RTP包序列号就会累加1。<strong>当发送端发送多路流时，所有流的 RTP 包的该扩展字段都是连续计数的，不会分开独立计数</strong>。该扩展头的作用是为了标识发送的包和反馈的包对应关系，用来进行码率估计；而RTP报文中的序列号是媒体流的序列号，主要用来组帧和抗丢包，同时也用来分离媒体。</p>
<p>Webrtc中调用<code>RTPSender::AllocatePacket</code>函数给RTP包分配内存时，会给RTP扩展预分配内存。若注册了（registered）某个扩展，会对相应的内容进行赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;RtpPacketToSend&gt; <span class="title">RTPSender::AllocatePacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    rtc::ArrayView&lt;<span class="type">const</span> <span class="type">uint32_t</span>&gt; csrcs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span> packet = std::<span class="built_in">make_unique</span>&lt;RtpPacketToSend&gt;(&amp;rtp_header_extension_map_,</span><br><span class="line">                                                  max_packet_size_);</span><br><span class="line">  packet-&gt;<span class="built_in">SetSsrc</span>(ssrc_);</span><br><span class="line">  packet-&gt;<span class="built_in">SetCsrcs</span>(csrcs);</span><br><span class="line">  <span class="comment">// 给扩展预留内存，如果注册了扩展会在 SendToNetwork 中设置 RtpSender</span></span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;AbsoluteSendTime&gt;();</span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;TransmissionOffset&gt;();</span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以视频为例，<code>RtpVideoSender</code>构造函数中注册扩展的过程为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">RtpVideoSender::<span class="built_in">RtpVideoSender</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rtp_config_.extensions.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 将rtp_config_中的所有extension设置到stream对应的rtp_rtcp module下</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; extension = rtp_config_.extensions[i].uri;</span><br><span class="line">    <span class="type">int</span> id = rtp_config_.extensions[i].id;</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(RtpExtension::<span class="built_in">IsSupportedForVideo</span>(extension));</span><br><span class="line">    <span class="comment">// rtp_rtcp module注册这些extension到每个流</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> RtpStreamSender&amp; stream : rtp_streams_) &#123;</span><br><span class="line">      <span class="comment">// std::unique_ptr&lt;ModuleRtpRtcpImpl2&gt; rtp_rtcp;</span></span><br><span class="line">      stream.rtp_rtcp-&gt;<span class="built_in">RegisterRtpHeaderExtension</span>(extension, id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModuleRtpRtcpImpl2::RegisterRtpHeaderExtension</span><span class="params">(absl::string_view uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将其转发给RTPSender packet_generator进行注册</span></span><br><span class="line">  <span class="type">bool</span> registered =</span><br><span class="line">      rtp_sender_-&gt;packet_generator.<span class="built_in">RegisterRtpHeaderExtension</span>(uri, id);</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(registered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RTPSender::RegisterRtpHeaderExtension</span><span class="params">(absl::string_view uri, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;send_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 注册扩展</span></span><br><span class="line">  <span class="type">bool</span> registered = rtp_header_extension_map_.<span class="built_in">RegisterByUri</span>(id, uri);</span><br><span class="line">  <span class="comment">// 是否启用了所有的BWE相关的RTP扩展决定是否启用padding功能</span></span><br><span class="line">  <span class="comment">// (带宽探测时，当前数据量达不到目标发送码率，用一些历史包或者空数据做带宽填充)</span></span><br><span class="line">  supports_bwe_extension_ = <span class="built_in">HasBweExtension</span>(rtp_header_extension_map_);</span><br><span class="line">  <span class="built_in">UpdateHeaderSizes</span>();</span><br><span class="line">  <span class="keyword">return</span> registered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BWE相关的RTP扩展共有四种</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasBweExtension</span><span class="params">(<span class="type">const</span> RtpHeaderExtensionMap&amp; extensions_map)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransportSequenceNumber) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransportSequenceNumber02) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionAbsoluteSendTime) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransmissionTimeOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// padding需要BWE相关的RTP扩展全部注册启用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RTPSender::SupportsPadding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;send_mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> sending_media_ &amp;&amp; supports_bwe_extension_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDP协商"><a href="#SDP协商" class="headerlink" title="SDP协商"></a>SDP协商</h3><p>视频的<code>AddDefaultFeedbackParams</code>函数和音频的<code>WebRtcVoiceEngine::CollectCodecs</code>函数在收集Feedback Param参数时候的一个函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codec-&gt;<span class="built_in">AddFeedbackParam</span>(<span class="built_in">FeedbackParam</span>(kRtcpFbParamTransportCc, kParamValueEmpty));</span><br></pre></td></tr></table></figure>
<p>启用TWCC需要在SDP数据中添加一条:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br></pre></td></tr></table></figure>
<p>SDP协商过程不变。</p>
<h3 id="TWCC解析"><a href="#TWCC解析" class="headerlink" title="TWCC解析"></a>TWCC解析</h3><p>接收到RTCP之后，在<code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>根据不同的RTCP类型调用不同的回调函数处理。<code>RtpTransportControllerSend::OnTransportFeedback</code>解析twcc包的内容，得到feedback_msg交给<code>GoogCcNetworkController::OnTransportPacketsFeedback</code>去做BWE</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line"></span><br><span class="line">  feedback_demuxer_.<span class="built_in">OnTransportFeedback</span>(feedback);</span><br><span class="line">  <span class="comment">// 从封装的PacketInformation中的TransportFeedback提取反馈包TWCC解析得到feedback_msg</span></span><br><span class="line">  <span class="comment">// 作用到GoogCcNetworkController模块去做BWE</span></span><br><span class="line">  absl::optional&lt;TransportPacketsFeedback&gt; feedback_msg =</span><br><span class="line">      transport_feedback_adapter_.<span class="built_in">ProcessTransportFeedback</span>(feedback,</span><br><span class="line">                                                           receive_time);</span><br><span class="line">  <span class="comment">// 将feedback_msg交给GoogCcNetworkController，</span></span><br><span class="line">  <span class="comment">// GoogCcNetworkController::OnTransportPacketsFeedback估算最终的码率并进一步probe    </span></span><br><span class="line">  <span class="keyword">if</span> (feedback_msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (controller_)</span><br><span class="line">      <span class="comment">// 发送端实现twcc的BWE，并处理传输的反馈以更新控制器的状态</span></span><br><span class="line">      <span class="comment">// GoogCcNetworkController::OnTransportPacketsFeedback</span></span><br><span class="line">      <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnTransportPacketsFeedback</span>(*feedback_msg));</span><br><span class="line">    <span class="comment">// 只有在任何数据包第一次被确认时才更新未完成的数据</span></span><br><span class="line">    <span class="built_in">UpdateCongestedState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::ProcessTransportFeedback</code>解析twcc包TransportPacketsFeedback feedback_msg信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;TransportPacketsFeedback&gt;</span></span><br><span class="line"><span class="function"><span class="title">TransportFeedbackAdapter::ProcessTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp feedback_receive_time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (feedback.<span class="built_in">GetPacketStatusCount</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Empty transport feedback packet received.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TransportPacketsFeedback msg;</span><br><span class="line">  msg.feedback_time = feedback_receive_time;</span><br><span class="line"></span><br><span class="line">  msg.prior_in_flight = in_flight_.<span class="built_in">GetOutstandingData</span>(network_route_);</span><br><span class="line">  <span class="comment">// feedback packet 再赋值</span></span><br><span class="line">  msg.packet_feedbacks =</span><br><span class="line">      <span class="built_in">ProcessTransportFeedbackInner</span>(feedback, feedback_receive_time);</span><br><span class="line">  <span class="keyword">if</span> (msg.packet_feedbacks.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(last_ack_seq_num_);</span><br><span class="line">  <span class="keyword">if</span> (it != history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    msg.first_unacked_send_time = it-&gt;second.sent.send_time;</span><br><span class="line">  &#125;</span><br><span class="line">  msg.data_in_flight = in_flight_.<span class="built_in">GetOutstandingData</span>(network_route_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packet_feedbacks 通过调用ProcessTransportFeedbackInner生成，用于后边的Trendline预测。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;PacketResult&gt;</span></span><br><span class="line"><span class="function"><span class="title">TransportFeedbackAdapter::ProcessTransportFeedbackInner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp feedback_receive_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里把第一个收到cc-feedback的时刻(feedback_receive_time)作为最初基准时间偏移(current_offset_)，</span></span><br><span class="line">  <span class="comment">// 在后续的cc-feedback报文到达后，计算之前cc-feedback的feedback_receive_time和当前的delta，</span></span><br><span class="line">  <span class="comment">// 累加到current_offset _上作为后续的基础时间偏移，根据注释所言，是为了能够更好的检视包的到达时间。</span></span><br><span class="line">  <span class="keyword">if</span> (last_timestamp_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">    current_offset_ = feedback_receive_time;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算当前的Base time和之前的Base time的差</span></span><br><span class="line">    <span class="type">const</span> TimeDelta delta = feedback.<span class="built_in">GetBaseDelta</span>(last_timestamp_)</span><br><span class="line">                                .<span class="built_in">RoundDownTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Protect against assigning current_offset_ negative value.</span></span><br><span class="line">    <span class="keyword">if</span> (delta &lt; Timestamp::<span class="built_in">Zero</span>() - current_offset_) &#123;</span><br><span class="line">      <span class="comment">// current_offset_负数情况下，直接将current_offset_置为feedback_receive_time</span></span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Unexpected feedback timestamp received.&quot;</span>;</span><br><span class="line">      current_offset_ = feedback_receive_time;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// current_offset 正常，则直接等于即可</span></span><br><span class="line">      current_offset_ += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last_timestamp_ = feedback.<span class="built_in">BaseTime</span>();</span><br><span class="line"></span><br><span class="line">  std::vector&lt;PacketResult&gt; packet_result_vector;</span><br><span class="line">  packet_result_vector.<span class="built_in">reserve</span>(feedback.<span class="built_in">GetPacketStatusCount</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> failed_lookups = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> ignored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  feedback.<span class="built_in">ForAllPackets</span>(</span><br><span class="line">      [&amp;](<span class="type">uint16_t</span> sequence_number, TimeDelta delta_since_base) &#123;</span><br><span class="line">        <span class="type">int64_t</span> seq_num = seq_num_unwrapper_.<span class="built_in">Unwrap</span>(sequence_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seq_num &gt; last_ack_seq_num_) &#123;</span><br><span class="line">          <span class="comment">// Starts at history_.begin() if last_ack_seq_num_ &lt; 0, since any</span></span><br><span class="line">          <span class="comment">// valid sequence number is &gt;= 0.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> it = history_.<span class="built_in">upper_bound</span>(last_ack_seq_num_);</span><br><span class="line">               it != history_.<span class="built_in">upper_bound</span>(seq_num); ++it) &#123;</span><br><span class="line">            in_flight_.<span class="built_in">RemoveInFlightPacketBytes</span>(it-&gt;second);</span><br><span class="line">          &#125;</span><br><span class="line">          last_ack_seq_num_ = seq_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据transport seqnumber将packet从history_获取出来，然后对其接收时间和接收状态的再赋值</span></span><br><span class="line">        <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(seq_num);</span><br><span class="line">        <span class="keyword">if</span> (it == history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          ++failed_lookups;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second.sent.send_time.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">          <span class="comment">// TODO(srte): Fix the tests that makes this happen and make this a</span></span><br><span class="line">          <span class="comment">// DCHECK.</span></span><br><span class="line">          <span class="built_in">RTC_DLOG</span>(LS_ERROR)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;Received feedback before packet was indicated as sent&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PacketFeedback packet_feedback = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (delta_since_base.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">          packet_feedback.receive_time =</span><br><span class="line">              current_offset_ +</span><br><span class="line">              delta_since_base.<span class="built_in">RoundDownTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">          <span class="comment">// Note: Lost packets are not removed from history because they might</span></span><br><span class="line">          <span class="comment">// be reported as received by a later feedback.</span></span><br><span class="line">          history_.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (packet_feedback.network_route == network_route_) &#123;</span><br><span class="line">          PacketResult result;</span><br><span class="line">          result.sent_packet = packet_feedback.sent;</span><br><span class="line">          result.receive_time = packet_feedback.receive_time;</span><br><span class="line">          packet_result_vector.<span class="built_in">push_back</span>(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++ignored;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failed_lookups &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Failed to lookup send time for &quot;</span> &lt;&lt; failed_lookups</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; packet&quot;</span> &lt;&lt; (failed_lookups &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">                        &lt;&lt; <span class="string">&quot;. Send time history too small?&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ignored &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Ignoring &quot;</span> &lt;&lt; ignored</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; packets because they were sent on a different route.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> packet_result_vector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分成左右两边，右边是生成feedback packet的过程，最初由RTPSenderVideo注册cc-extension到RTPSender, RTPSender支持cc-extension后支持PacingController的padding，并生成带有TransportSequenceNumber的包，转发到PacketRouter后设置TransportSequenceNumber, 在网络发送的过程中，经由RTPSenderEgress 将包的信息传到RTPTransportController，让其调用TransportFeedbackAdapter生成feedback packet; </p>
<h1 id="接收端带宽估计"><a href="#接收端带宽估计" class="headerlink" title="接收端带宽估计"></a>接收端带宽估计</h1><p>Call::DeliverRtpPacket<br>Call::NotifyBweOfReceivedPacket<br>ReceiveSideCongestionController::OnReceivedPacket<br>RemoteBitrateEstimatorAbsSendTime::IncomingPacket 做REMB的BWE</p>
<h1 id="配置网络更新"><a href="#配置网络更新" class="headerlink" title="配置网络更新"></a>配置网络更新</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::PostUpdates</span><span class="params">(NetworkControlUpdate update)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (update.congestion_window) &#123;</span><br><span class="line">    congestion_window_size_ = *update.congestion_window;</span><br><span class="line">    <span class="comment">// 更新拥塞窗口</span></span><br><span class="line">    <span class="built_in">UpdateCongestedState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (update.pacer_config) &#123;</span><br><span class="line">    <span class="comment">// 设置pacer发送码率</span></span><br><span class="line">    pacer_.<span class="built_in">SetPacingRates</span>(update.pacer_config-&gt;<span class="built_in">data_rate</span>(),</span><br><span class="line">                          update.pacer_config-&gt;<span class="built_in">pad_rate</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将新生成的ProbeClusterConfig转发到PacingController</span></span><br><span class="line">  <span class="keyword">if</span> (!update.probe_cluster_configs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    pacer_.<span class="built_in">CreateProbeClusters</span>(std::<span class="built_in">move</span>(update.probe_cluster_configs));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (update.target_rate) &#123;</span><br><span class="line">    <span class="comment">// 设置目标码率</span></span><br><span class="line">    control_handler_-&gt;<span class="built_in">SetTargetRate</span>(*update.target_rate);</span><br><span class="line">    <span class="comment">// 配置FEC、编码器等分配的码率</span></span><br><span class="line">    <span class="built_in">UpdateControlState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="更新网络状态"><a href="#更新网络状态" class="headerlink" title="更新网络状态"></a>更新网络状态</h1><p><code>MaybeTriggerOnNetworkChanged</code>是在进行BWE之后，将新码率设置到probe_controller, alr_detector等，并作用给pacing_controller使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoogCcNetworkController::MaybeTriggerOnNetworkChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkControlUpdate* update,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从BWE获取丢包率、RTT、码率、状态信息</span></span><br><span class="line">  <span class="type">uint8_t</span> fraction_loss = bandwidth_estimation_-&gt;<span class="built_in">fraction_loss</span>();</span><br><span class="line">  TimeDelta round_trip_time = bandwidth_estimation_-&gt;<span class="built_in">round_trip_time</span>();</span><br><span class="line">  DataRate loss_based_target_rate = bandwidth_estimation_-&gt;<span class="built_in">target_rate</span>();</span><br><span class="line">  LossBasedState loss_based_state = bandwidth_estimation_-&gt;<span class="built_in">loss_based_state</span>();</span><br><span class="line"></span><br><span class="line">  DataRate pushback_target_rate = loss_based_target_rate;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;fraction_loss_%&quot;</span>, at_time.<span class="built_in">ms</span>(),</span><br><span class="line">                        (fraction_loss * <span class="number">100</span>) / <span class="number">256</span>);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;rtt_ms&quot;</span>, at_time.<span class="built_in">ms</span>(), round_trip_time.<span class="built_in">ms</span>());</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;Target_bitrate_kbps&quot;</span>, at_time.<span class="built_in">ms</span>(),</span><br><span class="line">                        loss_based_target_rate.<span class="built_in">kbps</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> cwnd_reduce_ratio = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 新拥塞控制窗口中的目标码率，同时获取新的拥塞控制码率</span></span><br><span class="line">    <span class="type">int64_t</span> pushback_rate =</span><br><span class="line">        congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateTargetBitrate</span>(</span><br><span class="line">            loss_based_target_rate.<span class="built_in">bps</span>());</span><br><span class="line">      </span><br><span class="line">    pushback_rate = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(bandwidth_estimation_-&gt;<span class="built_in">GetMinBitrate</span>(),</span><br><span class="line">                                      pushback_rate);</span><br><span class="line">    <span class="comment">// 通过目标码率更新拥塞窗口的发送码率，</span></span><br><span class="line">    pushback_target_rate = DataRate::<span class="built_in">BitsPerSec</span>(pushback_rate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindowDropFrameOnly</span>()) &#123;</span><br><span class="line">      <span class="comment">// 通过预估码率和拥塞控制发送码率得到码率的降低比例，用来控制编码</span></span><br><span class="line">      cwnd_reduce_ratio = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(loss_based_target_rate.<span class="built_in">bps</span>() -</span><br><span class="line">                                              pushback_target_rate.<span class="built_in">bps</span>()) /</span><br><span class="line">                          loss_based_target_rate.<span class="built_in">bps</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链路容量(link_capacity)、 丢包码率(loss_based_target_rate)、窗口控制码率(pushback_target_rate)</span></span><br><span class="line">  <span class="comment">// 选择最小得到保守码率</span></span><br><span class="line">  <span class="comment">// 链路容量(link_capacity): 基于目标码率和当前吞吐量(acknowledge)做指数平滑估计出来的链路容量</span></span><br><span class="line">  <span class="comment">// 丢包码率(loss_based_target_rate): 基于丢包估算出来的链路码率，该码率并以延迟预估码率为上限</span></span><br><span class="line">  <span class="comment">// 窗口控制码率(pushback_target_rate)：基于loss_based_target_rate和当前窗口的使用程度缩放后的码率</span></span><br><span class="line">  DataRate stable_target_rate =</span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">GetEstimatedLinkCapacity</span>();</span><br><span class="line">  stable_target_rate = std::<span class="built_in">min</span>(stable_target_rate, pushback_target_rate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数有变化的进行更新</span></span><br><span class="line">  <span class="keyword">if</span> ((loss_based_target_rate != last_loss_based_target_rate_) ||</span><br><span class="line">      (loss_based_state != last_loss_base_state_) ||</span><br><span class="line">      (fraction_loss != last_estimated_fraction_loss_) ||</span><br><span class="line">      (round_trip_time != last_estimated_round_trip_time_) ||</span><br><span class="line">      (pushback_target_rate != last_pushback_target_rate_) ||</span><br><span class="line">      (stable_target_rate != last_stable_target_rate_)) &#123;</span><br><span class="line">    last_loss_based_target_rate_ = loss_based_target_rate;</span><br><span class="line">    last_pushback_target_rate_ = pushback_target_rate;</span><br><span class="line">    last_estimated_fraction_loss_ = fraction_loss;</span><br><span class="line">    last_estimated_round_trip_time_ = round_trip_time;</span><br><span class="line">    last_stable_target_rate_ = stable_target_rate;</span><br><span class="line">    last_loss_base_state_ = loss_based_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进行ALR探测的码率，用于更新IntervalBudget的预算</span></span><br><span class="line">    alr_detector_-&gt;<span class="built_in">SetEstimatedBitrate</span>(loss_based_target_rate.<span class="built_in">bps</span>());</span><br><span class="line">    <span class="comment">// 下次BWE期望的周期</span></span><br><span class="line">    TimeDelta bwe_period = delay_based_bwe_-&gt;<span class="built_in">GetExpectedBwePeriod</span>();</span><br><span class="line"></span><br><span class="line">    TargetTransferRate target_rate_msg;</span><br><span class="line">    target_rate_msg.at_time = at_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用仅丢帧来控制码率</span></span><br><span class="line">    <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindowDropFrameOnly</span>()) &#123;</span><br><span class="line">      <span class="comment">// 直接使用基于延迟的预估码率作为目标码率</span></span><br><span class="line">      target_rate_msg.target_rate = loss_based_target_rate;</span><br><span class="line">      target_rate_msg.cwnd_reduce_ratio = cwnd_reduce_ratio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用窗口控制码率作为目标码率</span></span><br><span class="line">      target_rate_msg.target_rate = pushback_target_rate;</span><br><span class="line">    &#125;</span><br><span class="line">    target_rate_msg.stable_target_rate = stable_target_rate;</span><br><span class="line">    target_rate_msg.network_estimate.at_time = at_time;</span><br><span class="line">    target_rate_msg.network_estimate.round_trip_time = round_trip_time;</span><br><span class="line">    target_rate_msg.network_estimate.loss_rate_ratio = fraction_loss / <span class="number">255.0f</span>;</span><br><span class="line">    target_rate_msg.network_estimate.bwe_period = bwe_period;</span><br><span class="line"></span><br><span class="line">    update-&gt;target_rate = target_rate_msg;</span><br><span class="line">    <span class="comment">// 码率没有达到预期的容量，重新进行探测</span></span><br><span class="line">    <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">SetEstimatedBitrate</span>(</span><br><span class="line">        loss_based_target_rate,</span><br><span class="line">        <span class="built_in">GetBandwidthLimitedCause</span>(bandwidth_estimation_-&gt;<span class="built_in">loss_based_state</span>(),</span><br><span class="line">                                 bandwidth_estimation_-&gt;<span class="built_in">IsRttAboveLimit</span>(),</span><br><span class="line">                                 delay_based_bwe_-&gt;<span class="built_in">last_state</span>()),</span><br><span class="line">        at_time);</span><br><span class="line"></span><br><span class="line">    update-&gt;probe_cluster_configs.<span class="built_in">insert</span>(update-&gt;probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                         probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 获取平滑发送的配置</span></span><br><span class="line">    update-&gt;pacer_config = <span class="built_in">GetPacingRates</span>(at_time);</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_VERBOSE) &lt;&lt; <span class="string">&quot;bwe &quot;</span> &lt;&lt; at_time.<span class="built_in">ms</span>() &lt;&lt; <span class="string">&quot; pushback_target_bps=&quot;</span></span><br><span class="line">                        &lt;&lt; last_pushback_target_rate_.<span class="built_in">bps</span>()</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; estimate_bps=&quot;</span> &lt;&lt; loss_based_target_rate.<span class="built_in">bps</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PacerConfig <span class="title">GoogCcNetworkController::GetPacingRates</span><span class="params">(Timestamp at_time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pacing rate is based on target rate before congestion window pushback,</span></span><br><span class="line">  <span class="comment">// because we don&#x27;t want to build queues in the pacer when pushback occurs.</span></span><br><span class="line">  <span class="comment">// 此处的pacing rate使用的是last_loss_based_target_rate_, 这个值没有经过拥塞窗口的更新处理</span></span><br><span class="line">  <span class="comment">// 但是没太看懂注释，&quot;当退避产生的时候不想在pacer创建队列&quot;，因为pacer有两种,一种是有queue的</span></span><br><span class="line">  <span class="comment">// 一种是无queue的，可能想要表达的是congestion push back不应用在有queue的队列上?</span></span><br><span class="line">  DataRate pacing_rate = DataRate::<span class="built_in">Zero</span>();</span><br><span class="line">  <span class="keyword">if</span> (pace_at_max_of_bwe_and_lower_link_capacity_ &amp;&amp; estimate_) &#123;</span><br><span class="line">    pacing_rate =</span><br><span class="line">        std::<span class="built_in">max</span>(&#123;min_total_allocated_bitrate_, estimate_-&gt;link_capacity_lower,</span><br><span class="line">                  last_loss_based_target_rate_&#125;) *</span><br><span class="line">        pacing_factor_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pacing_rate =</span><br><span class="line">        std::<span class="built_in">max</span>(min_total_allocated_bitrate_, last_loss_based_target_rate_) *</span><br><span class="line">        pacing_factor_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// padding_rate 主要的值还是max_padding_rate_，这是一个来自于外部(bitrateAllocation)计算的一个值</span></span><br><span class="line">  <span class="comment">// 其次，它肯定不能大于窗口控制的码率(last_pushback_target_rate_)</span></span><br><span class="line">  DataRate padding_rate =</span><br><span class="line">      (last_loss_base_state_ == LossBasedState::kIncreaseUsingPadding)</span><br><span class="line">          ? std::<span class="built_in">max</span>(max_padding_rate_, last_loss_based_target_rate_)</span><br><span class="line">          : max_padding_rate_;</span><br><span class="line">  padding_rate = std::<span class="built_in">min</span>(padding_rate, last_pushback_target_rate_);</span><br><span class="line">  PacerConfig msg;</span><br><span class="line">  msg.at_time = at_time;</span><br><span class="line">  msg.time_window = TimeDelta::<span class="built_in">Seconds</span>(<span class="number">1</span>);</span><br><span class="line">  msg.data_window = pacing_rate * msg.time_window;</span><br><span class="line">  msg.pad_window = padding_rate * msg.time_window;</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/01/18/Webrtc%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/">https://charstr.github.io/2024/01/18/Webrtc%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/Webrtc/"># Webrtc</a>
                            
                            <a href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"># 拥塞控制</a>
                            
                            <a href="/tags/BWE/"># BWE</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/02/20/Webrtc%E5%BA%94%E7%94%A8%E5%8C%BA%E5%9F%9F%E5%8F%97%E9%99%90%E6%8E%A2%E6%B5%8B/">Webrtc应用区域受限探测</a>
                      
                        
                          <a class="next" rel="next" href="/2024/01/13/TWCC%E6%89%A9%E5%B1%95RTP%E5%92%8CRTCP/">TWCC扩展RTP和RTCP</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>