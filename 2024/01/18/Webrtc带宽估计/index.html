<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc带宽估计 | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!-- 通过连接CDN加载MathJax的js代码 -->
<!-- <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> -->


<!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script> -->

<script type="text/javascript" async
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc带宽估计
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">1月 18, 2024&nbsp;&nbsp;16:37:35</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/Webrtc/">Webrtc</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/BWE/">BWE</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <p>Webrtc M121</p>
<p>webrtc中的部分码控结构，从socket层接收到数据后，到transport解析rtcp包处理得到feedback，通过call将feedback转发到对应sendstream上的rtcp处理模块，最终通过RtpTransportControllerSend将feedback转发到GoogCcNetworkController进行码率预估后，把预估的码率(target bitrate)， 探测策略(probe config), congestion windows给pacer，pacer转发给pacingContrller去使用进行发送码率控制</p>
<p>ProbeBitrateEstimator : 根据feedback计算探测码率，PacingController中会将包按照cluster进行划分，transport-CC报文能得到包所属的cluster以及发送和接收信息，通过发送和接收的数据大小比判断是否到达链路上限从而进行带宽探测</p>
<p>AcknowledgedBitrateEstimator : 估算当前的吞吐量<br>BitrateEstimator :使用滑动窗口 + 卡尔曼滤波计算当前发送吞吐量<br>DelayBasedBwe : 基于延迟预估码率<br>TrendlineEstimator : 使用线性回归计算当前网络拥堵情况<br>AimdRateControl : 通过TrendLine预测出来的网络状态对码率进行aimd方式调整<br>SendSideBandwidthEstimation : 基于丢包计算预估码率，结合延迟预估码率，得到最终的目标码率<br>ProbeController : 探测控制器，通过目标码率判断下次是否探测，探测码率大小<br>CongestionWindowPushbackController : 基于当前的rtt设置一个时间窗口，同时基于当前的码率设置当前时间窗口下的数据量，通过判断当前窗口的使用量，如果使用量过大的时候，降低编码时使用的目标码率，加速窗口消退，减少延迟<br>AlrDetector : 应用(码率)受限检测，检测当前的发送码率是否和目标码率由于编码器等原因相差过大受限了，受限情况下会触发带宽预测过程的特殊处理<br>NetworkStateEstimator 、 NetworkStatePredictor ： 此两者属于待开发类，只是在代码中有，但是还没开发完，没用上.</p>
<p>webrtc编码和发送的过程</p>
<p>webrtc::VideoStreamEncoder::OnFrame<br>  → webrtc::VideoStreamEncoder::MaybeEncodeVideoFrame<br>  → webrtc::VideoStreamEncoder::EncodeVideoFrame<br>  → webrtc::LibvpxVp8Encoder::Encode #1<br>  → webrtc::LibvpxVp8Encoder::GetEncodedPartitions<br>  → webrtc::VideoStreamEncoder::OnEncodedImage<br>  → webrtc::internal::VideoSendStreamImpl::OnEncodedImage<br>  → webrtc::RtpVideoSender::OnEncodedImage<br>  → webrtc::RTPSenderVideo::SendEncodedImage<br>  → webrtc::RTPSenderVideo::SendVideo<br>  → webrtc::RTPSenderVideo::LogAndSendToNetwork<br>  → webrtc::RTPSender::EnqueuePackets<br>  → webrtc::PacedSender::EnqueuePackets<br>  → webrtc::PacingController::EnqueuePacket<br>  → webrtc::PacingController::EnqueuePacketInternal<br>  → webrtc::PacedSender::Process #2<br>  → webrtc::PacingController::ProcessPackets<br>  → webrtc::PacedSender::SendRtpPacket<br>  → webrtc::ModuleRtpRtcpImpl2::TrySendPacket<br>  → webrtc::RtpSenderEgress::SendPacket<br>  → webrtc::RtpSenderEgress::SendPacketToNetwork<br>  → cricket::WebRtcVideoChannel::SendRtp<br>  → cricket::MediaChannel::SendPacket<br>  → cricket::MediaChannel::DoSendPacket<br>  → cricket::VideoChannel::SendPacket<br>  → webrtc::DtlsSrtpTransport::SendRtpPacket #3</p>
<p>这里的编码器是 LibvpxVp8Encoder，但换成其他继承自 webrtc::VideoEncoder 的子类都是可以的，比如 VP9Encoder 或者 H264Encoder。<br>RtpPacket 入队之后，将由 webrtc::ProcessThreadImpl::Process 进行处理，严格意义上已经不算是调用栈了，但读者也可以将其理解为 RtpPacket 的处理流程。<br>从这里开始进入 PeerConnection 发送数据包的流程。</p>
<h1 id="RtpTransportControllerSend类"><a href="#RtpTransportControllerSend类" class="headerlink" title="RtpTransportControllerSend类"></a>RtpTransportControllerSend类</h1><p><code>RtpTransportControllerSend</code>类封装了带宽估计、拥塞控制等相关的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RtpTransportControllerSend</span> <span class="keyword">final</span></span><br><span class="line">    : <span class="keyword">public</span> RtpTransportControllerSendInterface,</span><br><span class="line">      <span class="keyword">public</span> NetworkLinkRtcpObserver,</span><br><span class="line">      <span class="keyword">public</span> TransportFeedbackObserver,</span><br><span class="line">      <span class="keyword">public</span> NetworkStateEstimateObserver &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 发送控制模块，结合带宽估计控制平滑发包</span></span><br><span class="line">  TaskQueuePacedSender pacer_;</span><br><span class="line">  <span class="comment">// 带宽估计码率的回调者，在外部实现一个该类型的类传入来做接收</span></span><br><span class="line">  TargetTransferRateObserver* observer_;</span><br><span class="line">  <span class="comment">// 网络控制模块接口，支持外部实现网络控制部分</span></span><br><span class="line">  NetworkControllerFactoryInterface* <span class="type">const</span> controller_factory_override_;</span><br><span class="line">  <span class="comment">// 反馈数据适配模块</span></span><br><span class="line">  TransportFeedbackAdapter transport_feedback_adapter_;</span><br><span class="line">  <span class="comment">// 拥塞控制事件处理者</span></span><br><span class="line">  std::unique_ptr&lt;CongestionControlHandler&gt; control_handler_;</span><br><span class="line">  <span class="comment">// 网络控制模块</span></span><br><span class="line">  std::unique_ptr&lt;NetworkControllerInterface&gt; controller_;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>std::unique_ptr&lt;NetworkControllerInterface&gt; controller_</code>。</p>
<h1 id="GoogCcNetworkController类"><a href="#GoogCcNetworkController类" class="headerlink" title="GoogCcNetworkController类"></a>GoogCcNetworkController类</h1><p><code>GoogCcNetworkController</code>是带宽估计和调整的核心。在<code>RtpTransportControllerSend::MaybeCreateControllers</code>函数创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::MaybeCreateControllers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 创建GoogCcNetworkController</span></span><br><span class="line">  <span class="keyword">if</span> (controller_factory_override_) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Creating overridden congestion controller&quot;</span>;</span><br><span class="line">    controller_ = controller_factory_override_-&gt;<span class="built_in">Create</span>(initial_config_);</span><br><span class="line">    process_interval_ = controller_factory_override_-&gt;<span class="built_in">GetProcessInterval</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Creating fallback congestion controller&quot;</span>;</span><br><span class="line">    controller_ = controller_factory_fallback_-&gt;<span class="built_in">Create</span>(initial_config_);</span><br><span class="line">    process_interval_ = controller_factory_fallback_-&gt;<span class="built_in">GetProcessInterval</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定时对码率进行检测和更新，并将结果转发给pacer</span></span><br><span class="line">  <span class="built_in">UpdateControllerWithTimeInterval</span>();</span><br><span class="line">  <span class="built_in">StartProcessPeriodicTasks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的部分功能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::UpdateControllerWithTimeInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(controller_);</span><br><span class="line">  ProcessInterval msg;</span><br><span class="line">  msg.at_time = Timestamp::<span class="built_in">Millis</span>(env_.<span class="built_in">clock</span>().<span class="built_in">TimeInMilliseconds</span>());</span><br><span class="line">  <span class="keyword">if</span> (add_pacing_to_cwin_)</span><br><span class="line">    msg.pacer_queue = pacer_.<span class="built_in">QueueSizeData</span>();</span><br><span class="line">  <span class="comment">// 定时对码率进行检测和更新，并将结果转发给pacer</span></span><br><span class="line">  <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnProcessInterval</span>(msg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::StartProcessPeriodicTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// control_handler将GoogCcNetworkController计算的相关码率信息回调给其它模块</span></span><br><span class="line">  <span class="comment">// 调用UpdateControlState</span></span><br><span class="line">  <span class="keyword">if</span> (!pacer_queue_update_task_.<span class="built_in">Running</span>()) &#123;</span><br><span class="line">    pacer_queue_update_task_ = RepeatingTaskHandle::<span class="built_in">DelayedStart</span>(</span><br><span class="line">        task_queue_, kPacerQueueUpdateInterval, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">          <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">          TimeDelta expected_queue_time = pacer_.<span class="built_in">ExpectedQueueTime</span>();</span><br><span class="line">          control_handler_-&gt;<span class="built_in">SetPacerQueue</span>(expected_queue_time);</span><br><span class="line">          <span class="built_in">UpdateControlState</span>();</span><br><span class="line">          <span class="keyword">return</span> kPacerQueueUpdateInterval;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  controller_task_.<span class="built_in">Stop</span>();</span><br><span class="line">  <span class="keyword">if</span> (process_interval_.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 定时任务，定时执行UpdateControllerWithTimeInterval检测更新码率</span></span><br><span class="line">    controller_task_ = RepeatingTaskHandle::<span class="built_in">DelayedStart</span>(</span><br><span class="line">        task_queue_, process_interval_, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">          <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">          <span class="built_in">UpdateControllerWithTimeInterval</span>();</span><br><span class="line">          <span class="keyword">return</span> process_interval_;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时检测更新码率"><a href="#定时检测更新码率" class="headerlink" title="定时检测更新码率"></a>定时检测更新码率</h2><p><code>GoogCcNetworkController::OnProcessInterval</code>会定时触发进行带宽检测和更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnProcessInterval</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ProcessInterval msg)</span> </span>&#123;</span><br><span class="line">  NetworkControlUpdate update;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GoogCcNetworkController构造时候有传进来的初始的配置，</span></span><br><span class="line">  <span class="comment">// 初次调用的时候进行初始化设置，后边不用每次调用</span></span><br><span class="line">  <span class="keyword">if</span> (initial_config_) &#123;</span><br><span class="line">    <span class="comment">// 重设loss_based和delay_based码率探测器和probe的初始码率</span></span><br><span class="line">    <span class="comment">// 设置SendSideBandwidthEstimation、DelayBasedBwe、ProbeController</span></span><br><span class="line">    <span class="comment">// 的码率，返回码率探测簇配置std::vector&lt;ProbeClusterConfig&gt;，</span></span><br><span class="line">    <span class="comment">// 最终给pacing_controller控制发包码率</span></span><br><span class="line">    update.probe_cluster_configs =</span><br><span class="line">        <span class="built_in">ResetConstraints</span>(initial_config_-&gt;constraints);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前pacing 的发送码率、padding、time_windows等配置</span></span><br><span class="line">    update.pacer_config = <span class="built_in">GetPacingRates</span>(msg.at_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用周期性ALR探测，允许因为alr需要快速恢复码率而继续做probe</span></span><br><span class="line">    <span class="keyword">if</span> (initial_config_-&gt;stream_based_config.requests_alr_probing) &#123;</span><br><span class="line">      probe_controller_-&gt;<span class="built_in">EnablePeriodicAlrProbing</span>(</span><br><span class="line">          *initial_config_-&gt;stream_based_config.requests_alr_probing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有设置最大总分配码率，在ProbeController触发相应事件</span></span><br><span class="line">    absl::optional&lt;DataRate&gt; total_bitrate =</span><br><span class="line">        initial_config_-&gt;stream_based_config.max_total_allocated_bitrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total_bitrate) &#123;</span><br><span class="line">      <span class="comment">// 为ProbeController设置最大的分配码率(MaxTotalAllocatedBitrate)作为探测的上限</span></span><br><span class="line">      <span class="comment">// 探测的码率达到这个值就停止探测</span></span><br><span class="line">      <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">OnMaxTotalAllocatedBitrate</span>(</span><br><span class="line">          *total_bitrate, msg.at_time);</span><br><span class="line">      update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                          probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置initial_config_，不需要每次进行初始化设置</span></span><br><span class="line">    initial_config_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新拥塞窗口中的pacing数据长度</span></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; msg.pacer_queue) &#123;</span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdatePacingQueue</span>(</span><br><span class="line">        msg.pacer_queue-&gt;<span class="built_in">bytes</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SendSideBandwidthEstimation基于时间更新码率，其内部是依靠cc-feedback</span></span><br><span class="line">  <span class="comment">// 提供丢包率来预估码率，当没有feedback也会基于时间预估当前的rtt去更新码率</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateEstimate</span>(msg.at_time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ALR的开始时间。从AlrDetector获取当前是否处于Application-Limited Region（ALR）状态</span></span><br><span class="line">  <span class="comment">// AlrDetector每次发送数据时(OnSentPacket)都会检测实际发送码率是否与目标码率相差太多，</span></span><br><span class="line">  <span class="comment">// 从而判断是否(受限于编码器等原因而导致)无法达到目标码率，从而设定处于alr状态</span></span><br><span class="line">  <span class="comment">// 带宽预测的核心是需要向链路中发送足够的包去观察链路情况，</span></span><br><span class="line">  <span class="comment">// 如果探测到处于alr状态无法达到这个要求，就需要一些额外手段去处理。</span></span><br><span class="line">  absl::optional&lt;<span class="type">int64_t</span>&gt; start_time_ms =</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>();</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 在ProbeController设置ALR的开始时间。ProbeController内部已经完成了初始的探测过程，</span></span><br><span class="line">  <span class="comment">// 并且在正常的探测完成后，不再主动进行额外的探测。但当网络处于ALR状态或者网络发生变化时，</span></span><br><span class="line">  <span class="comment">// ProbeController要继续探测以便快恢复码率</span></span><br><span class="line">  probe_controller_-&gt;<span class="built_in">SetAlrStartTimeMs</span>(start_time_ms);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ProbeController获取probe_cluster_config，检测当前是否因alr状态而需要做探测</span></span><br><span class="line">  <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">Process</span>(msg.at_time);</span><br><span class="line">  update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                      probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用拥塞窗口并且反馈最大RTT不为空，更新拥塞窗口大小</span></span><br><span class="line">  <span class="comment">// (CongestionWindowPushbackController)</span></span><br><span class="line">  <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindow</span>() &amp;&amp;</span><br><span class="line">      !feedback_max_rtts_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">UpdateCongestionWindowSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; current_data_window_) &#123;</span><br><span class="line">    <span class="comment">// 设置拥塞控制窗口大小</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">SetDataWindow</span>(</span><br><span class="line">        *current_data_window_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.congestion_window = current_data_window_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bandwidth_estimation_可能对码率进行了更新，</span></span><br><span class="line">  <span class="comment">// 调用MaybeTriggerOnNetworkChanged()对alr，probe_controller中的码率进行更新，</span></span><br><span class="line">  <span class="comment">// 同时将码率，probe_config等放到update中返回</span></span><br><span class="line">  <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, msg.at_time);</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TWCC更新码率"><a href="#TWCC更新码率" class="headerlink" title="TWCC更新码率"></a>TWCC更新码率</h2><p>收到<code>TWCC-feedback</code>包时候也会更新码率。<code>TWCC-feedback</code>包内容参看 <a href="/2024/01/13/TWCC%E6%89%A9%E5%B1%95RTP%E5%92%8CRTCP/" title="TWCC扩展RTP和RTCP">TWCC扩展RTP和RTCP</a>。</p>
<p>TFB-GCC实现的流程可以理解为:<code>SDP协商-&gt;发送端发送RTP报文-&gt;接收端接收RTP报文及并存储信息-&gt;接收端构造Transport-CC RR报文-&gt;发送端解析Transport-CC RR报文-&gt;发送端码率估计</code>。</p>
<p>WebRtc基于transport wide cc 的延迟动态码率估计主要分成四大部分，如下：<br>第一部分、在发送端，当rtp包扩展transport wide cc 协议在发送过程中，当包发送到网络环境过程中的处理和顺利发送到网络环境后的处理，最后作用到GoogCcNetworkController模块。<br>第二部分、接收端接收到带transport wide cc 协议的rtp包后的处理，主要是生成基于transport wide cc 的RTCP报文，并定时将报文发送给发送端。<br>第三部分、发送端收到接收端基于transport wide cc 协议的rtcp 反馈报文，并对其进行解析，解析完成后进行再封装将其作用到GoogCcNetworkController模块。<br>第四部分、GoogCcNetworkController模块基于延迟模型根据transport wide cc feedback进行码率估计。</p>
<h3 id="RTP扩展"><a href="#RTP扩展" class="headerlink" title="RTP扩展"></a>RTP扩展</h3><p>RTP添加的扩展如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0              1                2               3</span><br><span class="line"> 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       0xBE    |    0xDE       |           length=1            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  ID   | L=1   |transport-wide sequence number | zero padding  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>2字节的<code>transport-wide sequence number</code>是传输层序列号，会添加到每个要发送的RTP包，发送端每发送一个RTP包序列号就会累加1。<strong>当发送端发送多路流时，所有流的 RTP 包的该扩展字段都是连续计数的，不会分开独立计数</strong>。该扩展头的作用是为了标识发送的包和反馈的包对应关系，用来进行码率估计；而RTP报文中的序列号是媒体流的序列号，主要用来组帧和抗丢包，同时也用来分离媒体。</p>
<p>Webrtc中调用<code>RTPSender::AllocatePacket</code>函数给RTP包分配内存时，会给RTP扩展预分配内存。若注册了（registered）某个扩展，会对相应的内容进行赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;RtpPacketToSend&gt; <span class="title">RTPSender::AllocatePacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    rtc::ArrayView&lt;<span class="type">const</span> <span class="type">uint32_t</span>&gt; csrcs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span> packet = std::<span class="built_in">make_unique</span>&lt;RtpPacketToSend&gt;(&amp;rtp_header_extension_map_,</span><br><span class="line">                                                  max_packet_size_);</span><br><span class="line">  packet-&gt;<span class="built_in">SetSsrc</span>(ssrc_);</span><br><span class="line">  packet-&gt;<span class="built_in">SetCsrcs</span>(csrcs);</span><br><span class="line">  <span class="comment">// 给扩展预留内存，如果注册了扩展会在 SendToNetwork 中设置 RtpSender</span></span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;AbsoluteSendTime&gt;();</span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;TransmissionOffset&gt;();</span><br><span class="line">  packet-&gt;<span class="built_in">ReserveExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以视频为例，<code>RtpVideoSender</code>构造函数中注册扩展的过程为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">RtpVideoSender::<span class="built_in">RtpVideoSender</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rtp_config_.extensions.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 将rtp_config_中的所有extension设置到stream对应的rtp_rtcp module下</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; extension = rtp_config_.extensions[i].uri;</span><br><span class="line">    <span class="type">int</span> id = rtp_config_.extensions[i].id;</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(RtpExtension::<span class="built_in">IsSupportedForVideo</span>(extension));</span><br><span class="line">    <span class="comment">// rtp_rtcp module注册这些extension到每个流</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> RtpStreamSender&amp; stream : rtp_streams_) &#123;</span><br><span class="line">      <span class="comment">// std::unique_ptr&lt;ModuleRtpRtcpImpl2&gt; rtp_rtcp;</span></span><br><span class="line">      stream.rtp_rtcp-&gt;<span class="built_in">RegisterRtpHeaderExtension</span>(extension, id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModuleRtpRtcpImpl2::RegisterRtpHeaderExtension</span><span class="params">(absl::string_view uri,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将其转发给RTPSender packet_generator进行注册</span></span><br><span class="line">  <span class="type">bool</span> registered =</span><br><span class="line">      rtp_sender_-&gt;packet_generator.<span class="built_in">RegisterRtpHeaderExtension</span>(uri, id);</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(registered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RTPSender::RegisterRtpHeaderExtension</span><span class="params">(absl::string_view uri, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;send_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 注册扩展</span></span><br><span class="line">  <span class="type">bool</span> registered = rtp_header_extension_map_.<span class="built_in">RegisterByUri</span>(id, uri);</span><br><span class="line">  <span class="comment">// 是否启用了所有的BWE相关的RTP扩展决定是否启用padding功能</span></span><br><span class="line">  <span class="comment">// (带宽探测时，当前数据量达不到目标发送码率，用一些历史包或者空数据做带宽填充)</span></span><br><span class="line">  supports_bwe_extension_ = <span class="built_in">HasBweExtension</span>(rtp_header_extension_map_);</span><br><span class="line">  <span class="built_in">UpdateHeaderSizes</span>();</span><br><span class="line">  <span class="keyword">return</span> registered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BWE相关的RTP扩展共有四种</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasBweExtension</span><span class="params">(<span class="type">const</span> RtpHeaderExtensionMap&amp; extensions_map)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransportSequenceNumber) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransportSequenceNumber02) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionAbsoluteSendTime) ||</span><br><span class="line">         extensions_map.<span class="built_in">IsRegistered</span>(kRtpExtensionTransmissionTimeOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// padding需要BWE相关的RTP扩展全部注册启用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RTPSender::SupportsPadding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;send_mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> sending_media_ &amp;&amp; supports_bwe_extension_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDP协商"><a href="#SDP协商" class="headerlink" title="SDP协商"></a>SDP协商</h3><p>视频的<code>AddDefaultFeedbackParams</code>函数和音频的<code>WebRtcVoiceEngine::CollectCodecs</code>函数在收集Feedback Param参数时候的一个函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codec-&gt;<span class="built_in">AddFeedbackParam</span>(<span class="built_in">FeedbackParam</span>(kRtcpFbParamTransportCc, kParamValueEmpty));</span><br></pre></td></tr></table></figure>
<p>启用TWCC需要在SDP数据中添加一条:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br></pre></td></tr></table></figure>
<p>SDP协商过程不变。</p>
<h3 id="发送端构造发送RTP报文"><a href="#发送端构造发送RTP报文" class="headerlink" title="发送端构造发送RTP报文"></a>发送端构造发送RTP报文</h3><p><code>PacketRouter::SendPacket</code>函数会在发送packet之前给TWCC扩展的每个RTP包头设置对应的TransportSequenceNumber，然后进行发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PacketRouter::SendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> PacedPacketInfo&amp; cluster_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 设置RTP包头的TWCC序列号</span></span><br><span class="line">  <span class="type">bool</span> assign_transport_sequence_number =</span><br><span class="line">      packet-&gt;<span class="built_in">HasExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="keyword">if</span> (assign_transport_sequence_number) &#123;</span><br><span class="line">    packet-&gt;<span class="built_in">SetExtension</span>&lt;TransportSequenceNumber&gt;((transport_seq_ + <span class="number">1</span>) &amp;</span><br><span class="line">                                                  <span class="number">0xFFFF</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ssrc = packet-&gt;<span class="built_in">Ssrc</span>();</span><br><span class="line">  <span class="keyword">auto</span> it = send_modules_map_.<span class="built_in">find</span>(ssrc);</span><br><span class="line">  <span class="keyword">if</span> (it == send_modules_map_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Failed to send packet, matching RTP module not found &quot;</span></span><br><span class="line">           <span class="string">&quot;or transport error. SSRC = &quot;</span></span><br><span class="line">        &lt;&lt; packet-&gt;<span class="built_in">Ssrc</span>() &lt;&lt; <span class="string">&quot;, sequence number &quot;</span> &lt;&lt; packet-&gt;<span class="built_in">SequenceNumber</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RtpRtcpInterface* rtp_module = it-&gt;second;</span><br><span class="line">  <span class="comment">// ModuleRtpRtcpImpl2::TrySendPacket尝试发送RTP数据包</span></span><br><span class="line">  <span class="keyword">if</span> (!rtp_module-&gt;<span class="built_in">TrySendPacket</span>(std::<span class="built_in">move</span>(packet), cluster_info)) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Failed to send packet, rejected by RTP module.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  modules_used_in_current_batch_.<span class="built_in">insert</span>(rtp_module);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sending succeeded.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleRtpRtcpImpl2::TrySendPacket</code>用于发送RTP数据包:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ModuleRtpRtcpImpl2::TrySendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(rtp_sender_);</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;rtp_sender_-&gt;sequencing_checker);</span><br><span class="line">  <span class="comment">// 不在发送媒体数据</span></span><br><span class="line">  <span class="keyword">if</span> (!rtp_sender_-&gt;packet_generator.<span class="built_in">SendingMedia</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据包是填充数据，并且SSRC与媒体数据的SSRC相同，但不能在媒体SSRC上发送填充数据</span></span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kPadding &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">Ssrc</span>() == rtp_sender_-&gt;packet_generator.<span class="built_in">SSRC</span>() &amp;&amp;</span><br><span class="line">      !rtp_sender_-&gt;sequencer.<span class="built_in">CanSendPaddingOnMediaSsrc</span>()) &#123;</span><br><span class="line">    <span class="comment">// 新的媒体数据包抢占了这个生成的填充数据包，丢弃它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查是否是FEC数据，并且SSRC与FEC的SSRC相同</span></span><br><span class="line">  <span class="type">bool</span> is_flexfec =</span><br><span class="line">      packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kForwardErrorCorrection &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">Ssrc</span>() == rtp_sender_-&gt;packet_generator.<span class="built_in">FlexfecSsrc</span>();</span><br><span class="line">  <span class="comment">// 如果不是FEC数据，进行序列化</span></span><br><span class="line">  <span class="keyword">if</span> (!is_flexfec) &#123;</span><br><span class="line">    rtp_sender_-&gt;sequencer.<span class="built_in">Sequence</span>(*packet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转发给RtpSenderEgress模块</span></span><br><span class="line">  <span class="comment">// RtpSenderEgress::SendPacket发送数据包</span></span><br><span class="line">  rtp_sender_-&gt;packet_sender.<span class="built_in">SendPacket</span>(std::<span class="built_in">move</span>(packet), pacing_info);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleRtpRtcpImpl2::TrySendPacket</code>会检查是否可以发送媒体数据，以及是否可以在媒体SSRC上发送填充数据，然后进行序列化，并最后发送数据包，最终将<code>RtpPacketToSend packet</code>经过传给<code>RtpSenderEgress::SendPacket</code>函数发送RTP数据包，并处理一些发送前的准备工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::SendPacket</span><span class="params">(std::unique_ptr&lt;RtpPacketToSend&gt; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 创建一个待发送的数据包</span></span><br><span class="line">  <span class="keyword">auto</span> compound_packet = Packet&#123;std::<span class="built_in">move</span>(packet), pacing_info, now&#125;;</span><br><span class="line">  <span class="comment">// 如果启用了数据包批量发送，并且不是音频</span></span><br><span class="line">  <span class="keyword">if</span> (enable_send_packet_batching_ &amp;&amp; !is_audio_) &#123;</span><br><span class="line">    <span class="comment">// 将数据包添加到待发送的数据包列表中，用于Pacing发送</span></span><br><span class="line">    <span class="comment">// 实际在发送时，会在RtpSenderEgress::OnBatchComplete函数中会遍历packets_to_send_</span></span><br><span class="line">    <span class="comment">// 调用CompleteSendPacket函数进行发送</span></span><br><span class="line">    packets_to_send_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(compound_packet));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接发送数据包，会处理TransportSequenceNumber</span></span><br><span class="line">    <span class="built_in">CompleteSendPacket</span>(compound_packet, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpSenderEgress::CompleteSendPacket</code>用于发送数据包:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::CompleteSendPacket</span><span class="params">(<span class="type">const</span> Packet&amp; compound_packet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> last_in_batch)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(worker_queue_);</span><br><span class="line">  <span class="keyword">auto</span>&amp; [packet, pacing_info, now] = compound_packet;</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(packet);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_media = packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kAudio ||</span><br><span class="line">                        packet-&gt;<span class="built_in">packet_type</span>() == RtpPacketMediaType::kVideo;</span><br><span class="line">  <span class="comment">// 数据包的参数</span></span><br><span class="line">  PacketOptions options;</span><br><span class="line">  options.included_in_allocation = force_part_of_allocation_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下游代码实际上使用这个标志来区分媒体和其他所有内容</span></span><br><span class="line">  options.is_retransmit = !is_media;</span><br><span class="line">  <span class="comment">// 提取数据包的TransportSequenceNumber生成feedback包</span></span><br><span class="line">  absl::optional&lt;<span class="type">uint16_t</span>&gt; packet_id =</span><br><span class="line">      packet-&gt;<span class="built_in">GetExtension</span>&lt;TransportSequenceNumber&gt;();</span><br><span class="line">  <span class="comment">//启用了TWCC的扩展</span></span><br><span class="line">  <span class="keyword">if</span> (packet_id.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    options.packet_id = *packet_id;</span><br><span class="line">    options.included_in_feedback = <span class="literal">true</span>;</span><br><span class="line">    options.included_in_allocation = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// AddPacketToTransportFeedback转发给TransportFeedbackObserver模块</span></span><br><span class="line">    <span class="comment">// 将一些信息添加到传输反馈中，用于进行TWCC的反馈？</span></span><br><span class="line">    <span class="built_in">AddPacketToTransportFeedback</span>(*packet_id, *packet, pacing_info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  options.additional_data = packet-&gt;<span class="built_in">additional_data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果数据包不是填充数据或重传数据，并且有发送数据包的观察者，并且有捕获时间</span></span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;<span class="built_in">packet_type</span>() != RtpPacketMediaType::kPadding &amp;&amp;</span><br><span class="line">      packet-&gt;<span class="built_in">packet_type</span>() != RtpPacketMediaType::kRetransmission &amp;&amp;</span><br><span class="line">      send_packet_observer_ != <span class="literal">nullptr</span> &amp;&amp; packet-&gt;<span class="built_in">capture_time</span>().<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 发送数据包</span></span><br><span class="line">    send_packet_observer_-&gt;<span class="built_in">OnSendPacket</span>(packet_id, packet-&gt;<span class="built_in">capture_time</span>(),</span><br><span class="line">                                        packet-&gt;<span class="built_in">Ssrc</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置是否可以批量发送和是否是批量中的最后一个包</span></span><br><span class="line">  options.batchable = enable_send_packet_batching_ &amp;&amp; !is_audio_;</span><br><span class="line">  options.last_packet_in_batch = last_in_batch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往网络发送数据包</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> send_success = <span class="built_in">SendPacketToNetwork</span>(*packet, options, pacing_info);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无论发送是否成功，都将数据包放入重传历史记录或更新待发送状态</span></span><br><span class="line">  <span class="keyword">if</span> (is_media &amp;&amp; packet-&gt;<span class="built_in">allow_retransmission</span>()) &#123;</span><br><span class="line">    packet_history_-&gt;<span class="built_in">PutRtpPacket</span>(std::<span class="built_in">make_unique</span>&lt;RtpPacketToSend&gt;(*packet),</span><br><span class="line">                                  now);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;<span class="built_in">retransmitted_sequence_number</span>()) &#123;</span><br><span class="line">    packet_history_-&gt;<span class="built_in">MarkPacketAsSent</span>(*packet-&gt;<span class="built_in">retransmitted_sequence_number</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送成功</span></span><br><span class="line">  <span class="keyword">if</span> (send_success) &#123;</span><br><span class="line"></span><br><span class="line">    media_has_been_sent_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 更新RTP统计信息</span></span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(packet-&gt;<span class="built_in">packet_type</span>().<span class="built_in">has_value</span>());</span><br><span class="line">    RtpPacketMediaType packet_type = *packet-&gt;<span class="built_in">packet_type</span>();</span><br><span class="line">    <span class="function">RtpPacketCounter <span class="title">counter</span><span class="params">(*packet)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UpdateRtpStats</span>(now, packet-&gt;<span class="built_in">Ssrc</span>(), packet_type, std::<span class="built_in">move</span>(counter),</span><br><span class="line">                   packet-&gt;<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpSenderEgress::AddPacketToTransportFeedback</code>函数构造<code>RtpPacketSendInfo packet_info</code>记录当前RTP报的信息，如Sequence Number、Transport Sequence Number、Packet Size等，其添加到传输反馈中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpSenderEgress::AddPacketToTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> packet_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RtpPacketToSend&amp; packet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacedPacketInfo&amp; pacing_info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传输反馈</span></span><br><span class="line">  <span class="keyword">if</span> (transport_feedback_observer_) &#123;</span><br><span class="line">    <span class="comment">// 构造packet_info，</span></span><br><span class="line">    <span class="comment">// 填充发送的RTP包信息,包括传输序号、RTP时间戳、长度、调度信息等</span></span><br><span class="line">    RtpPacketSendInfo packet_info;</span><br><span class="line">    <span class="comment">// 扩展的sequence_number</span></span><br><span class="line">    packet_info.transport_sequence_number = packet_id;</span><br><span class="line">    packet_info.rtp_timestamp = packet.<span class="built_in">Timestamp</span>();</span><br><span class="line">    packet_info.length = packet.<span class="built_in">size</span>();</span><br><span class="line">    packet_info.pacing_info = pacing_info;</span><br><span class="line">    packet_info.packet_type = packet.<span class="built_in">packet_type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数据包类型设置不同的信息</span></span><br><span class="line">    <span class="keyword">switch</span> (*packet_info.packet_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kAudio:</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kVideo:</span><br><span class="line">        packet_info.media_ssrc = ssrc_;</span><br><span class="line">        packet_info.rtp_sequence_number = packet.<span class="built_in">SequenceNumber</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kRetransmission:</span><br><span class="line">        <span class="comment">// 重传包填充原始媒体包的SSRC和序号</span></span><br><span class="line">        packet_info.media_ssrc = ssrc_;</span><br><span class="line">        packet_info.rtp_sequence_number =</span><br><span class="line">            *packet.<span class="built_in">retransmitted_sequence_number</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kPadding:</span><br><span class="line">      <span class="keyword">case</span> RtpPacketMediaType::kForwardErrorCorrection:</span><br><span class="line">        <span class="comment">// We&#x27;re not interested in feedback about these packets being received</span></span><br><span class="line">        <span class="comment">// or lost.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RtpTransportControllerSend继承TransportFeedbackObserver，</span></span><br><span class="line">    <span class="comment">// 依赖于TransportFeedbackAdapter类。</span></span><br><span class="line">    <span class="comment">// 有数据包要进行发送，transport_feedback_observer_生成数据包。实际调用</span></span><br><span class="line">    <span class="comment">// RtpTransportControllerSend::OnAddPacket函数添加feedback包</span></span><br><span class="line">    transport_feedback_observer_-&gt;<span class="built_in">OnAddPacket</span>(packet_info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::OnAddPacket</code>收到RtpPacketSendInfo反馈，交给<code>TransportFeedbackAdapter</code>模块进行处理:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnAddPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RtpPacketSendInfo&amp; packet_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  Timestamp creation_time =</span><br><span class="line">      Timestamp::<span class="built_in">Millis</span>(env_.<span class="built_in">clock</span>().<span class="built_in">TimeInMilliseconds</span>());</span><br><span class="line">  <span class="comment">// 将数据包添加到反馈解复用器</span></span><br><span class="line">  feedback_demuxer_.<span class="built_in">AddPacket</span>(packet_info);</span><br><span class="line">  <span class="comment">// 给TransportFeedbackAdapter::AddPacket添加feedback</span></span><br><span class="line">  transport_feedback_adapter_.<span class="built_in">AddPacket</span>(</span><br><span class="line">      packet_info, transport_overhead_bytes_per_packet_, creation_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::AddPacket</code>利用<code>RtpSenderEgress::AddPacketToTransportFeedback</code>中创建的<code>RtpPacketSendInfo packet_info</code>创建<code>PacketFeedback packet</code>，然后以 <TransportSequenceNumber,PacketFeedback> 插入到 history<em>容器中。PacketFeedback记录的信息是创建时间、TransportSequenceNumber、待发送的RTP包大小、SSRC等信息，等待feedback的时候计算数据。**history</em> 是TransportFeedbackAdapter类成员变量std::map<int64_t, PacketFeedback> history_**。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransportFeedbackAdapter::AddPacket</span><span class="params">(<span class="type">const</span> RtpPacketSendInfo&amp; packet_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> overhead_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Timestamp creation_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 生成PacketFeedback包</span></span><br><span class="line">  PacketFeedback packet;</span><br><span class="line">  packet.creation_time = creation_time;</span><br><span class="line">  packet.sent.sequence_number =</span><br><span class="line">      seq_num_unwrapper_.<span class="built_in">Unwrap</span>(packet_info.transport_sequence_number);</span><br><span class="line">  packet.sent.size = DataSize::<span class="built_in">Bytes</span>(packet_info.length + overhead_bytes);</span><br><span class="line">  packet.sent.audio = packet_info.packet_type == RtpPacketMediaType::kAudio;</span><br><span class="line">  packet.network_route = network_route_;</span><br><span class="line">  packet.sent.pacing_info = packet_info.pacing_info;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 历史记录中的数据包已经超出了发送时间历史窗口6s就进行删除</span></span><br><span class="line">  <span class="keyword">while</span> (!history_.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">         creation_time - history_.<span class="built_in">begin</span>()-&gt;second.creation_time &gt;</span><br><span class="line">             kSendTimeHistoryWindow) &#123;</span><br><span class="line">    <span class="comment">// TODO(sprang): Warn if erasing (too many) old items?</span></span><br><span class="line">    <span class="keyword">if</span> (history_.<span class="built_in">begin</span>()-&gt;second.sent.sequence_number &gt; last_ack_seq_num_)</span><br><span class="line">      in_flight_.<span class="built_in">RemoveInFlightPacketBytes</span>(history_.<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line">    history_.<span class="built_in">erase</span>(history_.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以transport_sequence_number和PacketFeedback为key-valiue，存入history_中</span></span><br><span class="line">  history_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(packet.sent.sequence_number, packet));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储到history_中已经完成把TWCC扩展的RTP包经过网络发送前的处理流程。</p>
<p><code>SendPacketToNetwork</code>函数通过网络发送RTP数据包。</p>
<h3 id="发送RTP包后的处理"><a href="#发送RTP包后的处理" class="headerlink" title="发送RTP包后的处理"></a>发送RTP包后的处理</h3><p>消息经Call模块，到达worker线程，最终反馈到RtpTransportControllerSend模块，接下来处理已发送的数据包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当一个数据包被发送时，OnSentPacket函数会被调用</span></span><br><span class="line">  <span class="comment">// 通常在网络线程上调用</span></span><br><span class="line">  <span class="comment">// 如果当前线程不是任务队列所在的线程</span></span><br><span class="line">  <span class="keyword">if</span> (TaskQueueBase::<span class="built_in">Current</span>() != task_queue_) &#123;</span><br><span class="line">    <span class="comment">// 在任务队列上异步执行RtpTransportControllerSend::ProcessSentPacket函数</span></span><br><span class="line">    task_queue_-&gt;<span class="built_in">PostTask</span>(<span class="built_in">SafeTask</span>(safety_.<span class="built_in">flag</span>(), [<span class="keyword">this</span>, sent_packet]() &#123;</span><br><span class="line">      <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">      <span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前的任务队列就是task_queue_，直接处理已发送的数据包</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::ProcessSentPacket</code>处理已发送的RTP包:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::ProcessSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// 1. TransportFeedbackAdapter::ProcessSentPacket函数</span></span><br><span class="line">  <span class="comment">// 从发送的报文获取SentPacket消息</span></span><br><span class="line">  absl::optional&lt;SentPacket&gt; packet_msg =</span><br><span class="line">      transport_feedback_adapter_.<span class="built_in">ProcessSentPacket</span>(sent_packet);</span><br><span class="line">  <span class="keyword">if</span> (!packet_msg)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 有反馈信息</span></span><br><span class="line">  <span class="comment">// 获取拥塞状态更新</span></span><br><span class="line">  <span class="keyword">auto</span> congestion_update = <span class="built_in">GetCongestedStateUpdate</span>();</span><br><span class="line">  NetworkControlUpdate control_update;</span><br><span class="line">  <span class="comment">// 发送反馈SentPacket包作用到GoogCcNetworkController模块</span></span><br><span class="line">  <span class="comment">// 2. GoogCcNetworkController::OnSentPacket函数</span></span><br><span class="line">  <span class="keyword">if</span> (controller_)</span><br><span class="line">    control_update = controller_-&gt;<span class="built_in">OnSentPacket</span>(*packet_msg);</span><br><span class="line">  <span class="comment">// 如果没有拥塞状态更新和控制更新，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!congestion_update &amp;&amp; !control_update.<span class="built_in">has_updates</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 3. RtpTransportControllerSend::ProcessSentPacketUpdates 处理发送的数据包更新</span></span><br><span class="line">  <span class="built_in">ProcessSentPacketUpdates</span>(std::<span class="built_in">move</span>(control_update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::ProcessSentPacket</code>主要用于处理已发送的数据包，根据数据包是否被包含在反馈中，以及是否被包含在分配中，来更新数据包的发送时间、在途数据的大小、未跟踪的数据大小等统计信息，最终得到<code>SentPacket</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;SentPacket&gt; <span class="title">TransportFeedbackAdapter::ProcessSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtc::SentPacket&amp; sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> send_time = Timestamp::<span class="built_in">Millis</span>(sent_packet.send_time_ms);</span><br><span class="line">  <span class="comment">// 数据包被包含在反馈中，或者数据包的ID不为-1</span></span><br><span class="line">  <span class="keyword">if</span> (sent_packet.info.included_in_feedback || sent_packet.packet_id != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 数据包的序列号</span></span><br><span class="line">    <span class="type">int64_t</span> unwrapped_seq_num =</span><br><span class="line">        seq_num_unwrapper_.<span class="built_in">Unwrap</span>(sent_packet.packet_id);</span><br><span class="line">    <span class="comment">// 根据已发送包的信息，根据seq number进行查询history_，</span></span><br><span class="line">    <span class="comment">// 查询到后，对里面的数据进行更新，主要是更新其发送时间</span></span><br><span class="line">    <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(unwrapped_seq_num);</span><br><span class="line">    <span class="comment">// 对SentPacket it-&gt;second.sent赋值，主要包含实际发送数据的大小、</span></span><br><span class="line">    <span class="comment">// 发送时间、transport seq number、以及data_in_flight</span></span><br><span class="line">    <span class="keyword">if</span> (it != history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 数据包的发送时间已经被设置，这是一个重传的数据包</span></span><br><span class="line">      <span class="type">bool</span> packet_retransmit = it-&gt;second.sent.send_time.<span class="built_in">IsFinite</span>();</span><br><span class="line">      <span class="comment">// 更新数据包的发送时间</span></span><br><span class="line">      it-&gt;second.sent.send_time = send_time;</span><br><span class="line">      <span class="comment">// 更新最后的发送时间</span></span><br><span class="line">      last_send_time_ = std::<span class="built_in">max</span>(last_send_time_, send_time);</span><br><span class="line">      <span class="comment">// 有未跟踪的数据,加入先前未ACK的数据量</span></span><br><span class="line">      <span class="keyword">if</span> (!pending_untracked_size_.<span class="built_in">IsZero</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_time &lt; last_untracked_send_time_)</span><br><span class="line">          <span class="built_in">RTC_LOG</span>(LS_WARNING)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;appending acknowledged data for out of order packet. (Diff: &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">ToString</span>(last_untracked_send_time_ - send_time) &lt;&lt; <span class="string">&quot; ms.)&quot;</span>;</span><br><span class="line">        it-&gt;second.sent.prior_unacked_data += pending_untracked_size_;</span><br><span class="line">        pending_untracked_size_ = DataSize::<span class="built_in">Zero</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是一个重传的数据包</span></span><br><span class="line">      <span class="keyword">if</span> (!packet_retransmit) &#123;</span><br><span class="line">        <span class="comment">// 数据包的序列号大于最后确认的序列号，添加在途数据包的字节</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second.sent.sequence_number &gt; last_ack_seq_num_)</span><br><span class="line">          <span class="comment">// 将已发送的RTP包中的实际palyload大小记录到in_flight_data_ 的map中，</span></span><br><span class="line">          <span class="comment">// 进行发送字节统计，最终会作用到pacer模块</span></span><br><span class="line">          in_flight_.<span class="built_in">AddInFlightPacketBytes</span>(it-&gt;second);</span><br><span class="line">        <span class="comment">// data_in_flight描述6s的统计窗口内，网络中一共有多少字节的数据在发送</span></span><br><span class="line">        it-&gt;second.sent.data_in_flight = <span class="built_in">GetOutstandingData</span>();</span><br><span class="line">        <span class="comment">// 返回SentPacket信息</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.sent;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sent_packet.info.included_in_allocation) &#123;</span><br><span class="line">    <span class="comment">// 数据包被包含在分配中</span></span><br><span class="line">    <span class="comment">// 忽略序号小于最后发送时间的未跟踪数据</span></span><br><span class="line">    <span class="keyword">if</span> (send_time &lt; last_send_time_) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;ignoring untracked data for out of order packet.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累积未跟踪的数据量</span></span><br><span class="line">    pending_untracked_size_ +=</span><br><span class="line">        DataSize::<span class="built_in">Bytes</span>(sent_packet.info.packet_size_bytes);</span><br><span class="line">    <span class="comment">// 更新最后未跟踪时间</span></span><br><span class="line">    last_untracked_send_time_ = std::<span class="built_in">max</span>(last_untracked_send_time_, send_time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AddInFlightPacketBytes</code>函数在每次发送数据包之后进行大小的累加，将每次发送的多少字节填入到in<em>flight_data</em>容器中，进行发送字节统计，最终会作用到pacer模块。<code>RemoveInFlightPacketBytes</code>函数用于seq number包已经收到接收端发回来的twcc feedback报告后，将对应seq number的包的大小计数从in<em>flight_data</em>容器中移除；同时用于用于<code>TransportFeedbackAdapter::AddPacket</code>函数中移除超时的（6s）的数据包。<br>综上，in<em>flight_data</em>容器描述的最大6s时间窗口内，总共有多少数据正在网络中发送。</p>
<p><code>GoogCcNetworkController::OnSentPacket</code>将发送反馈的SentPacket包作用到GoogCcNetworkController模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnSentPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SentPacket sent_packet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 网络受限会导致会对AlrDetector模块中的受限的起始时间alr_started_time_ms_赋值。</span></span><br><span class="line">  <span class="comment">// 其原理是通过预设的码率和预设的带宽利用率，以及每次发送数据的时间间隔，</span></span><br><span class="line">  <span class="comment">// 然后配合本次实际发送的字节数进行比较，比较预算应该发送多少字节的数据</span></span><br><span class="line">  <span class="comment">// 和实际发送了多少字节的数据的比例，来判断当前发送是否充分利用网络带宽</span></span><br><span class="line">  <span class="comment">// 原理参考 https://www.jianshu.com/p/55e5246f12b9</span></span><br><span class="line">  <span class="comment">// AlrDetector::OnBytesSent回调函数调用，更新发送数据的大小和时间，检测是否处于ALR状态</span></span><br><span class="line">  alr_detector_-&gt;<span class="built_in">OnBytesSent</span>(sent_packet.size.<span class="built_in">bytes</span>(),</span><br><span class="line">                             sent_packet.send_time.<span class="built_in">ms</span>());</span><br><span class="line">  <span class="comment">// 将探测结果设置到该模块，带宽利用率高的情况下，探测结果可能会没有值</span></span><br><span class="line">  acknowledged_bitrate_estimator_-&gt;<span class="built_in">SetAlr</span>(</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>().<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_packet_sent_) &#123;</span><br><span class="line">    first_packet_sent_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始化反馈时间为发送时间，以允许在收到第一个反馈之前估计RTT</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdatePropagationRtt</span>(sent_packet.send_time,</span><br><span class="line">                                                TimeDelta::<span class="built_in">Zero</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录本次发送的包信息，为基于丢包的动态码率估计提供入参信息</span></span><br><span class="line">  <span class="comment">// 基于丢包的带宽估计参考 https://www.jianshu.com/p/a3310e5d3768</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">OnSentPacket</span>(sent_packet);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 更新当前网络中时间有多少值在发送</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateOutstandingData</span>(</span><br><span class="line">        sent_packet.data_in_flight.<span class="built_in">bytes</span>());</span><br><span class="line">    NetworkControlUpdate update;</span><br><span class="line">    <span class="comment">// 可能触发网络变化事件</span></span><br><span class="line">    <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, sent_packet.send_time);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>RtpTransportControllerSend::ProcessSentPacketUpdates</code>进行发包后的更新：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTC_RUN_ON(task_queue_)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::ProcessSentPacketUpdates</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkControlUpdate updates)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line">  <span class="comment">// 更新拥塞状态</span></span><br><span class="line">  <span class="built_in">UpdateCongestedState</span>();</span><br><span class="line">  <span class="keyword">if</span> (controller_) &#123;</span><br><span class="line">    <span class="comment">// 如果存在controller_，则会进行码率的更新</span></span><br><span class="line">    <span class="built_in">PostUpdates</span>(std::<span class="built_in">move</span>(updates));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有在以下情况下更新未完成的数据：</span></span><br><span class="line">  <span class="comment">// 1. 使用了数据包反馈。</span></span><br><span class="line">  <span class="comment">// 2. 数据包尚未收到确认。</span></span><br><span class="line">  <span class="comment">// 3. 不是先前数据包的重传。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::UpdateCongestedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断网络是否拥塞并设置拥塞状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> update = <span class="built_in">GetCongestedStateUpdate</span>()) &#123;</span><br><span class="line">    is_congested_ = update.<span class="built_in">value</span>();</span><br><span class="line">    pacer_.<span class="built_in">SetCongested</span>(update.<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::optional&lt;<span class="type">bool</span>&gt; <span class="title">RtpTransportControllerSend::GetCongestedStateUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据当前网络中实际在发送的数据大小和拥塞窗口上限做比较，发生拥塞则会取消本次发送</span></span><br><span class="line">  <span class="comment">// congestion_window_size_是GoogCcNetworkController带宽估计得到的网络拥塞窗口上限，</span></span><br><span class="line">  <span class="comment">// 通过RtpTransportControllerSend::PostUpdates()函数配置到pacer模块</span></span><br><span class="line">  <span class="type">bool</span> congested = transport_feedback_adapter_.<span class="built_in">GetOutstandingData</span>() &gt;=</span><br><span class="line">                   congestion_window_size_;</span><br><span class="line">  <span class="keyword">if</span> (congested != is_congested_)</span><br><span class="line">    <span class="keyword">return</span> congested;</span><br><span class="line">  <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="接收端接收解析RTP报文"><a href="#接收端接收解析RTP报文" class="headerlink" title="接收端接收解析RTP报文"></a>接收端接收解析RTP报文</h3><h3 id="接收端构造发送RTCP报文"><a href="#接收端构造发送RTCP报文" class="headerlink" title="接收端构造发送RTCP报文"></a>接收端构造发送RTCP报文</h3><p>接收端接收到带TWCC协议的rtp包后的处理，主要是生成基于TWCC的RTCP报文，并定时将报文发送给发送端。</p>
<p><strong>接收端</strong>在<code>ReceiveSideCongestionController::OnReceivedPacket</code>函数中根据RTP包是否有<code>transport-wide sequence number</code>判断是否是 REMB-GCC 还是 TFB-GCC。有序列号，会在RemoteEstimatorProxy中处理RTP包的到达时间，构造Transport-cc报文，反馈给发送端。大概函数调用流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReceiveSideCongestionController::OnReceivedPacket</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::IncomingPacket</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::Process</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::SendPeriodicFeedbacks</span><br><span class="line">             ↓</span><br><span class="line">RemoteEstimatorProxy::BuildFeedbackPacket</span><br></pre></td></tr></table></figure>
<p><code>PacketArrivalTimeMap::AddPacket</code>函数记录RTP包到达的时间，存到 <sequence_number, arrival_time> 的映射队列。<code>RemoteEstimatorProxy</code>是进行Sendside-BWE在接收端的代理类，其中的<code>Process</code>函数以100ms为发送周期发送TransportCC报文</p>
<p>RemoteEstimatorProxy::IncomingPacket中，如果RTP包带有TransportSequenceNumber扩展，会记录该RTP包的到达时间，然后添加到构造的Transport-cc报文中。</p>
<p>发送周期会根据当前码率动态调整，其取值范围在[50ms, 250ms]之间，其本身可用的发送码率为当前可用码率的5%。</p>
<p>周期发送RTCP包的函数调用为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RemoteEstimatorProxy::Process</span><br><span class="line">-&gt;RemoteEstimatorProxy::SendPeriodicFeedbacks</span><br><span class="line">-&gt;RemoteEstimatorProxy::MaybeBuildFeedbackPacket</span><br><span class="line">-&gt;TransportFeedback::AddReceivedPacket</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="发送端接收解析RTCP报文"><a href="#发送端接收解析RTCP报文" class="headerlink" title="发送端接收解析RTCP报文"></a>发送端接收解析RTCP报文</h3><p>发送端收到接收端基于TWCC协议的rtcp 反馈报文会传给RTCPReceiver，并进行解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::IncomingPacket</span><span class="params">(rtc::ArrayView&lt;<span class="type">const</span> <span class="type">uint8_t</span>&gt; packet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (packet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Incoming empty RTCP packet&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PacketInformation packet_information;</span><br><span class="line">  <span class="comment">// RTCPReceiver::ParseCompoundPacket解析rtcp报文，再封装成PacketInformation</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseCompoundPacket</span>(packet, &amp;packet_information))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 转发给RtpTransportControllerSend，接着作用到GoogCcNetworkController模块</span></span><br><span class="line">  <span class="built_in">TriggerCallbacksFromRtcpPacket</span>(packet_information);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RTCPReceiver::TriggerCallbacksFromRtcpPacket</code>将解析出来的transport_feedback转发到RtpTransportControllerSend：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RTCPReceiver::TriggerCallbacksFromRtcpPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketInformation&amp; packet_information)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (network_link_rtcp_observer_) &#123;</span><br><span class="line">    Timestamp now = clock_-&gt;<span class="built_in">CurrentTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (packet_information.packet_type_flags &amp; kRtcpRemb) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReceiverEstimatedMaxBitrate</span>(</span><br><span class="line">          now, DataRate::<span class="built_in">BitsPerSec</span>(</span><br><span class="line">                   packet_information.receiver_estimated_max_bitrate_bps));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!packet_information.report_block_datas.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnReport</span>(</span><br><span class="line">          now, packet_information.report_block_datas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packet_information.rtt.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnRttUpdate</span>(now, *packet_information.rtt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packet_information.transport_feedback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 将包转给RtpTransportControllerSend::OnTransportFeedback处理</span></span><br><span class="line">      network_link_rtcp_observer_-&gt;<span class="built_in">OnTransportFeedback</span>(</span><br><span class="line">          now, *packet_information.transport_feedback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RtpTransportControllerSend::OnTransportFeedback解析得到feedback_msg:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RtpTransportControllerSend::OnTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp receive_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_RUN_ON</span>(&amp;sequence_checker_);</span><br><span class="line"></span><br><span class="line">  feedback_demuxer_.<span class="built_in">OnTransportFeedback</span>(feedback);</span><br><span class="line">  <span class="comment">// 从封装的PacketInformation中的TransportFeedback提取反馈包TWCC Feedback</span></span><br><span class="line">  <span class="comment">//  作用到GoogCcNetworkController模块</span></span><br><span class="line">  absl::optional&lt;TransportPacketsFeedback&gt; feedback_msg =</span><br><span class="line">      transport_feedback_adapter_.<span class="built_in">ProcessTransportFeedback</span>(feedback,</span><br><span class="line">                                                           receive_time);</span><br><span class="line">  <span class="comment">// 将TWCC Feedback交给GoogCcNetworkController，</span></span><br><span class="line">  <span class="comment">// GoogCcNetworkController::OnTransportPacketsFeedback估算最终的码率并进一步probe    </span></span><br><span class="line">  <span class="keyword">if</span> (feedback_msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (controller_)</span><br><span class="line">    ，解析完成后进行再封装将其作用到GoogCcNetworkController模块。</span><br><span class="line">      <span class="comment">// 基于延时梯度进行带宽预估，并处理传输的反馈以更新控制器的状态</span></span><br><span class="line">      <span class="comment">// GoogCcNetworkController::OnTransportPacketsFeedback</span></span><br><span class="line">      <span class="built_in">PostUpdates</span>(controller_-&gt;<span class="built_in">OnTransportPacketsFeedback</span>(*feedback_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有在任何数据包第一次被确认时才更新未完成的数据</span></span><br><span class="line">    <span class="built_in">UpdateCongestedState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransportFeedbackAdapter::ProcessTransportFeedback</code>解析接收到TransportFeedback包的得到feedback_msg TWCC Feedback信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;TransportPacketsFeedback&gt;</span></span><br><span class="line"><span class="function"><span class="title">TransportFeedbackAdapter::ProcessTransportFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp feedback_receive_time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (feedback.<span class="built_in">GetPacketStatusCount</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Empty transport feedback packet received.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TransportPacketsFeedback msg;</span><br><span class="line">  msg.feedback_time = feedback_receive_time;</span><br><span class="line"></span><br><span class="line">  msg.prior_in_flight = in_flight_.<span class="built_in">GetOutstandingData</span>(network_route_);</span><br><span class="line">  <span class="comment">// feedback packet 再赋值</span></span><br><span class="line">  msg.packet_feedbacks =</span><br><span class="line">      <span class="built_in">ProcessTransportFeedbackInner</span>(feedback, feedback_receive_time);</span><br><span class="line">  <span class="keyword">if</span> (msg.packet_feedbacks.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(last_ack_seq_num_);</span><br><span class="line">  <span class="keyword">if</span> (it != history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    msg.first_unacked_send_time = it-&gt;second.sent.send_time;</span><br><span class="line">  &#125;</span><br><span class="line">  msg.data_in_flight = in_flight_.<span class="built_in">GetOutstandingData</span>(network_route_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packet_feedbacks 通过调用ProcessTransportFeedbackInner生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;PacketResult&gt;</span></span><br><span class="line"><span class="function"><span class="title">TransportFeedbackAdapter::ProcessTransportFeedbackInner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rtcp::TransportFeedback&amp; feedback,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp feedback_receive_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里把第一个收到cc-feedback的时刻(feedback_receive_time)作为最初基准时间偏移(current_offset_)，</span></span><br><span class="line">  <span class="comment">// 在后续的cc-feedback报文到达后，计算之前cc-feedback的feedback_receive_time和当前的delta，</span></span><br><span class="line">  <span class="comment">// 累加到current_offset _上作为后续的基础时间偏移，根据注释所言，是为了能够更好的检视包的到达时间。</span></span><br><span class="line">  <span class="keyword">if</span> (last_timestamp_.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">    current_offset_ = feedback_receive_time;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算当前的Base time和之前的Base time的差</span></span><br><span class="line">    <span class="type">const</span> TimeDelta delta = feedback.<span class="built_in">GetBaseDelta</span>(last_timestamp_)</span><br><span class="line">                                .<span class="built_in">RoundDownTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Protect against assigning current_offset_ negative value.</span></span><br><span class="line">    <span class="keyword">if</span> (delta &lt; Timestamp::<span class="built_in">Zero</span>() - current_offset_) &#123;</span><br><span class="line">      <span class="comment">// current_offset_负数情况下，直接将current_offset_置为feedback_receive_time</span></span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Unexpected feedback timestamp received.&quot;</span>;</span><br><span class="line">      current_offset_ = feedback_receive_time;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// current_offset 正常，则直接等于即可</span></span><br><span class="line">      current_offset_ += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last_timestamp_ = feedback.<span class="built_in">BaseTime</span>();</span><br><span class="line"></span><br><span class="line">  std::vector&lt;PacketResult&gt; packet_result_vector;</span><br><span class="line">  packet_result_vector.<span class="built_in">reserve</span>(feedback.<span class="built_in">GetPacketStatusCount</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> failed_lookups = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> ignored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  feedback.<span class="built_in">ForAllPackets</span>(</span><br><span class="line">      [&amp;](<span class="type">uint16_t</span> sequence_number, TimeDelta delta_since_base) &#123;</span><br><span class="line">        <span class="type">int64_t</span> seq_num = seq_num_unwrapper_.<span class="built_in">Unwrap</span>(sequence_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seq_num &gt; last_ack_seq_num_) &#123;</span><br><span class="line">          <span class="comment">// Starts at history_.begin() if last_ack_seq_num_ &lt; 0, since any</span></span><br><span class="line">          <span class="comment">// valid sequence number is &gt;= 0.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> it = history_.<span class="built_in">upper_bound</span>(last_ack_seq_num_);</span><br><span class="line">               it != history_.<span class="built_in">upper_bound</span>(seq_num); ++it) &#123;</span><br><span class="line">            in_flight_.<span class="built_in">RemoveInFlightPacketBytes</span>(it-&gt;second);</span><br><span class="line">          &#125;</span><br><span class="line">          last_ack_seq_num_ = seq_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据transport seqnumber将packet从history_获取出来，然后对其接收时间和接收状态的再赋值</span></span><br><span class="line">        <span class="keyword">auto</span> it = history_.<span class="built_in">find</span>(seq_num);</span><br><span class="line">        <span class="keyword">if</span> (it == history_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          ++failed_lookups;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second.sent.send_time.<span class="built_in">IsInfinite</span>()) &#123;</span><br><span class="line">          <span class="comment">// TODO(srte): Fix the tests that makes this happen and make this a</span></span><br><span class="line">          <span class="comment">// DCHECK.</span></span><br><span class="line">          <span class="built_in">RTC_DLOG</span>(LS_ERROR)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;Received feedback before packet was indicated as sent&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PacketFeedback packet_feedback = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (delta_since_base.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">          packet_feedback.receive_time =</span><br><span class="line">              current_offset_ +</span><br><span class="line">              delta_since_base.<span class="built_in">RoundDownTo</span>(TimeDelta::<span class="built_in">Millis</span>(<span class="number">1</span>));</span><br><span class="line">          <span class="comment">// Note: Lost packets are not removed from history because they might</span></span><br><span class="line">          <span class="comment">// be reported as received by a later feedback.</span></span><br><span class="line">          history_.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (packet_feedback.network_route == network_route_) &#123;</span><br><span class="line">          PacketResult result;</span><br><span class="line">          result.sent_packet = packet_feedback.sent;</span><br><span class="line">          result.receive_time = packet_feedback.receive_time;</span><br><span class="line">          packet_result_vector.<span class="built_in">push_back</span>(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++ignored;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failed_lookups &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_WARNING) &lt;&lt; <span class="string">&quot;Failed to lookup send time for &quot;</span> &lt;&lt; failed_lookups</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; packet&quot;</span> &lt;&lt; (failed_lookups &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">                        &lt;&lt; <span class="string">&quot;. Send time history too small?&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ignored &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Ignoring &quot;</span> &lt;&lt; ignored</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; packets because they were sent on a different route.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> packet_result_vector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>feedback_msg用于进行BWE。</p>
<p>分成左右两边，右边是生成feedback packet的过程，最初由RTPSenderVideo注册cc-extension到RTPSender, RTPSender支持cc-extension后支持PacingController的padding，并生成带有TransportSequenceNumber的包，转发到PacketRouter后设置TransportSequenceNumber, 在网络发送的过程中，经由RTPSenderEgress 将包的信息传到RTPTransportController，让其调用TransportFeedbackAdapter生成feedback packet; </p>
<p>RTCPReceiver收到cc-feedback后解析生成transport-feedback，交给RTPTransportController对feedback packet进行再更新，将最终的feedback packet交给cc-controller中，用于带宽预估。</p>
<h3 id="发送端码率估计"><a href="#发送端码率估计" class="headerlink" title="发送端码率估计"></a>发送端码率估计</h3><p><code>GoogCcNetworkController::OnTransportPacketsFeedback</code>通过TWCC feedback进行码率估计并进一步探测。函数中会调用<code>DelayBasedBwe::IncomingPacketFeedbackVector</code>以此为起点根据反馈信息预估网络的状态，分析延时梯度变化，做trendline，再调用<code>DelayBasedBwe::MaybeUpdateEstimate</code>调整码率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkControlUpdate <span class="title">GoogCcNetworkController::OnTransportPacketsFeedback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TransportPacketsFeedback report)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果反馈中没有数据包，返回一个空的网络控制更新</span></span><br><span class="line">  <span class="keyword">if</span> (report.packet_feedbacks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// TODO(bugs.webrtc.org/10125): Design a better mechanism to safe-guard</span></span><br><span class="line">    <span class="comment">// against building very large network queues.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NetworkControlUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 更新发送数据的大小</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateOutstandingData</span>(</span><br><span class="line">        report.data_in_flight.<span class="built_in">bytes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化最大反馈RTT、最小传播RTT和最大接收时间</span></span><br><span class="line">  TimeDelta max_feedback_rtt = TimeDelta::<span class="built_in">MinusInfinity</span>();</span><br><span class="line">  TimeDelta min_propagation_rtt = TimeDelta::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">  Timestamp max_recv_time = Timestamp::<span class="built_in">MinusInfinity</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取已接收的数据包的反馈</span></span><br><span class="line">  std::vector&lt;PacketResult&gt; feedbacks = report.<span class="built_in">ReceivedWithSendInfo</span>();</span><br><span class="line">  <span class="comment">// 遍历获取最大的包到达时间(feedback.receive_time)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : feedbacks)</span><br><span class="line">    max_recv_time = std::<span class="built_in">max</span>(max_recv_time, feedback.receive_time);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : feedbacks) &#123;</span><br><span class="line">    TimeDelta feedback_rtt =</span><br><span class="line">        report.feedback_time - feedback.sent_packet.send_time;</span><br><span class="line">    TimeDelta min_pending_time = max_recv_time - feedback.receive_time;</span><br><span class="line">    TimeDelta propagation_rtt = feedback_rtt - min_pending_time;</span><br><span class="line">    <span class="comment">// 计算最大反馈RTT，包发出去到收到feed包</span></span><br><span class="line">    max_feedback_rtt = std::<span class="built_in">max</span>(max_feedback_rtt, feedback_rtt);</span><br><span class="line">    <span class="comment">// 和最小传播RTT，包在网络中传输的rtt，不包含在服务端pending处理的时间</span></span><br><span class="line">    min_propagation_rtt = std::<span class="built_in">min</span>(min_propagation_rtt, propagation_rtt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max_feedback_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    feedback_max_rtts_.<span class="built_in">push_back</span>(max_feedback_rtt.<span class="built_in">ms</span>());</span><br><span class="line">    <span class="comment">// 维护窗口大小32的最大反馈RTT</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxFeedbackRttWindow = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (feedback_max_rtts_.<span class="built_in">size</span>() &gt; kMaxFeedbackRttWindow)</span><br><span class="line">      feedback_max_rtts_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 更新传播RTT</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdatePropagationRtt</span>(report.feedback_time,</span><br><span class="line">                                                min_propagation_rtt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只使用数据包反馈，更新loss和delay估计的rtt</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback_only_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!feedback_max_rtts_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算32大小的窗口内最大反馈RTT的均值</span></span><br><span class="line">      <span class="type">int64_t</span> sum_rtt_ms =</span><br><span class="line">          std::<span class="built_in">accumulate</span>(feedback_max_rtts_.<span class="built_in">begin</span>(), feedback_max_rtts_.<span class="built_in">end</span>(),</span><br><span class="line">                          <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">      <span class="type">int64_t</span> mean_rtt_ms = sum_rtt_ms / feedback_max_rtts_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最大反馈RTT的均值更新基于延迟的BWE的码率估计器中的RTT</span></span><br><span class="line">      <span class="keyword">if</span> (delay_based_bwe_)</span><br><span class="line">        delay_based_bwe_-&gt;<span class="built_in">OnRttUpdate</span>(TimeDelta::<span class="built_in">Millis</span>(mean_rtt_ms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小反馈RTT</span></span><br><span class="line">    TimeDelta feedback_min_rtt = TimeDelta::<span class="built_in">PlusInfinity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : feedbacks) &#123;</span><br><span class="line">      TimeDelta pending_time = max_recv_time - packet_feedback.receive_time;</span><br><span class="line">      TimeDelta rtt = report.feedback_time -</span><br><span class="line">                      packet_feedback.sent_packet.send_time - pending_time;</span><br><span class="line">      <span class="comment">// Value used for predicting NACK round trip time in FEC controller.</span></span><br><span class="line">      feedback_min_rtt = std::<span class="built_in">min</span>(rtt, feedback_min_rtt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小反馈RTT</span></span><br><span class="line">    <span class="keyword">if</span> (feedback_min_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">UpdateRtt</span>(feedback_min_rtt, report.feedback_time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-----------更新丢包率---------*/</span></span><br><span class="line">    <span class="comment">// 上次更新丢包后到现在应该收到的包的总数</span></span><br><span class="line">    expected_packets_since_last_loss_update_ +=</span><br><span class="line">        report.<span class="built_in">PacketsWithFeedback</span>().<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//计算丢包数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; packet_feedback : report.<span class="built_in">PacketsWithFeedback</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!packet_feedback.<span class="built_in">IsReceived</span>())</span><br><span class="line">        lost_packets_since_last_loss_update_ += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next_loss_update_是更新丢包的时间点</span></span><br><span class="line">    <span class="keyword">if</span> (report.feedback_time &gt; next_loss_update_) &#123;</span><br><span class="line">      <span class="comment">// 更新下一次更新丢包率的时间戳 kLossUpdateInterval=1s</span></span><br><span class="line">      next_loss_update_ = report.feedback_time + kLossUpdateInterval;</span><br><span class="line">      <span class="comment">// 计算丢包并更新到BWE模块</span></span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">UpdatePacketsLost</span>(</span><br><span class="line">          lost_packets_since_last_loss_update_,</span><br><span class="line">          expected_packets_since_last_loss_update_, report.feedback_time);</span><br><span class="line">      <span class="comment">// 重置丢包参数统计</span></span><br><span class="line">      expected_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">      lost_packets_since_last_loss_update_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测当前是否处于alr</span></span><br><span class="line">  absl::optional&lt;<span class="type">int64_t</span>&gt; alr_start_time =</span><br><span class="line">      alr_detector_-&gt;<span class="built_in">GetApplicationLimitedRegionStartTime</span>();</span><br><span class="line">  <span class="comment">// 之前处于alr但是当前不在alr状态</span></span><br><span class="line">  <span class="keyword">if</span> (previously_in_alr_ &amp;&amp; !alr_start_time.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="type">int64_t</span> now_ms = report.feedback_time.<span class="built_in">ms</span>();</span><br><span class="line">    <span class="comment">// 告知acknowledged_bitrate_estimator_和probe_controller alr的结束时间</span></span><br><span class="line">    acknowledged_bitrate_estimator_-&gt;<span class="built_in">SetAlrEndedTime</span>(report.feedback_time);</span><br><span class="line">    probe_controller_-&gt;<span class="built_in">SetAlrEndedTimeMs</span>(now_ms);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新alr状态</span></span><br><span class="line">  previously_in_alr_ = alr_start_time.<span class="built_in">has_value</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据feedback计算接收端吞吐量</span></span><br><span class="line">  acknowledged_bitrate_estimator_-&gt;<span class="built_in">IncomingPacketFeedbackVector</span>(</span><br><span class="line">      report.<span class="built_in">SortedByReceiveTime</span>());</span><br><span class="line">  <span class="keyword">auto</span> acknowledged_bitrate = acknowledged_bitrate_estimator_-&gt;<span class="built_in">bitrate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其设置到bandwidth_estimation_中去更新链路容量(link_capacity)</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">SetAcknowledgedRate</span>(acknowledged_bitrate,</span><br><span class="line">                                             report.feedback_time);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*------------码率探测-------------*/</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feedback : report.<span class="built_in">SortedByReceiveTime</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (feedback.sent_packet.pacing_info.probe_cluster_id !=</span><br><span class="line">        PacedPacketInfo::kNotAProbe) &#123;</span><br><span class="line">      <span class="comment">// probe_estimator 根据返回的feedback更新带宽探测的计算</span></span><br><span class="line">      probe_bitrate_estimator_-&gt;<span class="built_in">HandleProbeAndEstimateBitrate</span>(feedback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (network_estimator_) &#123;</span><br><span class="line">    network_estimator_-&gt;<span class="built_in">OnTransportPacketsFeedback</span>(report);</span><br><span class="line">    <span class="keyword">auto</span> prev_estimate = estimate_;</span><br><span class="line">    estimate_ = network_estimator_-&gt;<span class="built_in">GetCurrentEstimate</span>();</span><br><span class="line">    <span class="comment">// TODO(srte): Make OnTransportPacketsFeedback signal whether the state</span></span><br><span class="line">    <span class="comment">// changed to avoid the need for this check.</span></span><br><span class="line">    <span class="keyword">if</span> (estimate_ &amp;&amp; (!prev_estimate || estimate_-&gt;last_feed_time !=</span><br><span class="line">                                            prev_estimate-&gt;last_feed_time)) &#123;</span><br><span class="line">      event_log_-&gt;<span class="built_in">Log</span>(std::<span class="built_in">make_unique</span>&lt;RtcEventRemoteEstimate&gt;(</span><br><span class="line">          estimate_-&gt;link_capacity_lower, estimate_-&gt;link_capacity_upper));</span><br><span class="line">      probe_controller_-&gt;<span class="built_in">SetNetworkStateEstimate</span>(*estimate_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取上面循环更新probe_estimator的最终的结果</span></span><br><span class="line">  absl::optional&lt;DataRate&gt; probe_bitrate =</span><br><span class="line">      probe_bitrate_estimator_-&gt;<span class="built_in">FetchAndResetLastEstimatedBitrate</span>();</span><br><span class="line">  <span class="comment">// 如果enable probe &lt; network_estimate时 忽略probe的特性，则忽略probe_bitrate</span></span><br><span class="line">  <span class="keyword">if</span> (ignore_probes_lower_than_network_estimate_ &amp;&amp; probe_bitrate &amp;&amp;</span><br><span class="line">      estimate_ &amp;&amp; *probe_bitrate &lt; delay_based_bwe_-&gt;<span class="built_in">last_estimate</span>() &amp;&amp;</span><br><span class="line">      *probe_bitrate &lt; estimate_-&gt;link_capacity_lower) &#123;</span><br><span class="line">    probe_bitrate.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果enable</span></span><br><span class="line">  <span class="comment">// 将probe略小于throughput_estimate_(预估吞吐量)的特性</span></span><br><span class="line">  <span class="comment">// 对probe现在acknowledged_bitrate(链路吞吐量)下</span></span><br><span class="line">  <span class="keyword">if</span> (limit_probes_lower_than_throughput_estimate_ &amp;&amp; probe_bitrate &amp;&amp;</span><br><span class="line">      acknowledged_bitrate) &#123;</span><br><span class="line">    DataRate limit =</span><br><span class="line">        std::<span class="built_in">min</span>(delay_based_bwe_-&gt;<span class="built_in">last_estimate</span>(),</span><br><span class="line">                 *acknowledged_bitrate * kProbeDropThroughputFraction);</span><br><span class="line">    probe_bitrate = std::<span class="built_in">max</span>(*probe_bitrate, limit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NetworkControlUpdate update;</span><br><span class="line">  <span class="type">bool</span> recovered_from_overuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用feedback进行基于延迟的码率估计</span></span><br><span class="line">  DelayBasedBwe::Result result;</span><br><span class="line">  result = delay_based_bwe_-&gt;<span class="built_in">IncomingPacketFeedbackVector</span>(</span><br><span class="line">      report, acknowledged_bitrate, probe_bitrate, estimate_,</span><br><span class="line">      alr_start_time.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于延迟的预估码率更新了</span></span><br><span class="line">  <span class="keyword">if</span> (result.updated) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result.probe) &#123;</span><br><span class="line">      <span class="comment">// bwe使用了探测码率进行重设</span></span><br><span class="line">      <span class="comment">// bandwidth_estimation_也进行重设sendbitrate</span></span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">SetSendBitrate</span>(result.target_bitrate,</span><br><span class="line">                                            report.feedback_time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新bandwidth_estimation_中基于延迟的估计码率</span></span><br><span class="line">    bandwidth_estimation_-&gt;<span class="built_in">UpdateDelayBasedEstimate</span>(report.feedback_time,</span><br><span class="line">                                                    result.target_bitrate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新基于延迟的带宽估计</span></span><br><span class="line">  bandwidth_estimation_-&gt;<span class="built_in">UpdateLossBasedEstimator</span>(</span><br><span class="line">      report, result.delay_detector_state, probe_bitrate,</span><br><span class="line">      alr_start_time.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result.updated) &#123;</span><br><span class="line">    <span class="comment">// 码率发生变化，将新码率设置到probe_controller, alr_detector等，</span></span><br><span class="line">    <span class="comment">// 并作用给pacing_controller使用</span></span><br><span class="line">    <span class="built_in">MaybeTriggerOnNetworkChanged</span>(&amp;update, report.feedback_time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  recovered_from_overuse = result.recovered_from_overuse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (recovered_from_overuse) &#123;</span><br><span class="line">    <span class="comment">// 从overuse中恢复了，重设alr开始时间</span></span><br><span class="line">    probe_controller_-&gt;<span class="built_in">SetAlrStartTimeMs</span>(alr_start_time);</span><br><span class="line">    <span class="comment">// 获取接下来要做带宽探测的参数，放到update中</span></span><br><span class="line">    <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">RequestProbe</span>(report.feedback_time);</span><br><span class="line">    <span class="comment">// 添加探测到网络控制更新中</span></span><br><span class="line">    update.probe_cluster_configs.<span class="built_in">insert</span>(update.probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                        probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大反馈RTT是有限的</span></span><br><span class="line">  <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindow</span>() &amp;&amp;</span><br><span class="line">      max_feedback_rtt.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 根据码率和RTT更新拥塞窗口的大小更新拥塞窗口大小</span></span><br><span class="line">    <span class="built_in">UpdateCongestionWindowSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将拥塞窗口大小设置到congestion_window_pushback_controller</span></span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_ &amp;&amp; current_data_window_) &#123;</span><br><span class="line">    <span class="comment">// 如果有congestion_window_pushback_controller_，将当前的窗口放在通知器下回推给编码器</span></span><br><span class="line">    congestion_window_pushback_controller_-&gt;<span class="built_in">SetDataWindow</span>(</span><br><span class="line">        *current_data_window_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，直接放在结果中</span></span><br><span class="line">    update.congestion_window = current_data_window_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>feedback time计算如下:</p>
<p><img src="feedback-time-calc.png" alt="feedback时间计算" style="zoom:27%;" /></p>
<h3 id="更新网络状态"><a href="#更新网络状态" class="headerlink" title="更新网络状态"></a>更新网络状态</h3><p><code>MaybeTriggerOnNetworkChanged</code>是在码率发生变化后，将新码率设置到probe_controller, alr_detector等，并作用给pacing_controller使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoogCcNetworkController::MaybeTriggerOnNetworkChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkControlUpdate* update,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从BWE获取丢包率、RTT、码率、状态信息</span></span><br><span class="line">  <span class="type">uint8_t</span> fraction_loss = bandwidth_estimation_-&gt;<span class="built_in">fraction_loss</span>();</span><br><span class="line">  TimeDelta round_trip_time = bandwidth_estimation_-&gt;<span class="built_in">round_trip_time</span>();</span><br><span class="line">  DataRate loss_based_target_rate = bandwidth_estimation_-&gt;<span class="built_in">target_rate</span>();</span><br><span class="line">  LossBasedState loss_based_state = bandwidth_estimation_-&gt;<span class="built_in">loss_based_state</span>();</span><br><span class="line"></span><br><span class="line">  DataRate pushback_target_rate = loss_based_target_rate;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;fraction_loss_%&quot;</span>, at_time.<span class="built_in">ms</span>(),</span><br><span class="line">                        (fraction_loss * <span class="number">100</span>) / <span class="number">256</span>);</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;rtt_ms&quot;</span>, at_time.<span class="built_in">ms</span>(), round_trip_time.<span class="built_in">ms</span>());</span><br><span class="line">  <span class="built_in">BWE_TEST_LOGGING_PLOT</span>(<span class="number">1</span>, <span class="string">&quot;Target_bitrate_kbps&quot;</span>, at_time.<span class="built_in">ms</span>(),</span><br><span class="line">                        loss_based_target_rate.<span class="built_in">kbps</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> cwnd_reduce_ratio = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">if</span> (congestion_window_pushback_controller_) &#123;</span><br><span class="line">    <span class="comment">// 更新目标速率</span></span><br><span class="line">    <span class="type">int64_t</span> pushback_rate =</span><br><span class="line">        congestion_window_pushback_controller_-&gt;<span class="built_in">UpdateTargetBitrate</span>(</span><br><span class="line">            loss_based_target_rate.<span class="built_in">bps</span>());</span><br><span class="line">      </span><br><span class="line">    pushback_rate = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(bandwidth_estimation_-&gt;<span class="built_in">GetMinBitrate</span>(),</span><br><span class="line">                                      pushback_rate);</span><br><span class="line">    <span class="comment">// 通过目标码率更新拥塞窗口的发送码率，</span></span><br><span class="line">    pushback_target_rate = DataRate::<span class="built_in">BitsPerSec</span>(pushback_rate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindowDropFrameOnly</span>()) &#123;</span><br><span class="line">      <span class="comment">// 通过预估码率和拥塞控制发送码率得到码率的降低比例，用来控制编码</span></span><br><span class="line">      cwnd_reduce_ratio = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(loss_based_target_rate.<span class="built_in">bps</span>() -</span><br><span class="line">                                              pushback_target_rate.<span class="built_in">bps</span>()) /</span><br><span class="line">                          loss_based_target_rate.<span class="built_in">bps</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链路容量(link_capacity)、 丢包码率(loss_based_target_rate)、窗口控制码率(pushback_target_rate)</span></span><br><span class="line">  <span class="comment">// 选择最小得到保守码率</span></span><br><span class="line">  <span class="comment">// 链路容量(link_capacity): 基于目标码率和当前吞吐量(acknowledge)做指数平滑估计出来的链路容量</span></span><br><span class="line">  <span class="comment">// 丢包码率(loss_based_target_rate): 基于丢包估算出来的链路码率，该码率并以延迟预估码率为上限</span></span><br><span class="line">  <span class="comment">// 窗口控制码率(pushback_target_rate)：基于loss_based_target_rate和当前窗口的使用程度缩放后的码率</span></span><br><span class="line">  DataRate stable_target_rate =</span><br><span class="line">      bandwidth_estimation_-&gt;<span class="built_in">GetEstimatedLinkCapacity</span>();</span><br><span class="line">  stable_target_rate = std::<span class="built_in">min</span>(stable_target_rate, pushback_target_rate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数有变化的进行更新</span></span><br><span class="line">  <span class="keyword">if</span> ((loss_based_target_rate != last_loss_based_target_rate_) ||</span><br><span class="line">      (loss_based_state != last_loss_base_state_) ||</span><br><span class="line">      (fraction_loss != last_estimated_fraction_loss_) ||</span><br><span class="line">      (round_trip_time != last_estimated_round_trip_time_) ||</span><br><span class="line">      (pushback_target_rate != last_pushback_target_rate_) ||</span><br><span class="line">      (stable_target_rate != last_stable_target_rate_)) &#123;</span><br><span class="line">    last_loss_based_target_rate_ = loss_based_target_rate;</span><br><span class="line">    last_pushback_target_rate_ = pushback_target_rate;</span><br><span class="line">    last_estimated_fraction_loss_ = fraction_loss;</span><br><span class="line">    last_estimated_round_trip_time_ = round_trip_time;</span><br><span class="line">    last_stable_target_rate_ = stable_target_rate;</span><br><span class="line">    last_loss_base_state_ = loss_based_state;</span><br><span class="line">    <span class="comment">// AlrDetector主动函数调用，更新用于进行ALR探测的码率</span></span><br><span class="line">    alr_detector_-&gt;<span class="built_in">SetEstimatedBitrate</span>(loss_based_target_rate.<span class="built_in">bps</span>());</span><br><span class="line">    <span class="comment">// 下次BWE期望的周期</span></span><br><span class="line">    TimeDelta bwe_period = delay_based_bwe_-&gt;<span class="built_in">GetExpectedBwePeriod</span>();</span><br><span class="line"></span><br><span class="line">    TargetTransferRate target_rate_msg;</span><br><span class="line">    target_rate_msg.at_time = at_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用仅丢帧来控制码率</span></span><br><span class="line">    <span class="keyword">if</span> (rate_control_settings_.<span class="built_in">UseCongestionWindowDropFrameOnly</span>()) &#123;</span><br><span class="line">      <span class="comment">// 直接使用基于延迟的预估码率作为目标码率</span></span><br><span class="line">      target_rate_msg.target_rate = loss_based_target_rate;</span><br><span class="line">      target_rate_msg.cwnd_reduce_ratio = cwnd_reduce_ratio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用窗口控制码率作为目标码率</span></span><br><span class="line">      target_rate_msg.target_rate = pushback_target_rate;</span><br><span class="line">    &#125;</span><br><span class="line">    target_rate_msg.stable_target_rate = stable_target_rate;</span><br><span class="line">    target_rate_msg.network_estimate.at_time = at_time;</span><br><span class="line">    target_rate_msg.network_estimate.round_trip_time = round_trip_time;</span><br><span class="line">    target_rate_msg.network_estimate.loss_rate_ratio = fraction_loss / <span class="number">255.0f</span>;</span><br><span class="line">    target_rate_msg.network_estimate.bwe_period = bwe_period;</span><br><span class="line"></span><br><span class="line">    update-&gt;target_rate = target_rate_msg;</span><br><span class="line">    <span class="comment">// 将最新码率放入probe_controller中，同时进行码率探测</span></span><br><span class="line">    <span class="keyword">auto</span> probes = probe_controller_-&gt;<span class="built_in">SetEstimatedBitrate</span>(</span><br><span class="line">        loss_based_target_rate,</span><br><span class="line">        <span class="built_in">GetBandwidthLimitedCause</span>(bandwidth_estimation_-&gt;<span class="built_in">loss_based_state</span>(),</span><br><span class="line">                                 bandwidth_estimation_-&gt;<span class="built_in">IsRttAboveLimit</span>(),</span><br><span class="line">                                 delay_based_bwe_-&gt;<span class="built_in">last_state</span>()),</span><br><span class="line">        at_time);</span><br><span class="line"></span><br><span class="line">    update-&gt;probe_cluster_configs.<span class="built_in">insert</span>(update-&gt;probe_cluster_configs.<span class="built_in">end</span>(),</span><br><span class="line">                                         probes.<span class="built_in">begin</span>(), probes.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 获取平滑发送的配置</span></span><br><span class="line">    update-&gt;pacer_config = <span class="built_in">GetPacingRates</span>(at_time);</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_VERBOSE) &lt;&lt; <span class="string">&quot;bwe &quot;</span> &lt;&lt; at_time.<span class="built_in">ms</span>() &lt;&lt; <span class="string">&quot; pushback_target_bps=&quot;</span></span><br><span class="line">                        &lt;&lt; last_pushback_target_rate_.<span class="built_in">bps</span>()</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; estimate_bps=&quot;</span> &lt;&lt; loss_based_target_rate.<span class="built_in">bps</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/01/18/Webrtc%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/">https://charstr.github.io/2024/01/18/Webrtc%E5%B8%A6%E5%AE%BD%E4%BC%B0%E8%AE%A1/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/Webrtc/"># Webrtc</a>
                            
                            <a href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"># 拥塞控制</a>
                            
                            <a href="/tags/BWE/"># BWE</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/02/20/Webrtc%E5%BA%94%E7%94%A8%E5%8C%BA%E5%9F%9F%E5%8F%97%E9%99%90%E6%8E%A2%E6%B5%8B/">Webrtc应用区域受限探测</a>
                      
                        
                          <a class="next" rel="next" href="/2024/01/13/TWCC%E6%89%A9%E5%B1%95RTP%E5%92%8CRTCP/">TWCC扩展RTP和RTCP</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>