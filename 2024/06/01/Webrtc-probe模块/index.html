<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>Webrtc probe模块 | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<!-- 通过连接CDN加载MathJax的js代码 -->
<!-- <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> -->


<!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script> -->

<script type="text/javascript" async
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  Webrtc probe模块
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">6月 1, 2024&nbsp;&nbsp;14:41:31</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/Webrtc/">Webrtc</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a>
                                  
                                  <a href="/categories/Webrtc/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/BWE/">BWE</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <p>GCC类似TCP算法中的AIMD，能够迅速反应带宽衰减，网络处于过载状态；带宽上升时，webrtc在前期乘性增加，逼近收敛加性增加，收敛时间比较长，影响数据发送效率。因此webrtc在起始阶段采用类似于TCP慢启动的probe模块，快速探测链路容量上限。</p>
<p><img src="p1.png" alt="p2" style="zoom:32%;" /></p>
<p>发送端发送探测包，同时记录发送时间戳和探测包大小、序列号、探测组id，接收端隔一段时间反馈数据包到达时间、接受包大小。根据发送端和接收端接受的字节数、时间间隔便可以计算接收和发送速度，两者最小值可以认为是网络带宽。</p>
<p>ProbeController负责生成ProbeClusterConfig，交给BitrateProber生成探测簇。ProbeBitrateEstimator是通过cc-feedback的报文得到探测包的发送情况，从而预估码率。</p>
<h1 id="探测流程"><a href="#探测流程" class="headerlink" title="探测流程"></a>探测流程</h1><h2 id="什么时候进行探测"><a href="#什么时候进行探测" class="headerlink" title="什么时候进行探测"></a>什么时候进行探测</h2><p>综上分析，在webrtc中，主动探测随时都有可能发生，初始的时候肯定会进行主动探测，以更为迅速的确定初始带宽；如果启用alr probing，则可以启动5s为单位的周期性探测；另外在带宽骤降的时候以及带宽骤升的时候都要进行主动探测，其主要目的都是为了尽快的确定真实的带宽到底为多少。</p>
<h3 id="开始阶段指数级探测"><a href="#开始阶段指数级探测" class="headerlink" title="开始阶段指数级探测"></a>开始阶段指数级探测</h3><p>ProbeController::InitiateExponentialProbing<br>webrtc设置起始码率300kbps，两阶段探测，第一阶段至900kbps，二阶段至1.8Mbps。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::InitiateExponentialProbing</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(network_available_);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(state_ == State::kInit);</span><br><span class="line">  <span class="built_in">RTC_DCHECK_GT</span>(start_bitrate_, DataRate::<span class="built_in">Zero</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 300kbps 两次探测，6倍至 1.8Mbps</span></span><br><span class="line">  <span class="comment">// 初始化第一个探测码率，webrtc设置初始码率300kbps</span></span><br><span class="line">  std::vector&lt;DataRate&gt; probes = &#123;config_.first_exponential_probe_scale *</span><br><span class="line">                                  start_bitrate_&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config_.second_exponential_probe_scale &amp;&amp;</span><br><span class="line">      config_.second_exponential_probe_scale.<span class="built_in">GetOptional</span>().<span class="built_in">value</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    probes.<span class="built_in">push_back</span>(config_.second_exponential_probe_scale.<span class="built_in">Value</span>() *</span><br><span class="line">                     start_bitrate_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加入900kbps和1.8Mbps两个探测码率</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(at_time, probes, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="InitiateProbing，初始化一次探测"><a href="#InitiateProbing，初始化一次探测" class="headerlink" title="InitiateProbing，初始化一次探测"></a>InitiateProbing，初始化一次探测</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::InitiateProbing</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp now,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;DataRate&gt; bitrates_to_probe,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> probe_further)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (config_.skip_if_estimate_larger_than_fraction_of_max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    DataRate network_estimate = network_estimate_</span><br><span class="line">                                    ? network_estimate_-&gt;link_capacity_upper</span><br><span class="line">                                    : DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">    DataRate max_probe_rate =</span><br><span class="line">        max_total_allocated_bitrate_.<span class="built_in">IsZero</span>()</span><br><span class="line">            ? max_bitrate_</span><br><span class="line">            : std::<span class="built_in">min</span>(max_total_allocated_bitrate_, max_bitrate_);</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">min</span>(network_estimate, estimated_bitrate_) &gt;</span><br><span class="line">        config_.skip_if_estimate_larger_than_fraction_of_max * max_probe_rate) &#123;</span><br><span class="line">      state_ = State::kProbingComplete;</span><br><span class="line">      min_bitrate_to_probe_further_ = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DataRate max_probe_bitrate = max_bitrate_;</span><br><span class="line">  <span class="keyword">if</span> (max_total_allocated_bitrate_ &gt; DataRate::<span class="built_in">Zero</span>()) &#123;</span><br><span class="line">    max_probe_bitrate =</span><br><span class="line">        std::<span class="built_in">min</span>(max_probe_bitrate, max_total_allocated_bitrate_ * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DataRate estimate_capped_bitrate = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">  <span class="keyword">switch</span> (bandwidth_limited_cause_) &#123;</span><br><span class="line">    <span class="keyword">case</span> BandwidthLimitedCause::kRttBasedBackOffHighRtt:</span><br><span class="line">    <span class="keyword">case</span> BandwidthLimitedCause::kDelayBasedLimitedDelayIncreased:</span><br><span class="line">    <span class="keyword">case</span> BandwidthLimitedCause::kLossLimitedBwe:</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Not sending probe in bandwidth limited state.&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">case</span> BandwidthLimitedCause::kLossLimitedBweIncreasing:</span><br><span class="line">      estimate_capped_bitrate =</span><br><span class="line">          std::<span class="built_in">min</span>(max_probe_bitrate,</span><br><span class="line">                   estimated_bitrate_ * config_.loss_limited_probe_scale);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BandwidthLimitedCause::kDelayBasedLimited:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config_.network_state_estimate_probing_interval-&gt;<span class="built_in">IsFinite</span>() &amp;&amp;</span><br><span class="line">      network_estimate_ &amp;&amp; network_estimate_-&gt;link_capacity_upper.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (network_estimate_-&gt;link_capacity_upper.<span class="built_in">IsZero</span>()) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Not sending probe, Network state estimate is zero&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    estimate_capped_bitrate = std::<span class="built_in">min</span>(</span><br><span class="line">        &#123;estimate_capped_bitrate, max_probe_bitrate,</span><br><span class="line">         std::<span class="built_in">max</span>(estimated_bitrate_, network_estimate_-&gt;link_capacity_upper *</span><br><span class="line">                                          config_.network_state_probe_scale)&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;ProbeClusterConfig&gt; pending_probes;</span><br><span class="line">  <span class="keyword">for</span> (DataRate bitrate : bitrates_to_probe) &#123;</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(!bitrate.<span class="built_in">IsZero</span>());</span><br><span class="line">    bitrate = std::<span class="built_in">min</span>(bitrate, estimate_capped_bitrate);</span><br><span class="line">    <span class="comment">// 超过设置码率上限，停止后续探测</span></span><br><span class="line">    <span class="keyword">if</span> (bitrate &gt; max_probe_bitrate) &#123;</span><br><span class="line">      bitrate = max_probe_bitrate; <span class="comment">// 默认5Mbps</span></span><br><span class="line">      probe_further = <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 生成ProbeClusterConfig，15ms，至少5个探测包。每次探测有不同id</span></span><br><span class="line">    ProbeClusterConfig config;</span><br><span class="line">    config.at_time = now;</span><br><span class="line">    config.target_data_rate = bitrate;</span><br><span class="line">    <span class="comment">// 探测时长</span></span><br><span class="line">    <span class="keyword">if</span> (network_estimate_ &amp;&amp;</span><br><span class="line">        config_.network_state_estimate_probing_interval-&gt;<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      config.target_duration = config_.network_state_probe_duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      config.target_duration = config_.min_probe_duration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最少需要发送的探测包数</span></span><br><span class="line">    config.target_probe_count = config_.min_probe_packets_sent;</span><br><span class="line">    config.id = next_probe_cluster_id_; <span class="comment">// 探测组id</span></span><br><span class="line">    next_probe_cluster_id_++;</span><br><span class="line">    <span class="built_in">MaybeLogProbeClusterCreated</span>(event_log_, config);</span><br><span class="line">    pending_probes.<span class="built_in">push_back</span>(config); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time_last_probing_initiated_ = now;</span><br><span class="line">  <span class="comment">// 进一步探测</span></span><br><span class="line">  <span class="keyword">if</span> (probe_further) &#123;</span><br><span class="line">    <span class="comment">// 修改状态，表示等待继续探测</span></span><br><span class="line">    state_ = State::kWaitingForProbingResult;</span><br><span class="line">    <span class="comment">// 下一次探测的码率不能低于最后一次探测码率的0.7倍，避免无意义的探测。</span></span><br><span class="line">    min_bitrate_to_probe_further_ =</span><br><span class="line">        std::<span class="built_in">min</span>(estimate_capped_bitrate, (*(bitrates_to_probe.<span class="built_in">end</span>() - <span class="number">1</span>))) *</span><br><span class="line">        config_.further_probe_threshold; <span class="comment">// threshold = 0.7</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//探测完毕，不用探测了</span></span><br><span class="line">    state_ = State::kProbingComplete;</span><br><span class="line">    min_bitrate_to_probe_further_ = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pending_probes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的ProbeClusterConfig作用到pacer模块，在<code>RtpTransportControllerSend::PostUpdates</code>函数进行处理。</p>
<h3 id="目标码率触发探测"><a href="#目标码率触发探测" class="headerlink" title="目标码率触发探测"></a>目标码率触发探测</h3><p>ProbeController::SetBitrates</p>
<p>GoogCcNetworkController::OnTargetRateConstraints<br>-&gt; GoogCcNetworkController::ResetConstraints<br>-&gt; ProbeController::SetBitrates</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::SetBitrates</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate min_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate start_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate max_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start_bitrate &gt; DataRate::<span class="built_in">Zero</span>()) &#123;</span><br><span class="line">    start_bitrate_ = start_bitrate;</span><br><span class="line">    estimated_bitrate_ = start_bitrate;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start_bitrate_.<span class="built_in">IsZero</span>()) &#123;</span><br><span class="line">    start_bitrate_ = min_bitrate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The reason we use the variable `old_max_bitrate_pbs` is because we</span></span><br><span class="line">  <span class="comment">// need to set `max_bitrate_` before we call InitiateProbing.</span></span><br><span class="line">  DataRate old_max_bitrate = max_bitrate_;</span><br><span class="line">  max_bitrate_ =</span><br><span class="line">      max_bitrate.<span class="built_in">IsFinite</span>() ? max_bitrate : kDefaultMaxProbingBitrate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> State::kInit:</span><br><span class="line">      <span class="comment">// 初始化阶段指数级探测</span></span><br><span class="line">      <span class="keyword">if</span> (network_available_)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InitiateExponentialProbing</span>(at_time);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> State::kWaitingForProbingResult:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 探测结束</span></span><br><span class="line">    <span class="keyword">case</span> State::kProbingComplete:</span><br><span class="line">      <span class="comment">// 设置了一个新的码率，且当前估计的码率还未达到最大，此时探测到设置的这个码率</span></span><br><span class="line">      <span class="keyword">if</span> (!estimated_bitrate_.<span class="built_in">IsZero</span>() &amp;&amp; old_max_bitrate &lt; max_bitrate_ &amp;&amp;</span><br><span class="line">          estimated_bitrate_ &lt; max_bitrate_) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(at_time, &#123;max_bitrate_&#125;, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大需求带宽更新"><a href="#最大需求带宽更新" class="headerlink" title="最大需求带宽更新"></a>最大需求带宽更新</h3><p>ProbeController::OnMaxTotalAllocatedBitrate</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::OnMaxTotalAllocatedBitrate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate max_total_allocated_bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> in_alr = alr_start_time_.<span class="built_in">has_value</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> allow_allocation_probe = in_alr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当最大需求带宽变化的时候需要触发probe</span></span><br><span class="line">  <span class="keyword">if</span> (config_.probe_on_max_allocated_bitrate_change &amp;&amp;</span><br><span class="line">      state_ == State::kProbingComplete &amp;&amp;</span><br><span class="line">      max_total_allocated_bitrate != max_total_allocated_bitrate_ &amp;&amp;</span><br><span class="line">      estimated_bitrate_ &lt; max_bitrate_ &amp;&amp;</span><br><span class="line">      estimated_bitrate_ &lt; max_total_allocated_bitrate &amp;&amp;</span><br><span class="line">      allow_allocation_probe) &#123;</span><br><span class="line">    max_total_allocated_bitrate_ = max_total_allocated_bitrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!config_.first_allocation_probe_scale)</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用两次上探，第一次为1倍，第二次为2倍</span></span><br><span class="line">    DataRate first_probe_rate = max_total_allocated_bitrate *</span><br><span class="line">                                config_.first_allocation_probe_scale.<span class="built_in">Value</span>();</span><br><span class="line">    DataRate probe_cap = config_.allocation_probe_max.<span class="built_in">Get</span>();</span><br><span class="line">    first_probe_rate = std::<span class="built_in">min</span>(first_probe_rate, probe_cap);</span><br><span class="line">    std::vector&lt;DataRate&gt; probes = &#123;first_probe_rate&#125;;</span><br><span class="line">    <span class="keyword">if</span> (config_.second_allocation_probe_scale) &#123;</span><br><span class="line">      DataRate second_probe_rate =</span><br><span class="line">          max_total_allocated_bitrate *</span><br><span class="line">          config_.second_allocation_probe_scale.<span class="built_in">Value</span>();</span><br><span class="line">      second_probe_rate = std::<span class="built_in">min</span>(second_probe_rate, probe_cap);</span><br><span class="line">      <span class="keyword">if</span> (second_probe_rate &gt; first_probe_rate)</span><br><span class="line">        probes.<span class="built_in">push_back</span>(second_probe_rate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(at_time, probes,</span><br><span class="line">                           config_.allocation_allow_further_probing.<span class="built_in">Get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  max_total_allocated_bitrate_ = max_total_allocated_bitrate;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络中断-恢复"><a href="#网络中断-恢复" class="headerlink" title="网络中断/恢复"></a>网络中断/恢复</h3><p>ProbeController::OnNetworkAvailability</p>
<p>GoogCcNetworkController::OnNetworkAvailability<br>-&gt; ProbeController::OnNetworkAvailability<br>-&gt; ProbeController::InitiateExponentialProbing</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::OnNetworkAvailability</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkAvailability msg)</span> </span>&#123;</span><br><span class="line">  network_available_ = msg.network_available;</span><br><span class="line">  <span class="comment">// 网络中断，立即结束探测</span></span><br><span class="line">  <span class="keyword">if</span> (!network_available_ &amp;&amp; state_ == State::kWaitingForProbingResult) &#123;</span><br><span class="line">    state_ = State::kProbingComplete;</span><br><span class="line">    min_bitrate_to_probe_further_ = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 恢复，初始化探测</span></span><br><span class="line">  <span class="keyword">if</span> (network_available_ &amp;&amp; state_ == State::kInit &amp;&amp; !start_bitrate_.<span class="built_in">IsZero</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InitiateExponentialProbing</span>(msg.at_time);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置估计的码率"><a href="#设置估计的码率" class="headerlink" title="设置估计的码率"></a>设置估计的码率</h3><p>ProbeController::SetEstimatedBitrate</p>
<p>乘性探测：探测码率大于设置目标值的70%就继续探测，直到小于这个值，说明链路带宽在这次探测的附近。</p>
<p>如果设置的估计码率超过上次最后一次探测的0.7倍，则需要继续探测</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::SetEstimatedBitrate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRate bitrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    BandwidthLimitedCause bandwidth_limited_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  bandwidth_limited_cause_ = bandwidth_limited_cause;</span><br><span class="line">  <span class="keyword">if</span> (bitrate &lt; kBitrateDropThreshold * estimated_bitrate_) &#123;</span><br><span class="line">    time_of_last_large_drop_ = at_time;</span><br><span class="line">    bitrate_before_last_large_drop_ = estimated_bitrate_;</span><br><span class="line">  &#125;</span><br><span class="line">  estimated_bitrate_ = bitrate;</span><br><span class="line">  <span class="comment">// 如果当前正在等待probe结果，且新设置的码率超过上次最后一次探测的0.7倍，则需要继续探测</span></span><br><span class="line">  <span class="comment">// 进一步探测，没有达到最大容量</span></span><br><span class="line">  <span class="keyword">if</span> (state_ == State::kWaitingForProbingResult) &#123;</span><br><span class="line">    <span class="comment">// further_probe_threshold = 0.7</span></span><br><span class="line">    DataRate network_state_estimate_probe_further_limit =</span><br><span class="line">        config_.network_state_estimate_probing_interval-&gt;<span class="built_in">IsFinite</span>() &amp;&amp;</span><br><span class="line">                network_estimate_</span><br><span class="line">            ? network_estimate_-&gt;link_capacity_upper *</span><br><span class="line">                  config_.further_probe_threshold</span><br><span class="line">            : DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Measured bitrate: &quot;</span> &lt;&lt; bitrate</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; Minimum to probe further: &quot;</span></span><br><span class="line">                     &lt;&lt; min_bitrate_to_probe_further_ &lt;&lt; <span class="string">&quot; upper limit: &quot;</span></span><br><span class="line">                     &lt;&lt; network_state_estimate_probe_further_limit;</span><br><span class="line">    <span class="comment">// 估计的bitrate已经大于了设定的进一步探测的最小值，则启动新的探测</span></span><br><span class="line">    <span class="keyword">if</span> (bitrate &gt; min_bitrate_to_probe_further_ &amp;&amp;</span><br><span class="line">        bitrate &lt;= network_state_estimate_probe_further_limit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(</span><br><span class="line">          at_time, &#123;config_.further_exponential_probe_scale * bitrate&#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时任务处理ALR周期探测、结束探测"><a href="#定时任务处理ALR周期探测、结束探测" class="headerlink" title="定时任务处理ALR周期探测、结束探测"></a>定时任务处理ALR周期探测、结束探测</h3><p>ProbeController::Process</p>
<p>周期性判断 prober状态为完成状态且应用限制区域激活，启动探测码率：</p>
<p>GoogCcNetworkController::OnProcessInterval<br>-&gt; GoogCcNetworkController::ResetConstraints - ProbeController::SetBitrates<br>-&gt; ProbeController::OnMaxTotalAllocatedBitrate<br>-&gt; ProbeController::Process</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::Process</span><span class="params">(Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 探测超过1s没完成，结束探测</span></span><br><span class="line">  <span class="keyword">if</span> (at_time - time_last_probing_initiated_ &gt;</span><br><span class="line">      kMaxWaitingTimeForProbingResult) &#123;</span><br><span class="line">    <span class="comment">// 超时</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == State::kWaitingForProbingResult) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;kWaitingForProbingResult: timeout&quot;</span>;</span><br><span class="line">      state_ = State::kProbingComplete;</span><br><span class="line">      min_bitrate_to_probe_further_ = DataRate::<span class="built_in">PlusInfinity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始alr周期探测才会设置探测的配置</span></span><br><span class="line">  <span class="keyword">if</span> (estimated_bitrate_.<span class="built_in">IsZero</span>() || state_ != State::kProbingComplete) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 符合ALR和probe的时间，ALR周期探测，采用当前码率的两倍进行探测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TimeForAlrProbe</span>(at_time) || <span class="built_in">TimeForNetworkStateProbe</span>(at_time)) &#123;</span><br><span class="line">    <span class="comment">// alr_probe_scale=2，即周期性探测是当前带宽的两倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(</span><br><span class="line">        at_time, &#123;estimated_bitrate_ * config_.alr_probe_scale&#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TimeForAlrProbe(at_time) || TimeForNetworkStateProbe(at_time)</span></span><br></pre></td></tr></table></figure>
<h3 id="主动请求探测"><a href="#主动请求探测" class="headerlink" title="主动请求探测"></a>主动请求探测</h3><p>ProbeController::RequestProbe</p>
<p>GoogCcNetworkController::MaybeTriggerOnNetworkChanged<br>-&gt; GoogCcNetworkController::ResetConstraints - ProbeController::SetBitrates<br>-&gt; ProbeController::SetEstimatedBitrate<br>-&gt; ProbeController::RequestProbe</p>
<p>在webrtc中，主动探测随时都有可能发生，初始的时候肯定会进行主动探测，以更为迅速的确定初始带宽；如果启用alr probing，则可以启动5s为单位的周期性探测；另外在带宽骤降的时候以及带宽骤升的时候都要进行主动探测，其主要目的都是为了尽快的确定真实的带宽到底为多少。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;ProbeClusterConfig&gt; <span class="title">ProbeController::RequestProbe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp at_time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在估计带宽大幅下降后恢复到正常状态时调用。当前的应对措施是以先前的比特率</span></span><br><span class="line">  <span class="comment">// 启动一次探测会话（如果尚未进行探测）。如果探测会话失败，则假定这次带宽下降</span></span><br><span class="line">  <span class="comment">// 是来自竞争流量或网络变化的实际带宽下降。</span></span><br><span class="line">  <span class="type">bool</span> in_alr = alr_start_time_.<span class="built_in">has_value</span>();</span><br><span class="line">  <span class="type">bool</span> alr_ended_recently =</span><br><span class="line">      (alr_end_time_.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">       at_time - alr_end_time_.<span class="built_in">value</span>() &lt; kAlrEndedTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ALR激活，临近ALR结束(离开应用区域首先不超过3秒)，快恢复码率</span></span><br><span class="line">  <span class="keyword">if</span> (in_alr || alr_ended_recently || in_rapid_recovery_experiment_) &#123;</span><br><span class="line">    <span class="comment">// 必须等待上一波探测完成</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == State::kProbingComplete) &#123;</span><br><span class="line">      <span class="comment">// 降低前码率的0.85作为新的探测码率</span></span><br><span class="line">      DataRate suggested_probe =</span><br><span class="line">          kProbeFractionAfterDrop * bitrate_before_last_large_drop_;</span><br><span class="line">      <span class="comment">// 再降低一点，取suggested_probe_bps的95%探测数据</span></span><br><span class="line">      <span class="comment">// 因为这里的快速恢复本地就存在风险，因此ACK需要严格一些</span></span><br><span class="line">      DataRate min_expected_probe_result =</span><br><span class="line">          (<span class="number">1</span> - kProbeUncertainty) * suggested_probe; <span class="comment">// 0.05</span></span><br><span class="line">      TimeDelta time_since_drop = at_time - time_of_last_large_drop_;</span><br><span class="line">      TimeDelta time_since_probe = at_time - last_bwe_drop_probing_time_;</span><br><span class="line">      <span class="comment">// 距离上次带宽降低在5s内，距离上次ALR探测超过5s</span></span><br><span class="line">      <span class="comment">// 需要ACK的码率超过当前的估计码率，否则就没必要开始这次探测</span></span><br><span class="line">      <span class="comment">// 满足上述条件后，就可以以建议的带宽探测。</span></span><br><span class="line">      <span class="keyword">if</span> (min_expected_probe_result &gt; estimated_bitrate_ &amp;&amp;</span><br><span class="line">          time_since_drop &lt; kBitrateDropTimeout &amp;&amp;</span><br><span class="line">          time_since_probe &gt; kMinTimeBetweenAlrProbes) &#123;</span><br><span class="line">        <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Detected big bandwidth drop, start probing.&quot;</span>;</span><br><span class="line">        <span class="comment">// 跟踪在响应ALR带宽下降时探测的频率。</span></span><br><span class="line">        <span class="built_in">RTC_HISTOGRAM_COUNTS_10000</span>(</span><br><span class="line">            <span class="string">&quot;WebRTC.BWE.BweDropProbingIntervalInS&quot;</span>,</span><br><span class="line">            (at_time - last_bwe_drop_probing_time_).<span class="built_in">seconds</span>());</span><br><span class="line">        last_bwe_drop_probing_time_ = at_time;</span><br><span class="line">        <span class="comment">// 启动新的探测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InitiateProbing</span>(at_time, &#123;suggested_probe&#125;, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;ProbeClusterConfig&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitrateProber生成探测簇"><a href="#BitrateProber生成探测簇" class="headerlink" title="BitrateProber生成探测簇"></a>BitrateProber生成探测簇</h2><p><code>BitrateProber::CreateProbeCluster</code> 消耗ProbeClusterConfig生成ProbeCluster。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RtpTransportControllerSend::PostUpdates</span></span><br><span class="line"><span class="comment">// -&gt;TaskQueuePacedSender::CreateProbeClusters</span></span><br><span class="line"><span class="comment">// -&gt;PacingController::CreateProbeClusters</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PacingController::CreateProbeClusters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    rtc::ArrayView&lt;<span class="type">const</span> ProbeClusterConfig&gt; probe_cluster_configs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pacer模块中的BitrateProber创建探测簇并加入队列中</span></span><br><span class="line">  <span class="comment">// BitrateProber::CreateProbeCluster</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> ProbeClusterConfig probe_cluster_config : probe_cluster_configs) &#123;</span><br><span class="line">    prober_.<span class="built_in">CreateProbeCluster</span>(probe_cluster_config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitrateProber::CreateProbeCluster</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ProbeClusterConfig&amp; cluster_config)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(probing_state_ != ProbingState::kDisabled);</span><br><span class="line">  <span class="comment">// 移除超时（5s）的探测组</span></span><br><span class="line">  <span class="keyword">while</span> (!clusters_.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">         (cluster_config.at_time - clusters_.<span class="built_in">front</span>().requested_at &gt;</span><br><span class="line">              kProbeClusterTimeout ||</span><br><span class="line">          clusters_.<span class="built_in">size</span>() &gt; kMaxPendingProbeClusters)) &#123;</span><br><span class="line">    clusters_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造新的ProbeCluster</span></span><br><span class="line">  ProbeCluster cluster;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  struct ProbeCluster &#123;</span></span><br><span class="line"><span class="comment">    PacedPacketInfo pace_info; // probe基本参数</span></span><br><span class="line"><span class="comment">    int sent_probes = 0; // 发送的probe包个数</span></span><br><span class="line"><span class="comment">    int sent_bytes = 0; // 发送的probe字节数</span></span><br><span class="line"><span class="comment">    Timestamp requested_at = Timestamp::MinusInfinity();</span></span><br><span class="line"><span class="comment">    Timestamp started_at = Timestamp::MinusInfinity();</span></span><br><span class="line"><span class="comment">    int retries = 0;</span></span><br><span class="line"><span class="comment">  &#125;;  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cluster.requested_at = cluster_config.at_time;</span><br><span class="line">  <span class="comment">// 最少的个数</span></span><br><span class="line">  cluster.pace_info.probe_cluster_min_probes =</span><br><span class="line">      cluster_config.target_probe_count;</span><br><span class="line">  <span class="comment">// 字节数=码率*探测时长</span></span><br><span class="line">  cluster.pace_info.probe_cluster_min_bytes =</span><br><span class="line">      (cluster_config.target_data_rate * cluster_config.target_duration)</span><br><span class="line">          .<span class="built_in">bytes</span>();</span><br><span class="line">  <span class="built_in">RTC_DCHECK_GE</span>(cluster.pace_info.probe_cluster_min_bytes, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 探测码率和id</span></span><br><span class="line">  cluster.pace_info.send_bitrate = cluster_config.target_data_rate;</span><br><span class="line">  cluster.pace_info.probe_cluster_id = cluster_config.id;</span><br><span class="line">  <span class="comment">// 加入探测队列</span></span><br><span class="line">  clusters_.<span class="built_in">push</span>(cluster);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 干什么？</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ReadyToSetActiveState</span>(<span class="comment">/*packet_size=*/</span>DataSize::<span class="built_in">Zero</span>())) &#123;</span><br><span class="line">    next_probe_time_ = Timestamp::<span class="built_in">MinusInfinity</span>();</span><br><span class="line">    probing_state_ = ProbingState::kActive;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BitrateProber::ReadyToSetActiveState</span><span class="params">(DataSize packet_size)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (clusters_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">RTC_DCHECK</span>(probing_state_ == ProbingState::kDisabled ||</span><br><span class="line">               probing_state_ == ProbingState::kInactive);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (probing_state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> ProbingState::kDisabled:</span><br><span class="line">    <span class="keyword">case</span> ProbingState::kActive:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> ProbingState::kInactive:</span><br><span class="line">      <span class="comment">// If config_.min_packet_size &gt; 0, a &quot;large enough&quot; packet must be sent</span></span><br><span class="line">      <span class="comment">// first, before a probe can be generated and sent. Otherwise, send the</span></span><br><span class="line">      <span class="comment">// probe asap.</span></span><br><span class="line">      <span class="keyword">return</span> packet_size &gt;=</span><br><span class="line">             std::<span class="built_in">min</span>(<span class="built_in">RecommendedMinProbeSize</span>(), config_.min_packet_size.<span class="built_in">Get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下一个探测包时间"><a href="#下一个探测包时间" class="headerlink" title="下一个探测包时间"></a>下一个探测包时间</h2><p>pacer默认5ms发送，探测包间隔优先级较高，可以大于或小于5ms。探测包发送时间计算：</p>
<p><code>PacingController::ProcessPackets</code>函数中，is_probing处于探测状态，发送一个探测报文，就会调用BitrateProber的ProbeSent函数。<code>BitrateProber::ProbeSent</code>更新当前cluster已经发送的字节数和packet数量，并计算下次发送时间，如果发送的字节数和报文数已经达到基本要求，则完成本cluster的探测。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitrateProber::ProbeSent</span><span class="params">(Timestamp now, DataSize size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(probing_state_ == ProbingState::kActive);</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!size.<span class="built_in">IsZero</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!clusters_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ProbeCluster* cluster = &amp;clusters_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span> (cluster-&gt;sent_probes == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">RTC_DCHECK</span>(cluster-&gt;started_at.<span class="built_in">IsInfinite</span>());</span><br><span class="line">      cluster-&gt;started_at = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新已发送字节数和报文数</span></span><br><span class="line">    cluster-&gt;sent_bytes += size.<span class="built_in">bytes</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    cluster-&gt;sent_probes += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一个发送时间</span></span><br><span class="line">    next_probe_time_ = <span class="built_in">CalculateNextProbeTime</span>(*cluster);</span><br><span class="line">    <span class="keyword">if</span> (cluster-&gt;sent_bytes &gt;= cluster-&gt;pace_info.probe_cluster_min_bytes &amp;&amp;</span><br><span class="line">        cluster-&gt;sent_probes &gt;= cluster-&gt;pace_info.probe_cluster_min_probes) &#123;</span><br><span class="line">      clusters_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空了挂起</span></span><br><span class="line">    <span class="keyword">if</span> (clusters_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      probing_state_ = ProbingState::kInactive;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下一个probe包的发送时间</span></span><br><span class="line"><span class="function">Timestamp <span class="title">BitrateProber::CalculateNextProbeTime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ProbeCluster&amp; cluster)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_CHECK_GT</span>(cluster.pace_info.send_bitrate.<span class="built_in">bps</span>(), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(cluster.started_at.<span class="built_in">IsFinite</span>());</span><br><span class="line"></span><br><span class="line">  DataSize sent_bytes = DataSize::<span class="built_in">Bytes</span>(cluster.sent_bytes);</span><br><span class="line">  DataRate send_bitrate = cluster.pace_info.send_bitrate;</span><br><span class="line">  <span class="comment">// 发送的时间间隔=大小/码率</span></span><br><span class="line">  TimeDelta delta = sent_bytes / send_bitrate;</span><br><span class="line">  <span class="comment">// 下一个发送时间</span></span><br><span class="line">  <span class="keyword">return</span> cluster.started_at + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProbeController::TimeForNetworkStateProbe</code>判断是否到达了下一次探测的时间</p>
<p>发送了数据包之后，由<code>TransportFeedbackAdapter::AddPacket</code>加入到历史发送队列。</p>
<h2 id="ProbeBitrateEstimator根据反馈包计算探测码率"><a href="#ProbeBitrateEstimator根据反馈包计算探测码率" class="headerlink" title="ProbeBitrateEstimator根据反馈包计算探测码率"></a>ProbeBitrateEstimator根据反馈包计算探测码率</h2><p><code>ProbeBitrateEstimator::HandleProbeAndEstimateBitrate</code>根据cc-feedback估计码率<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;DataRate&gt; <span class="title">ProbeBitrateEstimator::HandleProbeAndEstimateBitrate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PacketResult&amp; packet_feedback)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cluster_id = packet_feedback.sent_packet.pacing_info.probe_cluster_id;</span><br><span class="line">  <span class="built_in">RTC_DCHECK_NE</span>(cluster_id, PacedPacketInfo::kNotAProbe);</span><br><span class="line">  <span class="comment">// 去除超过1s的包</span></span><br><span class="line">  <span class="built_in">EraseOldClusters</span>(packet_feedback.receive_time);</span><br><span class="line">  <span class="comment">// 获取探测包</span></span><br><span class="line">  AggregatedCluster* cluster = &amp;clusters_[cluster_id];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新首包、尾包发送时间、大小</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback.sent_packet.send_time &lt; cluster-&gt;first_send) &#123;</span><br><span class="line">    cluster-&gt;first_send = packet_feedback.sent_packet.send_time;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (packet_feedback.sent_packet.send_time &gt; cluster-&gt;last_send) &#123;</span><br><span class="line">    cluster-&gt;last_send = packet_feedback.sent_packet.send_time;</span><br><span class="line">    cluster-&gt;size_last_send = packet_feedback.sent_packet.size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新首包、尾包接收时间、大小</span></span><br><span class="line">  <span class="keyword">if</span> (packet_feedback.receive_time &lt; cluster-&gt;first_receive) &#123;</span><br><span class="line">    cluster-&gt;first_receive = packet_feedback.receive_time;</span><br><span class="line">    cluster-&gt;size_first_receive = packet_feedback.sent_packet.size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (packet_feedback.receive_time &gt; cluster-&gt;last_receive) &#123;</span><br><span class="line">    cluster-&gt;last_receive = packet_feedback.receive_time;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新探测包总大小、个数</span></span><br><span class="line">  cluster-&gt;size_total += packet_feedback.sent_packet.size;</span><br><span class="line">  cluster-&gt;num_probes += <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收端至少要接收发送端探测包个数、大小的80%以上</span></span><br><span class="line">  <span class="type">int</span> min_probes =</span><br><span class="line">      packet_feedback.sent_packet.pacing_info.probe_cluster_min_probes *</span><br><span class="line">      kMinReceivedProbesRatio;</span><br><span class="line">  DataSize min_size =</span><br><span class="line">      DataSize::<span class="built_in">Bytes</span>(</span><br><span class="line">          packet_feedback.sent_packet.pacing_info.probe_cluster_min_bytes) *</span><br><span class="line">      kMinReceivedBytesRatio;</span><br><span class="line">  <span class="comment">// 没达到规定的要求，数据量不够导致不准确</span></span><br><span class="line">  <span class="keyword">if</span> (cluster-&gt;num_probes &lt; min_probes || cluster-&gt;size_total &lt; min_size)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送、接收间隔</span></span><br><span class="line">  TimeDelta send_interval = cluster-&gt;last_send - cluster-&gt;first_send;</span><br><span class="line">  TimeDelta receive_interval = cluster-&gt;last_receive - cluster-&gt;first_receive;</span><br><span class="line">  <span class="comment">// 间隔不能超过1s</span></span><br><span class="line">  <span class="keyword">if</span> (send_interval &lt;= TimeDelta::<span class="built_in">Zero</span>() || send_interval &gt; kMaxProbeInterval ||</span><br><span class="line">      receive_interval &lt;= TimeDelta::<span class="built_in">Zero</span>() ||</span><br><span class="line">      receive_interval &gt; kMaxProbeInterval) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// send_interval 不包括实际发送最后一个数据包所需的时间，因此应该去除最后一个发送包大小</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_GT</span>(cluster-&gt;size_total, cluster-&gt;size_last_send);</span><br><span class="line">  DataSize send_size = cluster-&gt;size_total - cluster-&gt;size_last_send;</span><br><span class="line">  DataRate send_rate = send_size / send_interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// receive_interval 不包括实际接收第一个数据包的时间，应该去除第一个接收数据包的大小</span></span><br><span class="line">  <span class="built_in">RTC_DCHECK_GT</span>(cluster-&gt;size_total, cluster-&gt;size_first_receive);</span><br><span class="line">  DataSize receive_size = cluster-&gt;size_total - cluster-&gt;size_first_receive;</span><br><span class="line">  DataRate receive_rate = receive_size / receive_interval;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ratio = receive_rate / send_rate;</span><br><span class="line">  <span class="comment">// 接收速率超过发送速率两倍，不合理</span></span><br><span class="line">  <span class="keyword">if</span> (ratio &gt; kMaxValidRatio) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 最终速率是发送和接收的最小值</span></span><br><span class="line">  DataRate res = std::<span class="built_in">min</span>(send_rate, receive_rate);</span><br><span class="line">  <span class="comment">// 接收速率明显低于发送速率（0.9倍），说明已经探测到链路容量。这里调高目标码率，避免出现overuse</span></span><br><span class="line">  <span class="keyword">if</span> (receive_rate &lt; kMinRatioForUnsaturatedLink * send_rate) &#123;</span><br><span class="line">    <span class="built_in">RTC_DCHECK_GT</span>(send_rate, receive_rate);</span><br><span class="line">    <span class="comment">// 0.95倍</span></span><br><span class="line">    res = kTargetUtilizationFraction * receive_rate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 估计的码率</span></span><br><span class="line">  estimated_data_rate_ = res;</span><br><span class="line">  <span class="keyword">return</span> estimated_data_rate_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ProbeBitrateEstimator::FetchAndResetLastEstimatedBitrate</code>得到最终的码率，并将估计值的reset。只有在收到cc-feedback之后调用，为了计算当前实时的探测码率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;DataRate&gt;</span></span><br><span class="line"><span class="function"><span class="title">ProbeBitrateEstimator::FetchAndResetLastEstimatedBitrate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;DataRate&gt; estimated_data_rate = estimated_data_rate_;</span><br><span class="line">  estimated_data_rate_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> estimated_data_rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="发送端处理"><a href="#发送端处理" class="headerlink" title="发送端处理"></a>发送端处理</h1><h2 id="周期性探测"><a href="#周期性探测" class="headerlink" title="周期性探测"></a>周期性探测</h2><p>GoogCcNetworkController::OnProcessInterval</p>
<h2 id="状态变化探测"><a href="#状态变化探测" class="headerlink" title="状态变化探测"></a>状态变化探测</h2><p>在估计带宽大幅下降后恢复到正常状态时调用。当前的应对措施是以先前的比特率启动一次探测会话（如果尚未进行探测）。如果探测会话失败，则假定这次带宽下降是来自竞争流量或网络变化的实际带宽下降。</p>
<h2 id="乘性探测"><a href="#乘性探测" class="headerlink" title="乘性探测"></a>乘性探测</h2><p>GoogCcNetworkController::MaybeTriggerOnNetworkChanged</p>
<h2 id="根据反馈估计码率"><a href="#根据反馈估计码率" class="headerlink" title="根据反馈估计码率"></a>根据反馈估计码率</h2><h1 id="接收端处理"><a href="#接收端处理" class="headerlink" title="接收端处理"></a>接收端处理</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x00. 探测包的处理</span></span><br><span class="line"><span class="function">RemoteBitrateEstimatorAbsSendTime::ProbeResult</span></span><br><span class="line"><span class="function"><span class="title">RemoteBitrateEstimatorAbsSendTime::ProcessClusters</span><span class="params">(Timestamp now)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过探测包构建包簇集</span></span><br><span class="line">  std::list&lt;Cluster&gt; clusters = <span class="built_in">ComputeClusters</span>();</span><br><span class="line">  <span class="comment">// 如果构建包簇集失败</span></span><br><span class="line">  <span class="keyword">if</span> (clusters.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// If we reach the max number of probe packets and still have no clusters,</span></span><br><span class="line">    <span class="comment">// we will remove the oldest one.</span></span><br><span class="line">    <span class="comment">// 如果探测包溢出(15个)，删除最旧的，直到正确构建包簇集.</span></span><br><span class="line">    <span class="keyword">if</span> (probes_.<span class="built_in">size</span>() &gt;= kMaxProbePackets)</span><br><span class="line">      probes_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> ProbeResult::kNoUpdate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算所有包簇的最佳探测带宽(取最大值)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="type">const</span> Cluster* best = <span class="built_in">FindBestProbe</span>(clusters)) &#123;</span><br><span class="line">    DataRate probe_bitrate = std::<span class="built_in">min</span>(best-&gt;<span class="built_in">SendBitrate</span>(), best-&gt;<span class="built_in">RecvBitrate</span>());</span><br><span class="line">    <span class="comment">// Make sure that a probe sent on a lower bitrate than our estimate can&#x27;t</span></span><br><span class="line">    <span class="comment">// reduce the estimate.</span></span><br><span class="line">    <span class="comment">// 获取通过发送时间、接收时间计算的码率的最小值作为当前包簇的探测带宽</span></span><br><span class="line">    <span class="comment">// 如果探测带宽优于当前带宽</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsBitrateImproving</span>(probe_bitrate)) &#123;</span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Probe successful, sent at &quot;</span></span><br><span class="line">                       &lt;&lt; best-&gt;<span class="built_in">SendBitrate</span>().<span class="built_in">bps</span>() &lt;&lt; <span class="string">&quot; bps, received at &quot;</span></span><br><span class="line">                       &lt;&lt; best-&gt;<span class="built_in">RecvBitrate</span>().<span class="built_in">bps</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; bps. Mean send delta: &quot;</span> &lt;&lt; best-&gt;send_mean.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, mean recv delta: &quot;</span> &lt;&lt; best-&gt;recv_mean.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, num probes: &quot;</span> &lt;&lt; best-&gt;count;</span><br><span class="line">      <span class="comment">// 直接设置到AimdRateControl作为初始码率.</span></span><br><span class="line">      remote_rate_.<span class="built_in">SetEstimate</span>(probe_bitrate, now);</span><br><span class="line">      <span class="keyword">return</span> ProbeResult::kBitrateUpdated;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not probing and received non-probe packet, or finished with current set</span></span><br><span class="line">  <span class="comment">// of probes.</span></span><br><span class="line">  <span class="keyword">if</span> (clusters.<span class="built_in">size</span>() &gt;= kExpectedNumberOfProbes)</span><br><span class="line">    probes_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">return</span> ProbeResult::kNoUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有的探测包，聚集5ms范围的探测包，并检查个数是否到达4个，形成包簇(这个算法在丢包比较严重的情况下可能会失效，因为常常连续出现5ms包簇的探测包不足4个的情况，这种情况下，只能以输入码率来估算带宽，这可能获得一个很小且增长缓慢的值)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">std::list&lt;RemoteBitrateEstimatorAbsSendTime::Cluster&gt;</span></span><br><span class="line"><span class="function"><span class="title">RemoteBitrateEstimatorAbsSendTime::ComputeClusters</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  std::list&lt;Cluster&gt; clusters;</span><br><span class="line">  Cluster cluster_aggregate;</span><br><span class="line">  Timestamp prev_send_time = Timestamp::<span class="built_in">MinusInfinity</span>();</span><br><span class="line">  Timestamp prev_recv_time = Timestamp::<span class="built_in">MinusInfinity</span>();</span><br><span class="line">  <span class="comment">// 遍历探测包</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> Probe&amp; probe : probes_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev_send_time.<span class="built_in">IsFinite</span>()) &#123;</span><br><span class="line">      <span class="comment">// 计算两个探测包的时间间隔</span></span><br><span class="line">      TimeDelta send_delta = probe.send_time - prev_send_time;</span><br><span class="line">      TimeDelta recv_delta = probe.recv_time - prev_recv_time;</span><br><span class="line">      <span class="keyword">if</span> (send_delta &gt;= kMinClusterDelta &amp;&amp; recv_delta &gt;= kMinClusterDelta) &#123;</span><br><span class="line">        <span class="comment">// 累加当前包簇有有效时间的包数</span></span><br><span class="line">        ++cluster_aggregate.num_above_min_delta;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果探测包不在包簇平均时间的5ms范围之内</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">IsWithinClusterBounds</span>(send_delta, cluster_aggregate)) &#123;</span><br><span class="line">         <span class="comment">// 添加1个新的包簇到包簇集合，会求得包簇尺寸、时间的平均值，以便计算码率</span></span><br><span class="line">        <span class="built_in">MaybeAddCluster</span>(cluster_aggregate, clusters);</span><br><span class="line">        <span class="comment">// 重置当前包簇</span></span><br><span class="line">        cluster_aggregate = <span class="built_in">Cluster</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新当前包簇的累计时间、尺寸</span></span><br><span class="line">      cluster_aggregate.send_mean += send_delta;</span><br><span class="line">      cluster_aggregate.recv_mean += recv_delta;</span><br><span class="line">      cluster_aggregate.mean_size += probe.payload_size;</span><br><span class="line">      ++cluster_aggregate.count;</span><br><span class="line">    &#125;</span><br><span class="line">    prev_send_time = probe.send_time;</span><br><span class="line">    prev_recv_time = probe.recv_time;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩余的不满5ms的探测包也判断下是否有必要添加成1个有效包簇</span></span><br><span class="line">  <span class="built_in">MaybeAddCluster</span>(cluster_aggregate, clusters);</span><br><span class="line">  <span class="keyword">return</span> clusters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算包簇集合的最佳码率(取每个包簇探测带宽的最大值)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> RemoteBitrateEstimatorAbsSendTime::Cluster*</span></span><br><span class="line"><span class="function"><span class="title">RemoteBitrateEstimatorAbsSendTime::FindBestProbe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::list&lt;Cluster&gt;&amp; clusters)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  DataRate highest_probe_bitrate = DataRate::<span class="built_in">Zero</span>();</span><br><span class="line">  <span class="type">const</span> Cluster* best = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 遍历所有包簇</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; cluster : clusters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cluster.send_mean == TimeDelta::<span class="built_in">Zero</span>() ||</span><br><span class="line">        cluster.recv_mean == TimeDelta::<span class="built_in">Zero</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前包簇有有效时间的探测包数超过1半</span></span><br><span class="line">    <span class="comment">// 并且接收时间差和发送时间差很接近</span></span><br><span class="line">    <span class="keyword">if</span> (cluster.num_above_min_delta &gt; cluster.count / <span class="number">2</span> &amp;&amp;</span><br><span class="line">        (cluster.recv_mean - cluster.send_mean &lt;= TimeDelta::<span class="built_in">Millis</span>(<span class="number">2</span>) &amp;&amp;</span><br><span class="line">         cluster.send_mean - cluster.recv_mean &lt;= TimeDelta::<span class="built_in">Millis</span>(<span class="number">5</span>))) &#123;</span><br><span class="line">      <span class="comment">// 获取通过发送时间、接收时间计算的码率的最小值作为当前包簇的探测带宽</span></span><br><span class="line">      DataRate probe_bitrate =</span><br><span class="line">          std::<span class="built_in">min</span>(cluster.<span class="built_in">SendBitrate</span>(), cluster.<span class="built_in">RecvBitrate</span>());</span><br><span class="line">      <span class="comment">// 记录所有包簇的探测带宽的最大值</span></span><br><span class="line">      <span class="keyword">if</span> (probe_bitrate &gt; highest_probe_bitrate) &#123;</span><br><span class="line">        highest_probe_bitrate = probe_bitrate;</span><br><span class="line">        best = &amp;cluster;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果发现无效的包簇，则本次探测失败.</span></span><br><span class="line">      <span class="built_in">RTC_LOG</span>(LS_INFO) &lt;&lt; <span class="string">&quot;Probe failed, sent at &quot;</span></span><br><span class="line">                       &lt;&lt; cluster.<span class="built_in">SendBitrate</span>().<span class="built_in">bps</span>() &lt;&lt; <span class="string">&quot; bps, received at &quot;</span></span><br><span class="line">                       &lt;&lt; cluster.<span class="built_in">RecvBitrate</span>().<span class="built_in">bps</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; bps. Mean send delta: &quot;</span> &lt;&lt; cluster.send_mean.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, mean recv delta: &quot;</span> &lt;&lt; cluster.recv_mean.<span class="built_in">ms</span>()</span><br><span class="line">                       &lt;&lt; <span class="string">&quot; ms, num probes: &quot;</span> &lt;&lt; cluster.count;</span><br><span class="line">      <span class="comment">// 返回最佳码率</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接收端处理每个RTP包，累计5ms的探测包簇计算初始带宽，然后通过到达时间滤波器、卡尔曼滤波器、过载检测器来计算链路的延迟变化，从而判断链路的拥塞状态，结合输入码率来估算接收端的带宽，然后通过REMB包反馈给发送端，该反馈的带宽将直接被发送端采用，并作为发送端后续带宽调整算法的基准。</p>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/06/01/Webrtc-probe%E6%A8%A1%E5%9D%97/">https://charstr.github.io/2024/06/01/Webrtc-probe%E6%A8%A1%E5%9D%97/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/Webrtc/"># Webrtc</a>
                            
                            <a href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"># 拥塞控制</a>
                            
                            <a href="/tags/BWE/"># BWE</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/06/03/Webrtc%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%B0%E8%AE%A1/">Webrtc吞吐量估计</a>
                      
                        
                          <a class="next" rel="next" href="/2024/06/01/Webrtc-Pacer%E6%A8%A1%E5%9D%97/">Webrtc Pacer模块</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>