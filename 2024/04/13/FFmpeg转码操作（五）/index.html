<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>FFmpeg转码操作（五） | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  FFmpeg转码操作（五）
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">4月 13, 2024&nbsp;&nbsp;17:33:35</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/FFmpeg/">FFmpeg</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <h2 id="decode-video-do-audio-out"><a href="#decode-video-do-audio-out" class="headerlink" title="decode_video/do_audio_out"></a>decode_video/do_audio_out</h2><ol>
<li><p>传进来的参数pkt和eof,分别是process_input_packet函数的参数avpkt和!pkt. !pkt为真说明输入文件已经读取不到pkt了，这时候eof=1。传入的pkt会有pkt!=NULL&amp;&amp;pkt.size!=0的情况, pkt!=NULL&amp;&amp;pkt.size=0的情况和pkt==NULL的情况.</p>
<ol>
<li><p>eof=0,此时是没有到文件结尾的有3种情况. 1) pkt!=NULL&amp;&amp;pkt.size!=0是正常读取到pkt的包然后解码,repeating=0; 2) pkt!=NULL&amp;&amp;pkt.size=0是空包的情况,应该跳过; 3) pkt==NULL是发送正常的pkt进行解码之后进行flush解码器得到frame的情况,repeating=1.</p>
</li>
<li><p>eof=1，说明已经不能从文件读取到pkt了。repeating始终为0，只存在有pkt!=NULL&amp;&amp;pkt.size=0的情况，是刷新数据包，用于清空内部的缓冲，并输出所有未输出的帧。传给decode函数的时候, 调用的avcodec_send_packet会进行特殊判断。</p>
</li>
</ol>
</li>
<li><p><strong>如果输入流的dts是有效的，首先会转换为输入流的时间基。</strong>将pkt送到decode进行解码。</p>
</li>
<li><p><strong>对解码后的frame进行时间戳设置。</strong>send_frame_to_filters将解码输出的帧送入滤镜链进行处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">decode_video</span><span class="params">(InputStream *ist, AVPacket *pkt, <span class="type">int</span> *got_output,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int64_t</span> *duration_pts, <span class="type">int</span> eof, <span class="type">int</span> *decode_failed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 传进来的参数pkt和eof,分别是process_input_packet函数的参数avpkt和!pkt.</span></span><br><span class="line"><span class="comment">  !pkt为真说明输入文件已经读取不到pkt了,这时候eof=1.</span></span><br><span class="line"><span class="comment">  传入的pkt会有pkt!=NULL&amp;&amp;pkt.size!=0的情况,</span></span><br><span class="line"><span class="comment">  pkt!=NULL&amp;&amp;pkt.size=0的情况和pkt==NULL的情况.</span></span><br><span class="line"><span class="comment">  2. eof=0,此时是没有到文件结尾的有3种情况. 1)</span></span><br><span class="line"><span class="comment">  pkt!=NULL&amp;&amp;pkt.size!=0是正常读取到pkt的包然后解码,repeating=0; 2)</span></span><br><span class="line"><span class="comment">  pkt!=NULL&amp;&amp;pkt.size=0是空包的情况,应该跳过; 3)</span></span><br><span class="line"><span class="comment">  pkt==NULL是发送正常的pkt进行解码之后进行flush解码器得到frame的情况,repeating=1.</span></span><br><span class="line"><span class="comment">  3.</span></span><br><span class="line"><span class="comment">  eof=1.说明已经不能从文件读取到pkt了.repeating始终为0,只存在有pkt!=NULL&amp;&amp;pkt.size=0的情况,刷新数据包，用于清空内部的缓冲，并输出所有未输出的帧。传给decode函数的时候,</span></span><br><span class="line"><span class="comment">  调用的avcodec_send_packet会进行特殊判断.</span></span><br><span class="line"><span class="comment">  4.</span></span><br><span class="line"><span class="comment">  decode解码出一个frame以后，send_frame_to_filters讲输入的帧送入滤镜链进行处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  AVFrame *decoded_frame = ist-&gt;decoded_frame;</span><br><span class="line">  <span class="type">int</span> i, ret = <span class="number">0</span>, err = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int64_t</span> best_effort_timestamp;</span><br><span class="line">  <span class="type">int64_t</span> dts = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// With fate-indeo3-2, we&#x27;re getting 0-sized packets before EOF for some</span></span><br><span class="line">  <span class="comment">// reason. This seems like a semi-critical bug. Don&#x27;t trigger EOF, and</span></span><br><span class="line">  <span class="comment">// skip the packet.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在一些情况下，会在EOF之前得到大小为0的数据包。</span></span><br><span class="line">  <span class="comment">// 这时不要触发EOF，应该跳过该数据包。</span></span><br><span class="line">  <span class="keyword">if</span> (!eof &amp;&amp; pkt &amp;&amp; pkt-&gt;size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输入流的dts不为AV_NOPTS_VALUE，则将其转换为输入流的时间基</span></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">    dts = <span class="built_in">av_rescale_q</span>(ist-&gt;dts, AV_TIME_BASE_Q, ist-&gt;st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">    pkt-&gt;dts = dts; <span class="comment">// ffmpeg.c probably shouldn&#x27;t do this ？</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The old code used to set dts on the drain packet, which does not work</span></span><br><span class="line">  <span class="comment">// with the new API anymore.</span></span><br><span class="line">  <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">    <span class="comment">// 在EOF时，将dts添加到dts缓冲区中</span></span><br><span class="line">    <span class="type">void</span> *<span class="keyword">new</span> = <span class="built_in">av_realloc_array</span>(ist-&gt;dts_buffer, ist-&gt;nb_dts_buffer + <span class="number">1</span>,</span><br><span class="line">                                 <span class="built_in">sizeof</span>(ist-&gt;dts_buffer[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    ist-&gt;dts_buffer = <span class="keyword">new</span>;</span><br><span class="line">    ist-&gt;dts_buffer[ist-&gt;nb_dts_buffer++] = dts;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_benchmark</span>(<span class="literal">NULL</span>); <span class="comment">// 对解码时间进行统计</span></span><br><span class="line">  <span class="comment">// 解码pkt</span></span><br><span class="line">  ret = <span class="built_in">decode</span>(ist, ist-&gt;dec_ctx, decoded_frame, got_output, pkt);</span><br><span class="line">  <span class="built_in">update_benchmark</span>(<span class="string">&quot;decode_video %d.%d&quot;</span>, ist-&gt;file_index, ist-&gt;st-&gt;index);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    *decode_failed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following line may be required in some cases where there is no parser</span></span><br><span class="line">  <span class="comment">// or the parser does not has_b_frames correctly</span></span><br><span class="line">  <span class="comment">// 在一些情况下，没有解析器或者解析器没有正确地处理B帧时，下面的代码可能是必需的</span></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;par-&gt;video_delay &lt; ist-&gt;dec_ctx-&gt;has_b_frames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;dec_ctx-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">      ist-&gt;par-&gt;video_delay = ist-&gt;dec_ctx-&gt;has_b_frames;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果解码器的B帧数大于解封装器的video_delay，输出警告信息</span></span><br><span class="line">      <span class="built_in">av_log</span>(ist-&gt;dec_ctx, AV_LOG_WARNING,</span><br><span class="line">             <span class="string">&quot;video_delay is larger in decoder than demuxer %d &gt; %d.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;If you want to help, upload a sample &quot;</span></span><br><span class="line">             <span class="string">&quot;of this file to https://streams.videolan.org/upload/ &quot;</span></span><br><span class="line">             <span class="string">&quot;and contact the ffmpeg-devel mailing list. &quot;</span></span><br><span class="line">             <span class="string">&quot;(ffmpeg-devel@ffmpeg.org)\n&quot;</span>,</span><br><span class="line">             ist-&gt;dec_ctx-&gt;has_b_frames, ist-&gt;par-&gt;video_delay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果不是EOF，检查解码结果</span></span><br><span class="line">  <span class="keyword">if</span> (ret != AVERROR_EOF)</span><br><span class="line">    <span class="built_in">check_decode_result</span>(ist, got_output, ret);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有输出并且解码成功，检查解码后的帧的参数是否匹配输入流的参数</span></span><br><span class="line">  <span class="keyword">if</span> (*got_output &amp;&amp; ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;dec_ctx-&gt;width != decoded_frame-&gt;width ||</span><br><span class="line">        ist-&gt;dec_ctx-&gt;height != decoded_frame-&gt;height ||</span><br><span class="line">        ist-&gt;dec_ctx-&gt;pix_fmt != decoded_frame-&gt;format) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_DEBUG,</span><br><span class="line">             <span class="string">&quot;Frame parameters mismatch context %d,%d,%d != %d,%d,%d\n&quot;</span>,</span><br><span class="line">             decoded_frame-&gt;width, decoded_frame-&gt;height, decoded_frame-&gt;format,</span><br><span class="line">             ist-&gt;dec_ctx-&gt;width, ist-&gt;dec_ctx-&gt;height, ist-&gt;dec_ctx-&gt;pix_fmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// decode的EOF到这里直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!*got_output || ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;top_field_first &gt;= <span class="number">0</span>)</span><br><span class="line">    decoded_frame-&gt;top_field_first = ist-&gt;top_field_first;</span><br><span class="line"></span><br><span class="line">  ist-&gt;frames_decoded++; <span class="comment">// 统计编码多少帧</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有输出数据并且解码成功</span></span><br><span class="line">  <span class="comment">// 如果支持硬件加速并且帧的格式匹配硬件加速的格式，则调用硬件加速的数据获取函数</span></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;hwaccel_retrieve_data &amp;&amp;</span><br><span class="line">      decoded_frame-&gt;format == ist-&gt;hwaccel_pix_fmt) &#123;</span><br><span class="line">    err = ist-&gt;<span class="built_in">hwaccel_retrieve_data</span>(ist-&gt;dec_ctx, decoded_frame);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最佳估算的时间戳和帧的持续时间</span></span><br><span class="line">  best_effort_timestamp = decoded_frame-&gt;best_effort_timestamp;</span><br><span class="line">  *duration_pts = decoded_frame-&gt;duration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输入流有固定帧率，则使用固定帧率（cfr）的方式计算时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;framerate.num)</span><br><span class="line">    best_effort_timestamp = ist-&gt;cfr_next_pts++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在EOF时，如果最佳估算的时间戳为AV_NOPTS_VALUE，并且dts缓冲区中有值，则使用dts缓冲区中的第一个dts值</span></span><br><span class="line">  <span class="keyword">if</span> (eof &amp;&amp; best_effort_timestamp == AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">      ist-&gt;nb_dts_buffer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    best_effort_timestamp = ist-&gt;dts_buffer[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dts缓冲区中的值向前移动</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ist-&gt;nb_dts_buffer - <span class="number">1</span>; i++)</span><br><span class="line">      ist-&gt;dts_buffer[i] = ist-&gt;dts_buffer[i + <span class="number">1</span>];</span><br><span class="line">    ist-&gt;nb_dts_buffer--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果最佳估算的时间戳不为AV_NOPTS_VALUE，则将其转换为输入流的时间基</span></span><br><span class="line">  <span class="keyword">if</span> (best_effort_timestamp != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    <span class="type">int64_t</span> ts = <span class="built_in">av_rescale_q</span>(decoded_frame-&gt;pts = best_effort_timestamp,</span><br><span class="line">                              ist-&gt;st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">    <span class="comment">// 如果转换后的时间戳不为AV_NOPTS_VALUE，则将其设置为下一个时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (ts != AV_NOPTS_VALUE)</span><br><span class="line">      ist-&gt;next_pts = ist-&gt;pts = ts;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印刚从解码器里解码出来的 AVFrame 的时间信息</span></span><br><span class="line">  <span class="keyword">if</span> (debug_ts) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(</span><br><span class="line">        <span class="literal">NULL</span>, AV_LOG_INFO,</span><br><span class="line">        <span class="string">&quot;decoder -&gt; ist_index:%d type:video &quot;</span></span><br><span class="line">        <span class="string">&quot;frame_pts:%s frame_pts_time:%s best_effort_ts:%&quot;</span> PRId64</span><br><span class="line">        <span class="string">&quot; best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\n&quot;</span>,</span><br><span class="line">        ist-&gt;st-&gt;index, <span class="built_in">av_ts2str</span>(decoded_frame-&gt;pts),</span><br><span class="line">        <span class="built_in">av_ts2timestr</span>(decoded_frame-&gt;pts, &amp;ist-&gt;st-&gt;time_base),</span><br><span class="line">        best_effort_timestamp,</span><br><span class="line">        <span class="built_in">av_ts2timestr</span>(best_effort_timestamp, &amp;ist-&gt;st-&gt;time_base),</span><br><span class="line">        decoded_frame-&gt;key_frame, decoded_frame-&gt;pict_type,</span><br><span class="line">        ist-&gt;st-&gt;time_base.num, ist-&gt;st-&gt;time_base.den);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输入流的采样纵横比不为0，则将解码后的帧的采样纵横比设置为输入流的采样纵横比</span></span><br><span class="line">  <span class="keyword">if</span> (ist-&gt;st-&gt;sample_aspect_ratio.num)</span><br><span class="line">    decoded_frame-&gt;sample_aspect_ratio = ist-&gt;st-&gt;sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调 av_buffersrc_add_frame_flags() 把 解码后AVFrame 往 滤镜里发送，</span></span><br><span class="line">  <span class="comment">// 如果滤镜没打开就会用 configure_filtergraph 打开滤镜。</span></span><br><span class="line">  <span class="comment">// 成功时返回0，发生错误时返回负数</span></span><br><span class="line">  err = <span class="built_in">send_frame_to_filters</span>(ist, decoded_frame);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="comment">// 滤镜容器是异步线程，为了让滤镜容器里面能拿到 AVFrame</span></span><br><span class="line">  <span class="comment">// 的内存，需要先把引用加一，</span></span><br><span class="line">  <span class="comment">// 要不发送完之后就立即释放内存，滤镜线程就拿不到内存了，</span></span><br><span class="line">  <span class="built_in">av_frame_unref</span>(decoded_frame); <span class="comment">// 把引用减一</span></span><br><span class="line">  <span class="keyword">return</span> err &lt; <span class="number">0</span> ? err : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="decode函数"><a href="#decode函数" class="headerlink" title="decode函数"></a>decode函数</h3></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">decode</span><span class="params">(InputStream *ist, AVCodecContext *avctx, AVFrame *frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> *got_frame, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  *got_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pkt.size进去返回AVERROR_EOF</span></span><br><span class="line">  <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">    <span class="comment">// 发送pkt给解码器进行解码</span></span><br><span class="line">    ret = <span class="built_in">avcodec_send_packet</span>(avctx, pkt);</span><br><span class="line">    <span class="comment">// In particular, we don&#x27;t expect AVERROR(EAGAIN), because we read all</span></span><br><span class="line">    <span class="comment">// decoded frames with avcodec_receive_frame() until done.</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从解码器读取frame，返回ERROR(EAGAIN)表示还要更多的pkt才能解码</span></span><br><span class="line">  <span class="comment">// flush完毕返回AVERROR_EOF</span></span><br><span class="line">  ret = <span class="built_in">avcodec_receive_frame</span>(avctx, frame);</span><br><span class="line">  <span class="comment">// pts设置</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;want_frame_data) &#123;</span><br><span class="line">      FrameData *fd;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">av_assert0</span>(!frame-&gt;opaque_ref);</span><br><span class="line">      frame-&gt;opaque_ref = <span class="built_in">av_buffer_allocz</span>(<span class="built_in">sizeof</span>(*fd));</span><br><span class="line">      <span class="keyword">if</span> (!frame-&gt;opaque_ref) &#123;</span><br><span class="line">        <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">      &#125;</span><br><span class="line">      fd = (FrameData *)frame-&gt;opaque_ref-&gt;data;</span><br><span class="line">      fd-&gt;pts = frame-&gt;pts;</span><br><span class="line">      fd-&gt;tb = avctx-&gt;pkt_timebase;</span><br><span class="line">      fd-&gt;idx = avctx-&gt;frame_num - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *got_frame = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avcodec-send-packet函数"><a href="#avcodec-send-packet函数" class="headerlink" title="avcodec_send_packet函数"></a>avcodec_send_packet函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> AVPacket *avpkt)</span> </span>&#123;</span><br><span class="line">  AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码器是否已经打开且是否是解码器而不是编码器</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) || !<span class="built_in">av_codec_is_decoder</span>(avctx-&gt;codec))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL); <span class="comment">// 返回 AVERROR(EINVAL) 表示参数错误</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入非NULL但是size=0的特殊数据包,表示解码器正在处理 EOF（文件结束）的阶段</span></span><br><span class="line">  <span class="keyword">if</span> (avctx-&gt;internal-&gt;draining)</span><br><span class="line">    <span class="keyword">return</span> AVERROR_EOF; <span class="comment">// 返回 AVERROR_EOF 表示文件结束。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包存在但是大小为0也就是无效的输入</span></span><br><span class="line">  <span class="keyword">if</span> (avpkt &amp;&amp; !avpkt-&gt;size &amp;&amp; avpkt-&gt;data)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="send-frame-to-filters-ifilter-send-frame函数"><a href="#send-frame-to-filters-ifilter-send-frame函数" class="headerlink" title="send_frame_to_filters/ifilter_send_frame函数"></a>send_frame_to_filters/ifilter_send_frame函数</h2><ol>
<li><p>每次循环都是选择一个输出流，然后选择对应的输入流，进而找到与之对应的输入文件索引。process_input找到这个输入文件，ifile_get_packet每次读取一个pkt，读取的pkt会标记来自哪个输入流，然后process_input_packet会根据这个流的类型，将pkt送到对应的解码器进行解码。send_frame_to_filters与这个输入流相关的所有入口滤镜，ifilter_send_frame将解码后的AVFrame送到对应的入口滤镜进行处理。</p>
</li>
<li><p>ifilter_send_frame首先会比较输入滤镜InputFilter ifilter和解码出来的AVFrame的格式是否相等、音频通道布局、视频分辨率等信息<strong>判断是否需要need_reinit操作</strong>。<strong>因为视频的帧率、分辨率，音频的通道数都是可能变化的，这里要对每个AVFrame都进行判断。</strong>一个滤镜容器（FilterGraph）有多个 InputFilter，这只是对其中一个进行初始化。</p>
<ol>
<li><p><strong>每个ifilter-&gt;format初始值为-1，在这里会赋值为对应流解码出来的frame-&gt;format。某个流第一次解码出frame运行到这里，一定会进行初始化。</strong>调用ifilter_parameters_from_frame函数用AVFrame 对 ifilter 进行赋值（包括format）。</p>
</li>
<li><p><strong>fg-&gt;graph也就是滤镜图中的AVFilterGraph *graph在所有输入滤镜初始化完成以前是没分配内存的。</strong>当 FilterGraph 里面还有 InputFilter 没有初始化时，就不能把 AVFrame 发送给滤镜，而是先缓存到当前输入滤镜的队列队列（ifilter-&gt;frame_queue，会在configure_filtergraph函数中进行处理）。当所有的输入滤镜InputFilter 都初始化，才会调用configure_filtergraph() 来配置滤镜链，里面会打开滤镜容器。</p>
</li>
<li><p>reap_filters(1)在配置滤镜以前要flush. </p>
</li>
</ol>
</li>
<li><p>configure_filtergraph配置并打开滤镜容器后，调 av_buffersrc_add_frame_flags 往滤镜<strong>发送 AVFrame</strong>。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">send_frame_to_filters</span><span class="params">(InputStream *ist, AVFrame *decoded_frame)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_assert1</span>(ist-&gt;nb_filters &gt; <span class="number">0</span>); <span class="comment">/* ensure ret is initialized */</span></span><br><span class="line">  <span class="comment">// 遍历所有的输入滤镜，按照滤镜链进行处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ist-&gt;nb_filters; i++) &#123;</span><br><span class="line">    <span class="comment">// 会对decoded_frame创建多一份的引用？？</span></span><br><span class="line">    ret = ifilter_send_frame(ist-&gt;filters[i], decoded_frame,</span><br><span class="line">                             i &lt; ist-&gt;nb_filters - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EOF视为正常退出</span></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">      ret = <span class="number">0</span>; <span class="comment">/* ignore */</span></span><br><span class="line">    <span class="comment">// 错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;Failed to inject frame into filter network: %s\n&quot;</span>,</span><br><span class="line">             <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ifilter-send-frame函数"><a href="#ifilter-send-frame函数" class="headerlink" title="ifilter_send_frame函数"></a>ifilter_send_frame函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把帧送到滤镜中进行处理。成功时返回0，发生错误时返回负数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ifilter_send_frame</span><span class="params">(InputFilter *ifilter, AVFrame *frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> keep_reference)</span> </span>&#123;</span><br><span class="line">  FilterGraph *fg = ifilter-&gt;graph;</span><br><span class="line">  AVFrameSideData *sd;</span><br><span class="line">  <span class="type">int</span> need_reinit, ret;</span><br><span class="line">  <span class="comment">// 是否需要多一份引用</span></span><br><span class="line">  <span class="type">int</span> buffersrc_flags = AV_BUFFERSRC_FLAG_PUSH;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要保持帧的引用，则设置相应的标志位</span></span><br><span class="line">  <span class="keyword">if</span> (keep_reference)</span><br><span class="line">    buffersrc_flags |= AV_BUFFERSRC_FLAG_KEEP_REF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*----------------判断是否要进行重新初始化-------------*/</span></span><br><span class="line">  <span class="comment">/* determine if the parameters for this input changed */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比InputFilter跟 AVFrame</span></span><br><span class="line">  <span class="comment">// 的格式，采样率，宽高等参数，判断需不需要重新初始化 filtergraph</span></span><br><span class="line">  <span class="comment">// ifilter-&gt;format 一开始是设置为 -1，所以第一次 need_init 肯定会设置为 1</span></span><br><span class="line">  need_reinit = ifilter-&gt;format != frame-&gt;format;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ifilter-&gt;ist-&gt;par-&gt;codec_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">    <span class="comment">// 对于音频流，判断采样率和声道布局是否发生变化</span></span><br><span class="line">    need_reinit |=</span><br><span class="line">        ifilter-&gt;sample_rate != frame-&gt;sample_rate ||</span><br><span class="line">        <span class="built_in">av_channel_layout_compare</span>(&amp;ifilter-&gt;ch_layout, &amp;frame-&gt;ch_layout);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">    <span class="comment">// 对于视频流，判断宽度和高度是否发生变化</span></span><br><span class="line">    need_reinit |=</span><br><span class="line">        ifilter-&gt;width != frame-&gt;width || ifilter-&gt;height != frame-&gt;height;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要重新初始化滤镜图，并根据情况处理帧数据</span></span><br><span class="line">  <span class="keyword">if</span> (!ifilter-&gt;ist-&gt;reinit_filters &amp;&amp; fg-&gt;graph)</span><br><span class="line">    need_reinit = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 检查硬件帧上下文是否发生变化，如果变化则需要重新初始化滤镜</span></span><br><span class="line">  <span class="keyword">if</span> (!!ifilter-&gt;hw_frames_ctx != !!frame-&gt;hw_frames_ctx ||</span><br><span class="line">      (ifilter-&gt;hw_frames_ctx &amp;&amp;</span><br><span class="line">       ifilter-&gt;hw_frames_ctx-&gt;data != frame-&gt;hw_frames_ctx-&gt;data))</span><br><span class="line">    need_reinit = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 检查帧中是否包含显示矩阵数据，如果包含则判断显示矩阵是否发生变化</span></span><br><span class="line">  <span class="keyword">if</span> (sd = <span class="built_in">av_frame_get_side_data</span>(frame, AV_FRAME_DATA_DISPLAYMATRIX)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ifilter-&gt;displaymatrix ||</span><br><span class="line">        <span class="built_in">memcmp</span>(sd-&gt;data, ifilter-&gt;displaymatrix, <span class="built_in">sizeof</span>(<span class="type">int32_t</span>) * <span class="number">9</span>))</span><br><span class="line">      need_reinit = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ifilter-&gt;displaymatrix)</span><br><span class="line">    need_reinit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要初始化，把 frame 的参数 赋值给 InputFilter，同时设置了format</span></span><br><span class="line">  <span class="keyword">if</span> (need_reinit) &#123;</span><br><span class="line">    ret = ifilter_parameters_from_frame(ifilter, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* (re)init the graph if possible, otherwise buffer the frame and return */</span></span><br><span class="line">  <span class="comment">// 需要重新进行初始化，这只是对其中一个进行初始化。</span></span><br><span class="line">  <span class="keyword">if</span> (need_reinit || !fg-&gt;graph) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的InputFilter都初始化完成才能送进滤镜链进行处理</span></span><br><span class="line">    <span class="comment">// 有InputFilter未初始化，则将帧缓存起来，等待后续处理</span></span><br><span class="line">    <span class="keyword">if</span> (!ifilter_has_all_input_formats(fg)) &#123;</span><br><span class="line">      AVFrame *tmp = <span class="built_in">av_frame_clone</span>(frame); <span class="comment">// 创建多一份应用</span></span><br><span class="line">      <span class="keyword">if</span> (!tmp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">      <span class="comment">// 未打开滤镜的时候，把未处理的数据缓存到队列，队列的数据会在configure_filtergraph函数</span></span><br><span class="line">      <span class="comment">// 打开滤镜之后把队列中的数据往滤镜中送</span></span><br><span class="line">      ret = <span class="built_in">av_fifo_write</span>(ifilter-&gt;frame_queue, &amp;tmp, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;tmp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fulsh</span></span><br><span class="line">    ret = <span class="built_in">reap_filters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error while filtering: %s\n&quot;</span>,</span><br><span class="line">             <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把所有的 InputFilter 与 OutputFilter 链接在一起</span></span><br><span class="line">    <span class="comment">// 如果全部初始化完成了，就会进行到这里配置滤镜了</span></span><br><span class="line">    ret = <span class="built_in">configure_filtergraph</span>(fg);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error reinitializing filters!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往buffer Filter发送frame进行处理</span></span><br><span class="line">  ret = <span class="built_in">av_buffersrc_add_frame_flags</span>(ifilter-&gt;filter, frame, buffersrc_flags);</span><br><span class="line">  <span class="comment">// 如果发生错误，输出错误信息</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret != AVERROR_EOF)</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error while filtering: %s\n&quot;</span>,</span><br><span class="line">             <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-video-out函数"><a href="#do-video-out函数" class="headerlink" title="do_video_out函数"></a>do_video_out函数</h2><ol>
<li>由reap_filters函数调用。do_video_out计算并更新帧持续时间,视频同步,更新帧数量,检测丢帧和重复帧,编码指定数量的帧,设置PTS,编码类型,质量等参数,提交编码.</li>
</ol>
<ol>
<li>submit_encode_frame用于提交待编码的帧到编码队列，并在必要时进行编码和写入文件。如果不使用编码队列，直接调用encode_frame函数进行编码。如果使用编码队列，先将帧通过sq_send函数发送到队列中，然后循环sq_receive从队列中接收待编码的帧，调用encode_frame函数进行编码和写入文件。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">do_video_out</span><span class="params">(OutputFile *of, OutputStream *ost,</span></span></span><br><span class="line"><span class="params"><span class="function">                         AVFrame *next_picture)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里边有强制关键帧-force_key_frames命令、sync 同步模式逻辑 与 帧率变换逻辑</span></span><br><span class="line">  <span class="comment">// -r选项的处理</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  AVCodecContext *enc = ost-&gt;enc_ctx; <span class="comment">// 从输出流获取编解码器上下文</span></span><br><span class="line">  AVRational frame_rate; <span class="comment">// 从 buffer sink 出口滤镜里读取到的帧率</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// nb_frames是要输入给编码器的帧数量，初始值是 1，可能大于</span></span><br><span class="line">  <span class="comment">// 1，代表重复输入一帧给编码器，内容一样pts不同</span></span><br><span class="line">  <span class="type">int64_t</span> nb_frames, nb_frames_prev, i;</span><br><span class="line">  <span class="type">double</span> duration = <span class="number">0</span>;</span><br><span class="line">  InputStream *ist = ost-&gt;ist;</span><br><span class="line">  AVFilterContext *filter = ost-&gt;filter-&gt;filter; <span class="comment">// 输出流的滤镜上下文</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输出流和帧做初始化处理</span></span><br><span class="line">  <span class="built_in">init_output_stream_wrapper</span>(ost, next_picture, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从过滤器获取帧率</span></span><br><span class="line">  frame_rate = <span class="built_in">av_buffersink_get_frame_rate</span>(filter);</span><br><span class="line">  <span class="keyword">if</span> (frame_rate.num &gt; <span class="number">0</span> &amp;&amp; frame_rate.den &gt; <span class="number">0</span>)</span><br><span class="line">    duration =</span><br><span class="line">        <span class="number">1</span> / (<span class="built_in">av_q2d</span>(frame_rate) * <span class="built_in">av_q2d</span>(enc-&gt;time_base)); <span class="comment">// 计算帧持续时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新duration</span></span><br><span class="line">  <span class="keyword">if</span> (ist &amp;&amp; ist-&gt;st-&gt;start_time != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">      ist-&gt;first_dts != AV_NOPTS_VALUE &amp;&amp; ost-&gt;frame_rate.num)</span><br><span class="line">    duration =</span><br><span class="line">        <span class="built_in">FFMIN</span>(duration, <span class="number">1</span> / (<span class="built_in">av_q2d</span>(ost-&gt;frame_rate) * <span class="built_in">av_q2d</span>(enc-&gt;time_base)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有过滤器,且存在下一帧图像和输入流</span></span><br><span class="line">  <span class="comment">// 根据下一帧图像的时长和时间基来调整时长,用码流时间基计算duration</span></span><br><span class="line">  <span class="keyword">if</span> (!ost-&gt;filters_script &amp;&amp; !ost-&gt;filters &amp;&amp;</span><br><span class="line">      (nb_filtergraphs == <span class="number">0</span> || !filtergraphs[<span class="number">0</span>]-&gt;graph_desc) &amp;&amp; next_picture &amp;&amp;</span><br><span class="line">      ist &amp;&amp;</span><br><span class="line">      <span class="built_in">lrintf</span>(next_picture-&gt;duration * <span class="built_in">av_q2d</span>(ist-&gt;st-&gt;time_base) /</span><br><span class="line">             <span class="built_in">av_q2d</span>(enc-&gt;time_base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    duration = <span class="built_in">lrintf</span>(next_picture-&gt;duration * <span class="built_in">av_q2d</span>(ist-&gt;st-&gt;time_base) /</span><br><span class="line">                      <span class="built_in">av_q2d</span>(enc-&gt;time_base));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否flushing</span></span><br><span class="line">  <span class="keyword">if</span> (!next_picture) &#123;</span><br><span class="line">    <span class="comment">// end, flushing 计算输出帧数量</span></span><br><span class="line">    nb_frames_prev = nb_frames =</span><br><span class="line">        <span class="built_in">mid_pred</span>(ost-&gt;last_nb0_frames[<span class="number">0</span>], ost-&gt;last_nb0_frames[<span class="number">1</span>],</span><br><span class="line">                 ost-&gt;last_nb0_frames[<span class="number">2</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理视频同步,更新nb_frames和nb_frames_prev</span></span><br><span class="line">    <span class="comment">// 通常 VFR 转成 CFR 的时候 nb_frames 会大于 1。或者使用 -r</span></span><br><span class="line">    <span class="comment">// 选项变大帧率也会导致 nb_frames 大于 1。 也有可能变成</span></span><br><span class="line">    <span class="comment">// 0，导致丢弃该帧，不输入给编码器，例如使用 -r</span></span><br><span class="line">    <span class="comment">// 选项降低帧率的时候就会出现这种情况。</span></span><br><span class="line">    <span class="built_in">video_sync_process</span>(of, ost, next_picture, duration, &amp;nb_frames,</span><br><span class="line">                       &amp;nb_frames_prev);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*-----------上边都是算有多少帧-----------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存有三个nb_frames_prev在last_nb0_frames中，每次[0]是最新的。写之前都向后移。</span></span><br><span class="line">  <span class="comment">// 移动帧数数组，更新最后的帧数</span></span><br><span class="line">  <span class="built_in">memmove</span>(ost-&gt;last_nb0_frames + <span class="number">1</span>, ost-&gt;last_nb0_frames,</span><br><span class="line">          <span class="built_in">sizeof</span>(ost-&gt;last_nb0_frames[<span class="number">0</span>]) *</span><br><span class="line">              (<span class="built_in">FF_ARRAY_ELEMS</span>(ost-&gt;last_nb0_frames) - <span class="number">1</span>));</span><br><span class="line">  ost-&gt;last_nb0_frames[<span class="number">0</span>] = nb_frames_prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测丢帧情况</span></span><br><span class="line">  <span class="keyword">if</span> (nb_frames_prev == <span class="number">0</span> &amp;&amp; ost-&gt;last_dropped) &#123;</span><br><span class="line">    nb_frames_drop++;</span><br><span class="line">    <span class="built_in">av_log</span>(ost, AV_LOG_VERBOSE,</span><br><span class="line">           <span class="string">&quot;*** dropping frame %&quot;</span> PRId64 <span class="string">&quot; at ts %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">           ost-&gt;vsync_frame_number, ost-&gt;last_frame-&gt;pts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测重复帧情况</span></span><br><span class="line">  <span class="comment">// 如果当前帧数大于前一帧数（帧被输出的情况下），或者当前帧数大于前一帧数（帧未被输出的情况下），则发生帧重复。</span></span><br><span class="line">  <span class="keyword">if</span> (nb_frames &gt;</span><br><span class="line">      (nb_frames_prev &amp;&amp; ost-&gt;last_dropped) + (nb_frames &gt; nb_frames_prev)) &#123;</span><br><span class="line">    <span class="comment">// 如果当前帧数大于一定阈值（dts_error_threshold *</span></span><br><span class="line">    <span class="comment">// 30），则认为帧重复过多，跳过该帧。</span></span><br><span class="line">    <span class="keyword">if</span> (nb_frames &gt; dts_error_threshold * <span class="number">30</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;%&quot;</span> PRId64 <span class="string">&quot; frame duplication too large, skipping\n&quot;</span>,</span><br><span class="line">             nb_frames - <span class="number">1</span>);</span><br><span class="line">      nb_frames_drop++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录帧重复数量并输出日志。</span></span><br><span class="line">    nb_frames_dup += nb_frames - (nb_frames_prev &amp;&amp; ost-&gt;last_dropped) -</span><br><span class="line">                     (nb_frames &gt; nb_frames_prev);</span><br><span class="line">    <span class="built_in">av_log</span>(ost, AV_LOG_VERBOSE, <span class="string">&quot;*** %&quot;</span> PRId64 <span class="string">&quot; dup!\n&quot;</span>, nb_frames - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb_frames_dup &gt; dup_warning) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_WARNING, <span class="string">&quot;More than %&quot;</span> PRIu64 <span class="string">&quot; frames duplicated\n&quot;</span>,</span><br><span class="line">             dup_warning);</span><br><span class="line">      dup_warning *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记是否丢帧</span></span><br><span class="line">  ost-&gt;last_dropped = nb_frames == nb_frames_prev &amp;&amp; next_picture;</span><br><span class="line">  ost-&gt;kf.dropped_keyframe =</span><br><span class="line">      ost-&gt;last_dropped &amp;&amp; next_picture &amp;&amp; next_picture-&gt;key_frame;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* duplicates frame if needed */</span></span><br><span class="line">  <span class="comment">// 处理帧的重复和输出</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_frames; i++) &#123;</span><br><span class="line">    AVFrame *in_picture;</span><br><span class="line">    <span class="comment">// 获取输入图像帧</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; nb_frames_prev &amp;&amp; ost-&gt;last_frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">      in_picture = ost-&gt;last_frame;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      in_picture = next_picture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_picture)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置帧的时间戳</span></span><br><span class="line">    in_picture-&gt;pts = ost-&gt;next_pts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对输出流的时间做限制 -t 选项限制输出流的时间</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check_recording_time</span>(ost, in_picture-&gt;pts, ost-&gt;enc_ctx-&gt;time_base))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置帧的质量和类型</span></span><br><span class="line">    in_picture-&gt;quality = enc-&gt;global_quality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应参数&quot;force_key_frames&quot;，指定时间戳强制I帧</span></span><br><span class="line">    in_picture-&gt;pict_type =</span><br><span class="line">        forced_kf_apply(ost, &amp;ost-&gt;kf, enc-&gt;time_base, in_picture, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传帧进去开始编码</span></span><br><span class="line">    ret = <span class="built_in">submit_encode_frame</span>(of, ost, in_picture);</span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 更新时间戳和帧号</span></span><br><span class="line">    ost-&gt;next_pts++;</span><br><span class="line">    ost-&gt;vsync_frame_number++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_frame_unref</span>(ost-&gt;last_frame);</span><br><span class="line">  <span class="keyword">if</span> (next_picture)</span><br><span class="line">    <span class="built_in">av_frame_move_ref</span>(ost-&gt;last_frame, next_picture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init_output_stream函数分析在<a href="/2024/04/13/FFmpeg%E8%BD%AC%E7%A0%81%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/" title="FFmpeg转码操作（二）">FFmpeg转码操作（二）</a>中</p>
<h3 id="submit-encode-frame函数"><a href="#submit-encode-frame函数" class="headerlink" title="submit_encode_frame函数"></a>submit_encode_frame函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交给编码队列进行编码</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">submit_encode_frame</span><span class="params">(OutputFile *of, OutputStream *ost,</span></span></span><br><span class="line"><span class="params"><span class="function">                               AVFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 如果sq_idx_encode小于0，表示不使用编码队列，直接进行编码</span></span><br><span class="line">  <span class="keyword">if</span> (ost-&gt;sq_idx_encode &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">encode_frame</span>(of, ost, frame);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在帧，将帧引用到输出流的sq_frame中，如果引用失败，返回错误</span></span><br><span class="line">  <span class="keyword">if</span> (frame) &#123;</span><br><span class="line">    ret = <span class="built_in">av_frame_ref</span>(ost-&gt;sq_frame, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    frame = ost-&gt;sq_frame;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将帧通过编码队列的sq_send函数发送到编码队列中</span></span><br><span class="line">  <span class="comment">// SQFRAME宏可能是对帧的一种封装，具体实现需要查看代码或文档</span></span><br><span class="line">  ret = <span class="built_in">sq_send</span>(of-&gt;sq_encode, ost-&gt;sq_idx_encode, <span class="built_in">SQFRAME</span>(frame));</span><br><span class="line">  <span class="comment">// 如果发送失败，释放帧并返回错误</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame)</span><br><span class="line">      <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    <span class="keyword">if</span> (ret != AVERROR_EOF)</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环从编码队列接收编码后的帧，并进行编码和写入</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    AVFrame *enc_frame = ost-&gt;sq_frame;</span><br><span class="line">    <span class="comment">// 这里又是什么?</span></span><br><span class="line">    ret = <span class="built_in">sq_receive</span>(of-&gt;sq_encode, ost-&gt;sq_idx_encode, <span class="built_in">SQFRAME</span>(enc_frame));</span><br><span class="line">    <span class="comment">// 如果接收到EOF，表示编码队列已经空了，置enc_frame为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">      enc_frame = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果接收到错误，如果是EAGAIN表示队列为空，继续下一轮循环，否则返回错误</span></span><br><span class="line">      <span class="built_in">return</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN)) ? <span class="number">0</span> : ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用encode_frame函数对编码后的帧进行进一步编码并写入文件</span></span><br><span class="line">    ret = <span class="built_in">encode_frame</span>(of, ost, enc_frame);</span><br><span class="line">    <span class="comment">// 释放已编码的帧</span></span><br><span class="line">    <span class="keyword">if</span> (enc_frame)</span><br><span class="line">      <span class="built_in">av_frame_unref</span>(enc_frame);</span><br><span class="line">    <span class="comment">// 如果编码或写入过程中发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">        <span class="built_in">close_output_stream</span>(ost);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="encode-frame函数"><a href="#encode-frame函数" class="headerlink" title="encode_frame函数"></a>encode_frame函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">encode_frame</span><span class="params">(OutputFile *of, OutputStream *ost, AVFrame *frame)</span> </span>&#123;</span><br><span class="line">  AVCodecContext *enc = ost-&gt;enc_ctx;</span><br><span class="line">  AVPacket *pkt = ost-&gt;pkt;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *type_desc = <span class="built_in">av_get_media_type_string</span>(enc-&gt;codec_type);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *action = frame ? <span class="string">&quot;encode&quot;</span> : <span class="string">&quot;flush&quot;</span>;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 如果有待编码帧,打印编码前的日志</span></span><br><span class="line">  <span class="keyword">if</span> (frame) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;enc_stats_pre.io)</span><br><span class="line">      <span class="built_in">enc_stats_write</span>(ost, &amp;ost-&gt;enc_stats_pre, frame, <span class="literal">NULL</span>,</span><br><span class="line">                      ost-&gt;frames_encoded);</span><br><span class="line">    <span class="comment">// 更新编码帧数</span></span><br><span class="line">    ost-&gt;frames_encoded++;</span><br><span class="line">    <span class="comment">// 更新编码样本数</span></span><br><span class="line">    ost-&gt;samples_encoded += frame-&gt;nb_samples;</span><br><span class="line">    <span class="comment">// 编码前打印时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (debug_ts) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_INFO,</span><br><span class="line">             <span class="string">&quot;encoder &lt;- type:%s &quot;</span></span><br><span class="line">             <span class="string">&quot;frame_pts:%s frame_pts_time:%s time_base:%d/%d\n&quot;</span>,</span><br><span class="line">             type_desc, <span class="built_in">av_ts2str</span>(frame-&gt;pts),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(frame-&gt;pts, &amp;enc-&gt;time_base), enc-&gt;time_base.num,</span><br><span class="line">             enc-&gt;time_base.den);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_benchmark</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送给编码器进行编码，</span></span><br><span class="line">  <span class="comment">// flush_encoders函数传进来NULL的包会把编码器剩下的packet全部刷出来</span></span><br><span class="line">  ret = <span class="built_in">avcodec_send_frame</span>(enc, frame);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; !(ret == AVERROR_EOF &amp;&amp; !frame)) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(ost, AV_LOG_ERROR, <span class="string">&quot;Error submitting %s frame to the encoder\n&quot;</span>,</span><br><span class="line">           type_desc);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从编码器读pkt</span></span><br><span class="line">    ret = <span class="built_in">avcodec_receive_packet</span>(enc, pkt);</span><br><span class="line">    <span class="built_in">update_benchmark</span>(<span class="string">&quot;%s_%s %d.%d&quot;</span>, action, type_desc, ost-&gt;file_index,</span><br><span class="line">                     ost-&gt;index);</span><br><span class="line"></span><br><span class="line">    pkt-&gt;time_base = enc-&gt;time_base; <span class="comment">// pkt的时间基初始化为编码器的时间基</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if two pass, output log on success and EOF */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret &gt;= <span class="number">0</span> || ret == AVERROR_EOF) &amp;&amp; ost-&gt;logfile &amp;&amp; enc-&gt;stats_out)</span><br><span class="line">      <span class="built_in">fprintf</span>(ost-&gt;logfile, <span class="string">&quot;%s&quot;</span>, enc-&gt;stats_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从编码器读取数据包的结果处理</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">      <span class="built_in">av_assert0</span>(frame); <span class="comment">// should never happen during flushing</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">      <span class="built_in">of_output_packet</span>(of, pkt, ost, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_ERROR, <span class="string">&quot;%s encoding failed\n&quot;</span>, type_desc);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新视频统计</span></span><br><span class="line">    <span class="keyword">if</span> (enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">      <span class="built_in">update_video_stats</span>(ost, pkt, !!vstats_filename);</span><br><span class="line">    <span class="comment">// 编码后统计信息</span></span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;enc_stats_post.io)</span><br><span class="line">      <span class="built_in">enc_stats_write</span>(ost, &amp;ost-&gt;enc_stats_post, <span class="literal">NULL</span>, pkt,</span><br><span class="line">                      ost-&gt;packets_encoded);</span><br><span class="line">    <span class="comment">// 从编码器读取到编码后的 AVPacket 的时候时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (debug_ts) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_INFO,</span><br><span class="line">             <span class="string">&quot;encoder -&gt; type:%s &quot;</span></span><br><span class="line">             <span class="string">&quot;pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s &quot;</span></span><br><span class="line">             <span class="string">&quot;duration:%s duration_time:%s\n&quot;</span>,</span><br><span class="line">             type_desc, <span class="built_in">av_ts2str</span>(pkt-&gt;pts),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;pts, &amp;enc-&gt;time_base), <span class="built_in">av_ts2str</span>(pkt-&gt;dts),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;dts, &amp;enc-&gt;time_base), <span class="built_in">av_ts2str</span>(pkt-&gt;duration),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;duration, &amp;enc-&gt;time_base));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换AVPacket的时间基从编码器时间基到muxer的时间基</span></span><br><span class="line">    <span class="built_in">av_packet_rescale_ts</span>(pkt, pkt-&gt;time_base, ost-&gt;mux_timebase);</span><br><span class="line">    pkt-&gt;time_base = ost-&gt;mux_timebase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从编码器出来的 AVPacket 的 pts 的 time_base</span></span><br><span class="line">    <span class="comment">// 是编码器的时间戳，这里要放进去 muxer， 需要转换成 muxer 的时间基</span></span><br><span class="line">    <span class="keyword">if</span> (debug_ts) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(ost, AV_LOG_INFO,</span><br><span class="line">             <span class="string">&quot;encoder -&gt; type:%s &quot;</span></span><br><span class="line">             <span class="string">&quot;pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s &quot;</span></span><br><span class="line">             <span class="string">&quot;duration:%s duration_time:%s\n&quot;</span>,</span><br><span class="line">             type_desc, <span class="built_in">av_ts2str</span>(pkt-&gt;pts),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;pts, &amp;enc-&gt;time_base), <span class="built_in">av_ts2str</span>(pkt-&gt;dts),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;dts, &amp;enc-&gt;time_base), <span class="built_in">av_ts2str</span>(pkt-&gt;duration),</span><br><span class="line">             <span class="built_in">av_ts2timestr</span>(pkt-&gt;duration, &amp;enc-&gt;time_base));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">trigger_fix_sub_duration_heartbeat</span>(ost, pkt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;Subtitle heartbeat logic failed in %s! (%s)\n&quot;</span>, __func__,</span><br><span class="line">             <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ost-&gt;data_size_enc += pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">    ost-&gt;packets_encoded++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能会先把 AVPacket</span></span><br><span class="line">    <span class="comment">// 写入队列，而不是写到文件，因为必须等所有的输出流都初始化完成才能写入头信息，</span></span><br><span class="line">    <span class="comment">// 只有写入了头信息，才能开始写 AVPacket。</span></span><br><span class="line">    <span class="comment">// 编码出来一个视频帧</span></span><br><span class="line">    <span class="comment">// AVPacket，但是音频输出流还未初始化，所以头信息未写入，因此这个视频帧需要先写到队列缓存下来。</span></span><br><span class="line">    <span class="built_in">of_output_packet</span>(of, pkt, ost, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_assert0</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/04/13/FFmpeg%E8%BD%AC%E7%A0%81%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89/">https://charstr.github.io/2024/04/13/FFmpeg%E8%BD%AC%E7%A0%81%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/FFmpeg/"># FFmpeg</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/04/13/FFmpeg%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">FFmpeg基本数据结构</a>
                      
                        
                          <a class="next" rel="next" href="/2024/04/13/FFmpeg%E8%BD%AC%E7%A0%81%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89/">FFmpeg转码操作（四）</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>