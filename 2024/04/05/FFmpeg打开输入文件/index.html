<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lly">





<title>FFmpeg打开输入文件 | lly&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">
                    lly&#39;s Blog
                </a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">
                        博客
                    </a>
                    
                    <a class="menu-item" href="/category">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/tag">
                        标签
                    </a>
                    
                    <a class="menu-item" href="/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">
                            lly&#39;s Blog
                        </a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">
                            博客
                        </a>
                        
                        <a class="menu-item" href="/category">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/tag">
                            标签
                        </a>
                        
                        <a class="menu-item" href="/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
  
    
      <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">回到底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? '全部展开' : '全部折叠';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
        

          
            <article class="post-wrap">
              <header class="post-header">
                <h1 class="post-title">
                  FFmpeg打开输入文件
                </h1>
                
                  <div class="post-meta">
                    
                      Author: <a itemprop="author" rel="author" href="/">lly</a>
                      

                        
                          <span class="post-time">
                            Date: <a href="#">4月 5, 2024&nbsp;&nbsp;16:37:25</a>
                          </span>
                          
                            
                              <span class="post-category">
                                Category:
                                
                                  <a href="/categories/FFmpeg/">FFmpeg</a>
                                  
                              </span>
                              
                  </div>
                  
              </header>

              <div class="post-content">
                <p>open_files函数通过回调ifile_open打开单个输入文件并进行一系列的处理。</p>
<h1 id="ifile-open函数"><a href="#ifile-open函数" class="headerlink" title="ifile_open函数"></a>ifile_open函数</h1><ol>
<li><p>主要实现打开一个文件，获取封装和解码信息，seek源文件等功能，信息保存在Demuxer结构体里。有时间戳-ss start_time，-sseof start_time_eof，-to stop_time，-t recording_time以及一些其他参数的处理。</p>
</li>
<li><p><strong>recording_time处理。</strong>1）同时指定-t recording_time和 -to stop_time，使用-t参数，忽略-to（设置stop_time为INT64_MAX）；2）指定了结束时间-to但未指定录制时长-t，结束时间-to和起始时间-ss（没有指定-ss就是0）的差就是recording_time（-t）。</p>
</li>
<li><p>1）如果指定了参数-f fmt，调用av_find_input_format遍历检查设置的输入文件格式。2）<strong>avformat_alloc_context给AVFormatContext *ic输入文件格式上下文申请内存；</strong>3）根据命令行输入的音视频通道、像素格式等信息设置基本属性；4）MATCH_PER_TYPE_OPT宏根据名称“v a s d”匹配视频、音频、字幕和数据流的解码器并设置对应的解码器以及解码器ID；5）设置av_read_frame函数为非阻塞。</p>
</li>
<li><p>1）<strong>avformat_open_input打开输入文件并获取输入文件的AVFormatContext封装格式上下文信息</strong>；2）avformat_find_stream_info获取流的参数信息，如果初始的流参数信息不够，需要解码流中的第一帧来获取更多的参数信息，<strong>对参数AVFormatContext进行更详细的设置。</strong></p>
</li>
<li><p><strong>seek的时间戳处理。</strong></p>
<ol>
<li><p>同时启用-ss(start_time，从指定时间开始处理)和 -sseof(start_time_eof，负值，从文件末尾倒数的时间开始处理)，存在冲突，忽略 -sseof 选项（start_time_eof设置为AV_NOPTS_VALUE无效时间戳，表示没有指定-sseof）。</p>
</li>
<li><p>没有启用-ss start_time但是启用了-sseof start_time_eof（小于0），如果输入文件持续时间ic-&gt;duration&gt;0，那么start_time = start_time_eof + ic-&gt;duration;得到开始处理文件的绝对时间戳，这个时间是相对于0的。</p>
</li>
<li><p>进行seek的时间戳初始值timestamp默认为开始处理的时间戳start_time，如果没有指定-seek_timestamp选项且输入文件的起始时间戳ic-&gt;start_time已知，timestamp += ic-&gt;start_time;进行seek的时间戳timestamp变成了相对于文件起始时间的。</p>
</li>
<li><p>如果开始处理的时间start_time!= AV_NOPTS_VALUE（不管是相对于0还是文件起始时间）是有效的，就要进行seek操作。默认使用PTS进行seek，如果video_delay也就是文件有B帧，存在DTS delay(DTS和PTS时间戳不一致)，启用dts_heuristic对DTS进行启发式修正seek_timestamp -= 3*AV_TIME_BASE / 23;也就是把时间提前3/23秒。因为视频解码需要事先缓冲几帧,seek到PTS位置就晚了,应该提前一点seek到DTS位置。</p>
</li>
<li><p>通过avformat_seek_file函数进行seek操作。</p>
</li>
</ol>
</li>
<li><p><strong>allocate_array_elem函数给全局输入文件数组input_files分配内存扩容，并将AVFormatContext保存给InputFile的AVFormatContext *ctx变量，到这里完成了输入文件所有信息的解析。</strong>add_input_streams(o, d)添加所有输入文件的中的流到Demuxer中输入文件InputFile f的InputStream **streams输入流结构体指针数组，更新OptionsContext参数。</p>
</li>
<li><p>如果同时指定了-re和-readrate，默认采用-readrate。<strong>设置解复用器线程队列的大小thread_queue_size。如果没有输入参数默认为-1（根据输入文件的数量由ffmpeg决定）</strong></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ifile_open</span><span class="params">(<span class="type">const</span> OptionsContext *o, <span class="type">const</span> <span class="type">char</span> *filename)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// const OptionsContext *o是解析得到的参数</span></span><br><span class="line">  Demuxer *d; <span class="comment">// Demuxer结构体指针，用于存储解封装器信息，每个文件一个？</span></span><br><span class="line">  InputFile *f; <span class="comment">// InputFile结构体指针，用于存储输入文件的信息</span></span><br><span class="line">  AVFormatContext *ic; <span class="comment">// FFmpeg格式上下文，表示输入文件的格式信息</span></span><br><span class="line">  <span class="type">const</span> AVInputFormat *file_iformat = <span class="literal">NULL</span>; <span class="comment">// 指向输入文件格式的指针</span></span><br><span class="line">  <span class="type">int</span> err, i, ret;   <span class="comment">// 用于存储错误码和循环变量</span></span><br><span class="line">  <span class="type">int64_t</span> timestamp; <span class="comment">// 存储时间戳</span></span><br><span class="line"></span><br><span class="line">  AVDictionary *unused_opts = <span class="literal">NULL</span>;  <span class="comment">// 用于存储未使用的选项</span></span><br><span class="line">  <span class="type">const</span> AVDictionaryEntry *e = <span class="literal">NULL</span>; <span class="comment">// 用于迭代字典中的条目</span></span><br><span class="line">  <span class="type">char</span> *video_codec_name = <span class="literal">NULL</span>;     <span class="comment">// 存储视频编码器名称</span></span><br><span class="line">  <span class="type">char</span> *audio_codec_name = <span class="literal">NULL</span>;     <span class="comment">// 存储音频编码器名称</span></span><br><span class="line">  <span class="type">char</span> *subtitle_codec_name = <span class="literal">NULL</span>;  <span class="comment">// 存储字幕编码器名称</span></span><br><span class="line">  <span class="type">char</span> *data_codec_name = <span class="literal">NULL</span>;      <span class="comment">// 存储数据流编码器名称</span></span><br><span class="line">  <span class="type">int</span> scan_all_pmts_set = <span class="number">0</span>; <span class="comment">// 标志位，指示是否设置了scan_all_pmts选项</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> start_time = o-&gt;start_time; <span class="comment">// 用户指定的起始时间 -ss</span></span><br><span class="line">  <span class="type">int64_t</span> start_time_eof =</span><br><span class="line">      o-&gt;start_time_eof; <span class="comment">// 用户指定的结束时间（文件末尾）-sseof</span></span><br><span class="line">  <span class="type">int64_t</span> stop_time = o-&gt;stop_time;           <span class="comment">// 用户指定的停止时间 -to</span></span><br><span class="line">  <span class="type">int64_t</span> recording_time = o-&gt;recording_time; <span class="comment">// 用户指定的录制时长 -t</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果同时指定了结束时间和录制时长，忽略结束时间并输出警告</span></span><br><span class="line">  <span class="keyword">if</span> (stop_time != INT64_MAX &amp;&amp; recording_time != INT64_MAX) &#123;</span><br><span class="line">    stop_time = INT64_MAX;</span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;-t and -to cannot be used together; using -t.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同时指定了结束时间和录制时长，选择录制时长，并输出警告</span></span><br><span class="line">  <span class="keyword">if</span> (stop_time != INT64_MAX &amp;&amp; recording_time == INT64_MAX) &#123;</span><br><span class="line">    <span class="type">int64_t</span> start = start_time == AV_NOPTS_VALUE ? <span class="number">0</span> : start_time;</span><br><span class="line">    <span class="keyword">if</span> (stop_time &lt;= start) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;-to value smaller than -ss; aborting.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      recording_time = stop_time - start;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果用户指定了输入文件格式，查找对应的输入格式</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;format) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(file_iformat = <span class="built_in">av_find_input_format</span>(o-&gt;format))) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Unknown input format: &#x27;%s&#x27;\n&quot;</span>, o-&gt;format);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    filename = <span class="string">&quot;fd:&quot;</span>;</span><br><span class="line"></span><br><span class="line">  stdin_interaction &amp;= <span class="built_in">strncmp</span>(filename, <span class="string">&quot;pipe:&quot;</span>, <span class="number">5</span>) &amp;&amp;</span><br><span class="line">                       <span class="built_in">strcmp</span>(filename, <span class="string">&quot;fd:&quot;</span>) &amp;&amp;</span><br><span class="line">                       <span class="built_in">strcmp</span>(filename, <span class="string">&quot;/dev/stdin&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get default parameters from command line */</span></span><br><span class="line">  <span class="comment">// 分配AVFormatContext结构体，用于存储输入文件的格式信息</span></span><br><span class="line">  <span class="comment">// 给io_open函数指针赋值，</span></span><br><span class="line">  ic = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">  <span class="keyword">if</span> (!ic)</span><br><span class="line">    <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*-------------音频相关的参数配置-----------------------*/</span></span><br><span class="line">  <span class="comment">// 设置音频采样率，这里一般是命令行输入的参数</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_audio_sample_rate) &#123;</span><br><span class="line">    <span class="built_in">av_dict_set_int</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;sample_rate&quot;</span>,</span><br><span class="line">                    o-&gt;audio_sample_rate[o-&gt;nb_audio_sample_rate - <span class="number">1</span>].u.i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置音频通道数，输入的-ac参数作用输入源</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_audio_channels) &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *priv_class;</span><br><span class="line">    <span class="keyword">if</span> (file_iformat &amp;&amp; (priv_class = file_iformat-&gt;priv_class) &amp;&amp;</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;priv_class, <span class="string">&quot;ch_layout&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                    AV_OPT_SEARCH_FAKE_OBJ)) &#123;</span><br><span class="line">      <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">      <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%dC&quot;</span>,</span><br><span class="line">               o-&gt;audio_channels[o-&gt;nb_audio_channels - <span class="number">1</span>].u.i);</span><br><span class="line">      <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;ch_layout&quot;</span>, buf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置音频通道布局 -channel_layout, -ch_layout</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_audio_ch_layouts) &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *priv_class;</span><br><span class="line">    <span class="keyword">if</span> (file_iformat &amp;&amp; (priv_class = file_iformat-&gt;priv_class) &amp;&amp;</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;priv_class, <span class="string">&quot;ch_layout&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                    AV_OPT_SEARCH_FAKE_OBJ)) &#123;</span><br><span class="line">      <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;ch_layout&quot;</span>,</span><br><span class="line">                  o-&gt;audio_ch_layouts[o-&gt;nb_audio_ch_layouts - <span class="number">1</span>].u.str, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*-------------视频相关的参数配置-----------------------*/</span></span><br><span class="line">  <span class="comment">// 设置帧率</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_frame_rates) &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *priv_class;</span><br><span class="line">    <span class="comment">/* set the format-level framerate option;</span></span><br><span class="line"><span class="comment">     * this is important for video grabbers, e.g. x11 */</span></span><br><span class="line">    <span class="keyword">if</span> (file_iformat &amp;&amp; (priv_class = file_iformat-&gt;priv_class) &amp;&amp;</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;priv_class, <span class="string">&quot;framerate&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                    AV_OPT_SEARCH_FAKE_OBJ)) &#123;</span><br><span class="line">      <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;framerate&quot;</span>,</span><br><span class="line">                  o-&gt;frame_rates[o-&gt;nb_frame_rates - <span class="number">1</span>].u.str, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置视频尺寸</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_frame_sizes) &#123;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;video_size&quot;</span>,</span><br><span class="line">                o-&gt;frame_sizes[o-&gt;nb_frame_sizes - <span class="number">1</span>].u.str, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置像素格式</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;nb_frame_pix_fmts)</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;pixel_format&quot;</span>,</span><br><span class="line">                o-&gt;frame_pix_fmts[o-&gt;nb_frame_pix_fmts - <span class="number">1</span>].u.str, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上音视频参数的设置通过输入参数</span></span><br><span class="line">  <span class="comment">/*---------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 匹配视频、音频、字母、数据流的编码器名称</span></span><br><span class="line">  <span class="built_in">MATCH_PER_TYPE_OPT</span>(codec_names, str, video_codec_name, ic, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">  <span class="built_in">MATCH_PER_TYPE_OPT</span>(codec_names, str, audio_codec_name, ic, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="built_in">MATCH_PER_TYPE_OPT</span>(codec_names, str, subtitle_codec_name, ic, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">  <span class="built_in">MATCH_PER_TYPE_OPT</span>(codec_names, str, data_codec_name, ic, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">  <span class="comment">// 查找对应的编码器</span></span><br><span class="line">  <span class="keyword">if</span> (video_codec_name)</span><br><span class="line">    ic-&gt;video_codec =</span><br><span class="line">        <span class="built_in">find_codec_or_die</span>(<span class="literal">NULL</span>, video_codec_name, AVMEDIA_TYPE_VIDEO, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_codec_name)</span><br><span class="line">    ic-&gt;audio_codec =</span><br><span class="line">        <span class="built_in">find_codec_or_die</span>(<span class="literal">NULL</span>, audio_codec_name, AVMEDIA_TYPE_AUDIO, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (subtitle_codec_name)</span><br><span class="line">    ic-&gt;subtitle_codec =</span><br><span class="line">        <span class="built_in">find_codec_or_die</span>(<span class="literal">NULL</span>, subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (data_codec_name)</span><br><span class="line">    ic-&gt;data_codec =</span><br><span class="line">        <span class="built_in">find_codec_or_die</span>(<span class="literal">NULL</span>, data_codec_name, AVMEDIA_TYPE_DATA, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置编码器ID</span></span><br><span class="line">  ic-&gt;video_codec_id =</span><br><span class="line">      video_codec_name ? ic-&gt;video_codec-&gt;id : AV_CODEC_ID_NONE;</span><br><span class="line">  ic-&gt;audio_codec_id =</span><br><span class="line">      audio_codec_name ? ic-&gt;audio_codec-&gt;id : AV_CODEC_ID_NONE;</span><br><span class="line">  ic-&gt;subtitle_codec_id =</span><br><span class="line">      subtitle_codec_name ? ic-&gt;subtitle_codec-&gt;id : AV_CODEC_ID_NONE;</span><br><span class="line">  ic-&gt;data_codec_id = data_codec_name ? ic-&gt;data_codec-&gt;id : AV_CODEC_ID_NONE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置AVFormatContext的标志位和中断回调函数</span></span><br><span class="line">  ic-&gt;flags |= AVFMT_FLAG_NONBLOCK; <span class="comment">// 设置非阻塞标志位</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;bitexact)</span><br><span class="line">    ic-&gt;flags |= AVFMT_FLAG_BITEXACT; <span class="comment">// 设置比特精确标志位</span></span><br><span class="line">  ic-&gt;interrupt_callback = int_cb;    <span class="comment">// 设置中断回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在输入过程中是否扫描所有的PMT（Program Map Table）,默认为1</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">av_dict_get</span>(o-&gt;g-&gt;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                   AV_DICT_MATCH_CASE)) &#123;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                AV_DICT_DONT_OVERWRITE);</span><br><span class="line">    scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* open the input file with generic avformat function */</span></span><br><span class="line">  <span class="comment">// 打开输入文件，解复用也是走到这里，调用解复用器的read_probe函数回调，进行探测</span></span><br><span class="line">  err = <span class="built_in">avformat_open_input</span>(&amp;ic, filename, file_iformat, &amp;o-&gt;g-&gt;format_opts);</span><br><span class="line">  <span class="comment">// 打开后就有了AVStream以及code_id，到这里确定了封装格式</span></span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print_error</span>(filename, err);</span><br><span class="line">    <span class="keyword">if</span> (err == AVERROR_PROTOCOL_NOT_FOUND)</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Did you mean file:%s?\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果设置了scan_all_pmts选项，从o-&gt;g-&gt;format_opts中移除该选项，干什么的？</span></span><br><span class="line">  <span class="keyword">if</span> (scan_all_pmts_set)</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;o-&gt;g-&gt;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE);</span><br><span class="line">  <span class="comment">// 从 o-&gt;g-&gt;format_opts 中移除与 o-&gt;g-&gt;codec_opts</span></span><br><span class="line">  <span class="comment">// 中相同的选项。确保不会有相同的选项被重复设置</span></span><br><span class="line">  <span class="built_in">remove_avoptions</span>(&amp;o-&gt;g-&gt;format_opts, o-&gt;g-&gt;codec_opts);</span><br><span class="line">  <span class="built_in">assert_avoptions</span>(</span><br><span class="line">      o-&gt;g-&gt;format_opts); <span class="comment">// 确保 o-&gt;g-&gt;format_opts 所有选项都已经被使用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* apply forced codec ids */</span></span><br><span class="line">  <span class="comment">// 应用强制编解码器选项</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++)</span><br><span class="line">    <span class="built_in">choose_decoder</span>(o, ic, ic-&gt;streams[i], HWACCEL_NONE, AV_HWDEVICE_TYPE_NONE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行文件信息的查找和解析操作，填充AVFormatContext结构体</span></span><br><span class="line">  <span class="keyword">if</span> (o-&gt;find_stream_info) &#123;</span><br><span class="line">    AVDictionary **opts = <span class="built_in">setup_find_stream_info_opts</span>(ic, o-&gt;g-&gt;codec_opts);</span><br><span class="line">    <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If not enough info to get the stream parameters, we decode the</span></span><br><span class="line"><span class="comment">       first frames to get it. (used in mpeg case for example) */</span></span><br><span class="line">    <span class="comment">// 对于FLV文件，头信息不包括流以及编解码信息，所以会在这里创建流</span></span><br><span class="line">    ret = <span class="built_in">avformat_find_stream_info</span>(ic, opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orig_nb_streams; i++)</span><br><span class="line">      <span class="built_in">av_dict_free</span>(&amp;opts[i]);</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;%s: could not find codec parameters\n&quot;</span>,</span><br><span class="line">             filename);</span><br><span class="line">      <span class="keyword">if</span> (ic-&gt;nb_streams == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;ic);</span><br><span class="line">        <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理用户指定的时间戳参数</span></span><br><span class="line">  <span class="comment">// 如果同时启用了-ss（表示从指定时间开始处理）和</span></span><br><span class="line">  <span class="comment">// -sseof（表示从文件末尾倒数的时间开始处理），存在冲突。</span></span><br><span class="line">  <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE &amp;&amp; start_time_eof != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Cannot use -ss and -sseof both, using -ss for %s\n&quot;</span>, filename);</span><br><span class="line">    <span class="comment">// 忽略-sseof选项，将start_time_eof设置为AV_NOPTS_VALUE，表示没有指定-sseof。</span></span><br><span class="line">    start_time_eof = AV_NOPTS_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果用户指定了-sseof选项</span></span><br><span class="line">  <span class="keyword">if</span> (start_time_eof != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    <span class="comment">// 如果指定的-sseof的值不为负数，输出错误信息，终止程序。</span></span><br><span class="line">    <span class="keyword">if</span> (start_time_eof &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;-sseof value must be negative; aborting\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果输入文件的持续时间已知</span></span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据-sseof的值和输入文件的持续时间计算start_time（处理的起始时间点）</span></span><br><span class="line">      start_time = start_time_eof + ic-&gt;duration;</span><br><span class="line">      <span class="comment">// 如果计算得到的start_time小于0，说明-sseof的值超出了文件的起始时间，输出警告信息，将start_time设置为AV_NOPTS_VALUE。</span></span><br><span class="line">      <span class="keyword">if</span> (start_time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">               <span class="string">&quot;-sseof value seeks to before start of file %s; ignored\n&quot;</span>,</span><br><span class="line">               filename);</span><br><span class="line">        start_time = AV_NOPTS_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果输入文件的持续时间未知，输出警告信息，无法使用-sseof选项</span></span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">             <span class="string">&quot;Cannot use -sseof, duration of %s not known\n&quot;</span>, filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据用户指定的输入文件起始时间-ss</span></span><br><span class="line">  <span class="comment">// start_time和输入文件元数据的起始时间（ic-&gt;start_time） 设置 timestamp</span></span><br><span class="line">  <span class="comment">// 变量，用于存储处理的时间戳</span></span><br><span class="line">  timestamp = (start_time == AV_NOPTS_VALUE) ? <span class="number">0</span> : start_time;</span><br><span class="line">  <span class="comment">/* add the stream start time */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果用户没有指定-seek_timestamp选项且输入文件的起始时间已知，将timestamp加上输入文件的起始时间。</span></span><br><span class="line">  <span class="keyword">if</span> (!o-&gt;seek_timestamp &amp;&amp; ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">    timestamp += ic-&gt;start_time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果用户指定了-seek_timestamp选项，执行seek操作</span></span><br><span class="line">  <span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line">  <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    <span class="comment">// 计算seek的时间戳，如果输入文件格式不支持PTS方式的seek，进行时间戳修正</span></span><br><span class="line">    <span class="type">int64_t</span> seek_timestamp = timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ic-&gt;iformat-&gt;flags &amp; AVFMT_SEEK_TO_PTS)) &#123;</span><br><span class="line">      <span class="type">int</span> dts_heuristic = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果存在视频流并且视频流的参数中有video_delay，就是DTS和PTS时间戳不一致</span></span><br><span class="line">      <span class="comment">// 说明视频流的DTS需要启发式修正。</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodecParameters *par = ic-&gt;streams[i]-&gt;codecpar;</span><br><span class="line">        <span class="keyword">if</span> (par-&gt;video_delay) &#123;</span><br><span class="line">          dts_heuristic = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果需要DTS启发式修正，将seek_timestamp减去3秒。</span></span><br><span class="line">      <span class="keyword">if</span> (dts_heuristic) &#123;</span><br><span class="line">        seek_timestamp -= <span class="number">3</span> * AV_TIME_BASE / <span class="number">23</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行seek操作，将文件位置移动到指定的时间戳,av_seek_frame实现，seek_frame_internal</span></span><br><span class="line">    ret = <span class="built_in">avformat_seek_file</span>(ic, <span class="number">-1</span>, INT64_MIN, seek_timestamp, seek_timestamp,</span><br><span class="line">                             <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果seek操作失败，输出警告信息，指示无法定位到指定的位置。</span></span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">             filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给输入文件结构体指针数组扩容，大小为什么是sizeof(*d)</span></span><br><span class="line">  <span class="comment">// 192不是sizeof(InputFile) 128</span></span><br><span class="line">  d = <span class="built_in">allocate_array_elem</span>(&amp;input_files, <span class="built_in">sizeof</span>(*d), &amp;nb_input_files);</span><br><span class="line">  f = &amp;d-&gt;f; <span class="comment">// Demuxer-&gt;InputFile</span></span><br><span class="line"></span><br><span class="line">  f-&gt;ctx = ic;</span><br><span class="line">  f-&gt;index = nb_input_files - <span class="number">1</span>;</span><br><span class="line">  f-&gt;start_time = start_time;</span><br><span class="line">  f-&gt;recording_time = recording_time;</span><br><span class="line">  f-&gt;input_sync_ref = o-&gt;input_sync_ref;</span><br><span class="line">  f-&gt;input_ts_offset = o-&gt;input_ts_offset;</span><br><span class="line">  f-&gt;ts_offset = o-&gt;input_ts_offset -</span><br><span class="line">                 (copy_ts ? (start_at_zero &amp;&amp; ic-&gt;start_time != AV_NOPTS_VALUE</span><br><span class="line">                                 ? ic-&gt;start_time</span><br><span class="line">                                 : <span class="number">0</span>)</span><br><span class="line">                          : timestamp); <span class="comment">// 偏移</span></span><br><span class="line">  f-&gt;rate_emu =</span><br><span class="line">      o-&gt;rate_emu; <span class="comment">// 指定-re 限制 FFmpeg 的读取速度，使其不超过输入文件的帧率。</span></span><br><span class="line">  f-&gt;accurate_seek = o-&gt;accurate_seek;</span><br><span class="line">  d-&gt;loop = o-&gt;loop;</span><br><span class="line">  d-&gt;duration = <span class="number">0</span>;</span><br><span class="line">  d-&gt;time_base = (AVRational)&#123;<span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">// 初始时间基</span></span><br><span class="line"></span><br><span class="line">  f-&gt;readrate =</span><br><span class="line">      o-&gt;readrate ? o-&gt;readrate : <span class="number">0.0</span>; <span class="comment">// 指定输入文件的读取速度，以倍数表示。</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;readrate &lt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(</span><br><span class="line">        <span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">        <span class="string">&quot;Option -readrate for Input #%d is %0.3f; it must be non-negative.\n&quot;</span>,</span><br><span class="line">        f-&gt;index, f-&gt;readrate);</span><br><span class="line">    <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;readrate &amp;&amp; f-&gt;rate_emu) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\n&quot;</span>,</span><br><span class="line">           f-&gt;index, f-&gt;readrate);</span><br><span class="line">    f-&gt;rate_emu = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// thread_queue_size参数，设置解复用器缓冲队列的大小</span></span><br><span class="line">  <span class="comment">// 如果有设置解复用器线程队列的大小</span></span><br><span class="line">  d-&gt;thread_queue_size = o-&gt;thread_queue_size;</span><br><span class="line">  <span class="comment">// Add all the streams from the given input file to the demuxer</span></span><br><span class="line">  <span class="comment">/* update the current parameters so that they match the one of the input</span></span><br><span class="line"><span class="comment">   * stream */</span></span><br><span class="line">  <span class="comment">// 把所有的输出流都添加到解复用器</span></span><br><span class="line">  <span class="built_in">add_input_streams</span>(o, d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* dump the file content */</span></span><br><span class="line">  <span class="built_in">av_dump_format</span>(ic, f-&gt;index, filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check if all codec options have been used */</span></span><br><span class="line">  <span class="comment">// 检查是否有未使用的编解码器选项</span></span><br><span class="line">  unused_opts = <span class="built_in">strip_specifiers</span>(o-&gt;g-&gt;codec_opts);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;nb_streams; i++) &#123;</span><br><span class="line">    e = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((e = <span class="built_in">av_dict_iterate</span>(f-&gt;streams[i]-&gt;decoder_opts, e)))</span><br><span class="line">      <span class="built_in">av_dict_set</span>(&amp;unused_opts, e-&gt;key, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出警告信息，指示可能的问题</span></span><br><span class="line">  e = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> ((e = <span class="built_in">av_dict_iterate</span>(unused_opts, e))) &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span> = <span class="built_in">avcodec_get_class</span>();</span><br><span class="line">    <span class="type">const</span> AVOption *option =</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;<span class="keyword">class</span>, e-&gt;key, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                    AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);</span><br><span class="line">    <span class="type">const</span> AVClass *fclass = <span class="built_in">avformat_get_class</span>();</span><br><span class="line">    <span class="type">const</span> AVOption *foption =</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;fclass, e-&gt;key, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                    AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);</span><br><span class="line">    <span class="keyword">if</span> (!option || foption)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(option-&gt;flags &amp; AV_OPT_FLAG_DECODING_PARAM)) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;Codec AVOption %s (%s) specified for &quot;</span></span><br><span class="line">             <span class="string">&quot;input file #%d (%s) is not a decoding option.\n&quot;</span>,</span><br><span class="line">             e-&gt;key, option-&gt;help ? option-&gt;help : <span class="string">&quot;&quot;</span>, f-&gt;index, filename);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Codec AVOption %s (%s) specified for &quot;</span></span><br><span class="line">           <span class="string">&quot;input file #%d (%s) has not been used for any stream. The most &quot;</span></span><br><span class="line">           <span class="string">&quot;likely reason is either wrong type (e.g. a video option with &quot;</span></span><br><span class="line">           <span class="string">&quot;no video streams) or that it is a private option of some decoder &quot;</span></span><br><span class="line">           <span class="string">&quot;which was not actually used for any stream.\n&quot;</span>,</span><br><span class="line">           e-&gt;key, option-&gt;help ? option-&gt;help : <span class="string">&quot;&quot;</span>, f-&gt;index, filename);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">av_dict_free</span>(&amp;unused_opts);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理附件流的信息</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; o-&gt;nb_dump_attachment; i++) &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ic-&gt;nb_streams; j++) &#123;</span><br><span class="line">      AVStream *st = ic-&gt;streams[j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check_stream_specifier</span>(ic, st, o-&gt;dump_attachment[i].specifier) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">dump_attachment</span>(st, o-&gt;dump_attachment[i].u.str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="avformat-open-input函数"><a href="#avformat-open-input函数" class="headerlink" title="avformat_open_input函数"></a>avformat_open_input函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> AVInputFormat *fmt, AVDictionary **options)</span> </span>&#123;</span><br><span class="line">  AVFormatContext *s = *ps;</span><br><span class="line">  FFFormatContext *si;</span><br><span class="line">  AVDictionary *tmp = <span class="literal">NULL</span>;</span><br><span class="line">  ID3v2ExtraMeta *id3v2_extra_meta = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里要读取输入文件，并将信息解析到AVFormatContext **ps</span></span><br><span class="line">  <span class="comment">// ifile_open已经分配过内存，这里进行判断是否要重新分配内存，</span></span><br><span class="line">  <span class="comment">// 这时候里面的 stream是空的，avformat_open_input执行完才有数据</span></span><br><span class="line">  <span class="keyword">if</span> (!s &amp;&amp; !(s = <span class="built_in">avformat_alloc_context</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">  si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;av_class) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;Input context has not been properly allocated by &quot;</span></span><br><span class="line">           <span class="string">&quot;avformat_alloc_context() and is not NULL either\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 命令行是否指定-f mp4</span></span><br><span class="line">  <span class="keyword">if</span> (fmt)</span><br><span class="line">    s-&gt;iformat = fmt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options)</span><br><span class="line">    <span class="built_in">av_dict_copy</span>(&amp;tmp, *options, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;pb) <span class="comment">// must be before any goto fail</span></span><br><span class="line">    s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(s, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(s-&gt;url = <span class="built_in">av_strdup</span>(filename ? filename : <span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">    ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在未确定输入格式的时候，调用read_probe回调函数读取一段输入文件进行打分，</span></span><br><span class="line">  <span class="comment">// 确定输入文件格式</span></span><br><span class="line">  <span class="comment">// demuxer AVFormatContext</span></span><br><span class="line">  <span class="comment">// 对于mp4的是mov_probe函数，不会调用mov_read_header等系列函数 对于flv</span></span><br><span class="line">  <span class="keyword">if</span> ((ret = <span class="built_in">init_input</span>(s, filename, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  s-&gt;probe_score = ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;protocol_whitelist &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;protocol_whitelist) &#123;</span><br><span class="line">    s-&gt;protocol_whitelist = <span class="built_in">av_strdup</span>(s-&gt;pb-&gt;protocol_whitelist);</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;protocol_whitelist) &#123;</span><br><span class="line">      ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;protocol_blacklist &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;protocol_blacklist) &#123;</span><br><span class="line">    s-&gt;protocol_blacklist = <span class="built_in">av_strdup</span>(s-&gt;pb-&gt;protocol_blacklist);</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;protocol_blacklist) &#123;</span><br><span class="line">      ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;format_whitelist &amp;&amp;</span><br><span class="line">      <span class="built_in">av_match_list</span>(s-&gt;iformat-&gt;name, s-&gt;format_whitelist, <span class="string">&#x27;,&#x27;</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(s, AV_LOG_ERROR, <span class="string">&quot;Format not on whitelist \&#x27;%s\&#x27;\n&quot;</span>,</span><br><span class="line">           s-&gt;format_whitelist);</span><br><span class="line">    ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">avio_skip</span>(s-&gt;pb, s-&gt;skip_initial_bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check filename in case an image number is expected. */</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NEEDNUMBER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">av_filename_number_test</span>(filename)) &#123;</span><br><span class="line">      ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化了持续时间</span></span><br><span class="line">  s-&gt;duration = s-&gt;start_time = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate private data. */</span></span><br><span class="line">  <span class="comment">// 给私有数据分配内存</span></span><br><span class="line">  <span class="comment">// ff_mov_demuxer中的priv_data_size也就是sizeof(MOVContext)大小</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;iformat-&gt;priv_data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;priv_data = <span class="built_in">av_mallocz</span>(s-&gt;iformat-&gt;priv_data_size))) &#123;</span><br><span class="line">      ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝内存</span></span><br><span class="line">    <span class="comment">// AVFormatContext 是一个通用的数据结构，MP4，FLV 都用这个结构，但是不同的</span></span><br><span class="line">    <span class="comment">// Demuxer，内部的数据结构不一样，所以需要在 AVFormatContext里面绑定一个</span></span><br><span class="line">    <span class="comment">// priv_data（私有数据结构）比如在 MP4 Demuxer 的priv_data 是 MOVContext</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat-&gt;priv_class) &#123;</span><br><span class="line">      *(<span class="type">const</span> AVClass **)s-&gt;priv_data = s-&gt;iformat-&gt;priv_class;</span><br><span class="line">      <span class="built_in">av_opt_set_defaults</span>(s-&gt;priv_data); <span class="comment">// 设置 priv_data 的其他字段为默认值</span></span><br><span class="line">      <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(s-&gt;priv_data, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于mp4这里有值了</span></span><br><span class="line">  <span class="comment">/* e.g. AVFMT_NOFILE formats will not have an AVIOContext */</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;pb)</span><br><span class="line">    <span class="built_in">ff_id3v2_read_dict</span>(s-&gt;pb, &amp;si-&gt;id3v2_meta, ID3v2_DEFAULT_MAGIC,</span><br><span class="line">                       &amp;id3v2_extra_meta);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  init_input里边进行探测读读取的内存，指针又复位了，所以到这里的时候，AVIOContext</span></span><br><span class="line"><span class="comment">  中， buffer 是缓冲区的起始地址，buf_ptr 是已经消费的地址是一样。</span></span><br><span class="line"><span class="comment">  s-&gt;iforamt实际上就是定义的demuxer的类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  read_header函数指针，是在Demuxer类中定义的回调函数，读取头部进行解析</span></span><br><span class="line"><span class="comment">  如mp4格式在ff_mov_demuxer中定义的mov_read_header回调函数</span></span><br><span class="line"><span class="comment">  flv的ff_flv_demuxer中定义的flv_read_header函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;iformat-&gt;read_header) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;iformat-&gt;<span class="built_in">read_header</span>(s)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;iformat-&gt;flags_internal &amp; FF_FMT_INIT_CLEANUP)</span><br><span class="line">        <span class="keyword">goto</span> close;</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;metadata) &#123;</span><br><span class="line">    s-&gt;metadata = si-&gt;id3v2_meta;</span><br><span class="line">    si-&gt;id3v2_meta = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (si-&gt;id3v2_meta) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Discarding ID3 tags because more suitable tags were found.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;si-&gt;id3v2_meta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (id3v2_extra_meta) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;mp3&quot;</span>) || !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;aac&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;tta&quot;</span>) || !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;wav&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_apic</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> close;</span><br><span class="line">      <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_chapters</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> close;</span><br><span class="line">      <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_priv</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> close;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">av_log</span>(s, AV_LOG_DEBUG,</span><br><span class="line">             <span class="string">&quot;demuxer does not support additional id3 data, skipping\n&quot;</span>);</span><br><span class="line">    <span class="built_in">ff_id3v2_free_extra_meta</span>(&amp;id3v2_extra_meta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((ret = <span class="built_in">avformat_queue_attached_pictures</span>(s)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> close;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;pb &amp;&amp; !si-&gt;data_offset)</span><br><span class="line">    si-&gt;data_offset = <span class="built_in">avio_tell</span>(s-&gt;pb);</span><br><span class="line"></span><br><span class="line">  si-&gt;raw_packet_buffer_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_stream_avctx</span>(s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="built_in">av_dict_free</span>(options);</span><br><span class="line">    *options = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  *ps = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">close:</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;iformat-&gt;read_close)</span><br><span class="line">    s-&gt;iformat-&gt;<span class="built_in">read_close</span>(s);</span><br><span class="line">fail:</span><br><span class="line">  <span class="built_in">ff_id3v2_free_extra_meta</span>(&amp;id3v2_extra_meta);</span><br><span class="line">  <span class="built_in">av_dict_free</span>(&amp;tmp);</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;pb &amp;&amp; !(s-&gt;flags &amp; AVFMT_FLAG_CUSTOM_IO))</span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;s-&gt;pb);</span><br><span class="line">  <span class="built_in">avformat_free_context</span>(s);</span><br><span class="line">  *ps = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init-input函数"><a href="#init-input函数" class="headerlink" title="init_input函数"></a>init_input函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的Demuxer调用read_probe回调函数进行探测</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                      AVDictionary **options)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  AVProbeData pd = &#123;filename, <span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line">  <span class="comment">// 命令行-f mp4指定的是AVFormatContext-&gt;iformat</span></span><br><span class="line">  <span class="comment">// 处理用户层已经自定义了 AVIOContext 的场景</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">    <span class="comment">// avformat_open_input函数调用前后都申请了内存，这里会判断是否自定义了AVIOContext场景</span></span><br><span class="line">    s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令行没有指定，遍历所有没有 AVFMT_NOFILE 标记的 Demuxer</span></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">av_probe_input_buffer2</span>(s-&gt;pb, &amp;s-&gt;iformat, filename, s, <span class="number">0</span>,</span><br><span class="line">                                    s-&gt;format_probesize);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">      <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">             <span class="string">&quot;Custom AVIOContext makes no sense and &quot;</span></span><br><span class="line">             <span class="string">&quot;will be ignored with AVFMT_NOFILE format.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定了-f iformat直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// s-&gt;pb是NULL走到这里，一般都是没有指定的</span></span><br><span class="line">  <span class="comment">// 传 is_opened=0给av_probe_input_format2函数，遍历有 AVFMT_NOFILE 标记的</span></span><br><span class="line">  <span class="comment">// Demuxer， AVFMT_NOFILE字段由 Demuxer的属性决定，存储在flags 字段</span></span><br><span class="line">  <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">      (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = <span class="built_in">av_probe_input_format2</span>(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">  <span class="comment">// 这里给s-&gt;pb申请了内存</span></span><br><span class="line">  <span class="keyword">if</span> ((ret = s-&gt;<span class="built_in">io_open</span>(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags,</span><br><span class="line">                        options)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否指定了输入的文件格式</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;iformat)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// format_probesize也可以命令行指定</span></span><br><span class="line">  <span class="comment">// 遍历没有 AVFMT_NOFILE 标记的 Demuxer，是不需要执行 s-&gt;io_open()</span></span><br><span class="line">  <span class="comment">// 打开输入文件的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">av_probe_input_buffer2</span>(s-&gt;pb, &amp;s-&gt;iformat, filename, s, <span class="number">0</span>,</span><br><span class="line">                                s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="av-probe-input-buffer2函数"><a href="#av-probe-input-buffer2函数" class="headerlink" title="av_probe_input_buffer2函数"></a>av_probe_input_buffer2函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_probe_input_buffer2</span><span class="params">(AVIOContext *pb, <span class="type">const</span> AVInputFormat **fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">void</span> *logctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> max_probe_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AVProbeData pd = &#123;filename ? filename : <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>, probe_size, buf_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ret2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!max_probe_size)</span><br><span class="line">    max_probe_size = PROBE_BUF_MAX;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (max_probe_size &lt; PROBE_BUF_MIN) &#123;</span><br><span class="line">    <span class="built_in">av_log</span>(logctx, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;Specified probe size value %u cannot be &lt; %u\n&quot;</span>, max_probe_size,</span><br><span class="line">           PROBE_BUF_MIN);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (offset &gt;= max_probe_size)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pb-&gt;av_class) &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *mime_type_opt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *semi;</span><br><span class="line">    <span class="built_in">av_opt_get</span>(pb, <span class="string">&quot;mime_type&quot;</span>, AV_OPT_SEARCH_CHILDREN, &amp;mime_type_opt);</span><br><span class="line">    pd.mime_type = (<span class="type">const</span> <span class="type">char</span> *)mime_type_opt;</span><br><span class="line">    semi = pd.mime_type ? <span class="built_in">strchr</span>(pd.mime_type, <span class="string">&#x27;;&#x27;</span>) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (semi) &#123;</span><br><span class="line">      *semi = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次扩大读取的数据量两倍，直到确定fmt</span></span><br><span class="line">  <span class="keyword">for</span> (probe_size = PROBE_BUF_MIN; probe_size &lt;= max_probe_size &amp;&amp; !*fmt;</span><br><span class="line">       probe_size =</span><br><span class="line">           <span class="built_in">FFMIN</span>(probe_size &lt;&lt; <span class="number">1</span>, <span class="built_in">FFMAX</span>(max_probe_size, probe_size + <span class="number">1</span>))) &#123;</span><br><span class="line">    score = probe_size &lt; max_probe_size ? AVPROBE_SCORE_RETRY : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read probe data. */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_reallocp</span>(&amp;buf, probe_size + AVPROBE_PADDING_SIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pb里边的buffer，buf指向文件开始的地址，buf_offset相对起始的偏移，</span></span><br><span class="line">    <span class="comment">// 已经读取了buf_offset，现在总的要读取probe_size，所以需要再在buf +</span></span><br><span class="line">    <span class="comment">// buf_offset基础上再读 probe_size - buf_offset的数据</span></span><br><span class="line">    <span class="comment">// 读取数据给av_probe_input_format2里边通过回调函数read_probe进行探测</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">avio_read</span>(pb, buf + buf_offset, probe_size - buf_offset)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* Fail if error was not end of file, otherwise, lower score. */</span></span><br><span class="line">      <span class="keyword">if</span> (ret != AVERROR_EOF)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">      score = <span class="number">0</span>;</span><br><span class="line">      ret = <span class="number">0</span>; <span class="comment">/* error was end of file, nothing read */</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf_offset += ret; <span class="comment">// ret是读取的多少，读取多少，buf_offset偏移多少</span></span><br><span class="line">    <span class="keyword">if</span> (buf_offset &lt; offset)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    pd.buf_size = buf_offset - offset; <span class="comment">// 一共读取多少数据</span></span><br><span class="line">    pd.buf = &amp;buf[offset];</span><br><span class="line">    <span class="comment">// 内存对齐</span></span><br><span class="line">    <span class="built_in">memset</span>(pd.buf + pd.buf_size, <span class="number">0</span>, AVPROBE_PADDING_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Guess file format. */</span></span><br><span class="line">    <span class="comment">// 读取了数据进行探测</span></span><br><span class="line">    *fmt = <span class="built_in">av_probe_input_format2</span>(&amp;pd, <span class="number">1</span>, &amp;score);</span><br><span class="line">    <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">      <span class="comment">/* This can only be true in the last iteration. */</span></span><br><span class="line">      <span class="keyword">if</span> (score &lt;= AVPROBE_SCORE_RETRY) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(logctx, AV_LOG_WARNING,</span><br><span class="line">               <span class="string">&quot;Format %s detected only with low score of %d, &quot;</span></span><br><span class="line">               <span class="string">&quot;misdetection possible!\n&quot;</span>,</span><br><span class="line">               (*fmt)-&gt;name, score);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">av_log</span>(logctx, AV_LOG_DEBUG,</span><br><span class="line">               <span class="string">&quot;Format %s probed with size=%d and score=%d\n&quot;</span>, (*fmt)-&gt;name,</span><br><span class="line">               probe_size, score);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            FILE *f = <span class="built_in">fopen</span>(<span class="string">&quot;probestat.tmp&quot;</span>, <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(f, <span class="string">&quot;probe_size:%d format:%s score:%d filename:%s\n&quot;</span>, probe_size, (*fmt)-&gt;name, score, filename);</span><br><span class="line">            <span class="built_in">fclose</span>(f);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!*fmt)</span><br><span class="line">    ret = AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Rewind. Reuse probe buffer to avoid seeking. */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里相当于是把指针进行了移动， avio_read读取的时候指针发生偏移，这里把指针</span></span><br><span class="line"><span class="comment">  s-&gt;buf_ptr 指针指向文件的第一个字节</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ret2 = <span class="built_in">ffio_rewind_with_probe_data</span>(pb, &amp;buf, buf_offset);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">    ret = ret2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">av_freep</span>(&amp;pd.mime_type);</span><br><span class="line">  <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="avformat-find-stream-info函数"><a href="#avformat-find-stream-info函数" class="headerlink" title="avformat_find_stream_info函数"></a>avformat_find_stream_info函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> max_analyze_duration =</span><br><span class="line">      ic-&gt;max_analyze_duration; <span class="comment">// 是否有指定的最大探测时长</span></span><br><span class="line">  <span class="type">int64_t</span> max_stream_analyze_duration;</span><br><span class="line">  <span class="type">int64_t</span> max_subtitle_analyze_duration;</span><br><span class="line">  <span class="type">int64_t</span> probesize =</span><br><span class="line">      ic-&gt;probesize; <span class="comment">// 探测的大小默认 5000000,在avformat_options设置</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  max_stream_analyze_duration = max_analyze_duration;</span><br><span class="line">  max_subtitle_analyze_duration = max_analyze_duration;</span><br><span class="line">  <span class="keyword">if</span> (!max_analyze_duration) &#123;</span><br><span class="line">    <span class="comment">// 没有指定就是5*AV_TIME_BASE</span></span><br><span class="line">    max_stream_analyze_duration = max_analyze_duration = <span class="number">5</span> * AV_TIME_BASE;</span><br><span class="line">    max_subtitle_analyze_duration = <span class="number">30</span> * AV_TIME_BASE;</span><br><span class="line">    <span class="comment">// 针对 flv 跟 mpeg 增加了探索时长 max_stream_analyze_duration</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;flv&quot;</span>))</span><br><span class="line">      max_stream_analyze_duration = <span class="number">90</span> * AV_TIME_BASE;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;mpeg&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;mpegts&quot;</span>))</span><br><span class="line">      max_stream_analyze_duration = <span class="number">7</span> * AV_TIME_BASE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// Try to just open decoders, in case this is enough to get parameters.</span></span><br><span class="line">    <span class="comment">// Also ensure that subtitle_header is properly set.</span></span><br><span class="line">    <span class="comment">// 在某些场景下，只需打开解码器，就能获取到编码层的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>) &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span> ||</span><br><span class="line">        st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (codec &amp;&amp; !avctx-&gt;codec)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(avctx, codec, options ? &amp;options[i] : &amp;thread_opt) &lt;</span><br><span class="line">            <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">av_log</span>(ic, AV_LOG_WARNING, <span class="string">&quot;Failed to open codec in %s\n&quot;</span>,</span><br><span class="line">                 __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">      <span class="built_in">av_dict_free</span>(&amp;thread_opt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> A new stream can be added there if no header in file</span></span><br><span class="line"><span class="comment">     * (AVFMTCTX_NOHEADER). */</span></span><br><span class="line">    <span class="comment">// 直接读取文件的数据</span></span><br><span class="line">    <span class="comment">//  其中调用demuxer的read_packet回调函数读取pkt，对于flv来说，这里创建流</span></span><br><span class="line">    ret = <span class="built_in">read_frame_internal</span>(ic, pkt1);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有设置-nobuffer就会先把pkt放到缓存的一个链表，后边读取的时候优先读取</span></span><br><span class="line">    <span class="keyword">if</span> (!(ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)) &#123;</span><br><span class="line">      ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;packet_buffer, pkt1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line"></span><br><span class="line">      pkt = &amp;si-&gt;packet_buffer.tail-&gt;pkt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pkt = pkt1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 在某些场景下，打开解码器还获取不到编码层参数，就需要尝试解码</span></span><br><span class="line">    <span class="built_in">try_decode_frame</span>(ic, st, pkt,</span><br><span class="line">                     (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">      <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line"></span><br><span class="line">    sti-&gt;codec_info_nb_frames++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="avformat-seek-file函数"><a href="#avformat-seek-file函数" class="headerlink" title="avformat_seek_file函数"></a>avformat_seek_file函数</h2><ol>
<li><p>想跳转到某个位置进行播放，比如5分钟的地方，如果直接用 av_read_frame不断读数据，读到第5分钟的AVPacket才开始处理，之前的AVPacket丢弃，会带来非常大的磁盘IO。可以使用avformat_seek_file。</p>
</li>
<li><p>接受一个打开的容器的AVFormatContext，对应的流索引stream_index，跳转的位置ts，跳转的最大最小范围int64_t min_ts和max_ts，flags标志位。标志位能指定按照字节大小、帧数大小、是否是非关键帧位置，以及往ts前还是后找关键帧。快进和后退的时候，可以通过调整min_ts和max_ts的范围比ts大和小。</p>
</li>
<li>默认按照时间seek，stream_index=-1，表示要对所有的流进行定位操作，比如多个流的之间保持同步，或者需要按照统一的时间基进行整体的定位操作。ts的时间基为AV_TIME_BASE(100000，1s分成100000份)，stream_index!=-1只需对特定的流进行seek，用对应流的时间基。</li>
</ol>
<h2 id="add-input-streams函数"><a href="#add-input-streams函数" class="headerlink" title="add_input_streams函数"></a>add_input_streams函数</h2><ol>
<li><p>遍历一个输入文件所有的流，<strong>给Demuxer中输入文件InputFile f的输入流InputStream ** streams 分配内存扩容</strong>，代码逻辑为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem) &#123;</span><br><span class="line">  void **tab;</span><br><span class="line">  memcpy(&amp;tab, tab_ptr, sizeof(tab));</span><br><span class="line">  FF_DYNARRAY_ADD(</span><br><span class="line">      INT_MAX, sizeof(*tab), tab, *nb_ptr,</span><br><span class="line">      &#123;</span><br><span class="line">        tab[*nb_ptr] = elem;</span><br><span class="line">        memcpy(tab_ptr, &amp;tab, sizeof(tab));</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; return AVERROR(ENOMEM); &#125;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">#define ALLOC_ARRAY_ELEM(array, nb_elems)                                      \</span><br><span class="line">  allocate_array_elem(&amp;array, sizeof(*array[0]), &amp;nb_elems)</span><br><span class="line">void *allocate_array_elem(void *ptr, size_t elem_size, int *nb_elems) &#123;</span><br><span class="line">  void *new_elem;</span><br><span class="line">  if (!(new_elem = av_mallocz(elem_size)) ||</span><br><span class="line">      av_dynarray_add_nofree(ptr, nb_elems, new_elem) &lt; 0)</span><br><span class="line">    report_and_exit(AVERROR(ENOMEM));</span><br><span class="line">  return new_elem;</span><br><span class="line">&#125;</span><br><span class="line">// f-&gt;streams是InputStream **streams变量，nb_elems是int类型</span><br><span class="line">ist = ALLOC_ARRAY_ELEM(f-&gt;streams, f-&gt;nb_streams);</span><br></pre></td></tr></table></figure>
<p>上述过程变量的传递：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ALLOC_ARRAY_ELEM</span></span><br><span class="line">array = InputStream **streams;</span><br><span class="line">nb_elems = <span class="type">int</span> nb_streams;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate_array_elem</span></span><br><span class="line"><span class="type">void</span> *ptr = &amp;array = &amp;(InputStream **streams),ptr:InputStream ***</span><br><span class="line"><span class="type">size_t</span> elem_size = <span class="built_in">sizeof</span>(*array[<span class="number">0</span>]) = <span class="built_in">sizeof</span>(InputStream)</span><br><span class="line"><span class="type">int</span> *nb_elems = &amp;nb_elems = &amp;(<span class="type">int</span> nb_streams)</span><br></pre></td></tr></table></figure>
<p>av_mallocz申请的elem_size大小是InputStream的大小。allocate_array_elem申请了内存，av_dynarray_add_nofree给数组进行扩容，拷贝tab_ptr给，tab也指向动态数组，然后利用拷贝的tab进行扩容，扩容后再更新_tab_ptr指向新的tab指针指向位置。</p>
</li>
<li><p>初始化一个输出流参数的基本信息，<strong>choose_decoder选择解码器</strong>，filter_codec_opts把OptionsContext的解码器参数赋值给 ist-&gt;decoder_opt。<strong>avcodec_alloc_context3根据ist-&gt;AVCodec申请解码器实例</strong>，通过avcodec_parameters_to_context把输入流的得到的AVCodecParameters赋值给解码器上下文实例ist-&gt;dec_ctx。<strong>av_frame_alloc和av_packet_alloc分别给解码帧decoded_frame和读取的pkt分配内存。</strong></p>
</li>
<li>根据音视频等不同的数据流分别对解码器上下文AVCodecContext ist-&gt;dec_ctx进行不同的修改，<strong>avcodec_parameters_alloc给输入流的AVCodecParameters ist-&gt;par解码器参数申请内存</strong>，并avcodec_parameters_from_context从解码器上下文AVCodecContext ist-&gt;dec_ctx复制信息给解码参数AVCodecParameters ist-&gt;par。因为<strong>AVCodecContext解码器上下文的参数可能发生改变。</strong></li>
<li>add_input_streams初始化了每个流的解码器实例，并且使用掉命令行的解码器参数，<strong>choose_decoder选择了解码器，但不会打开解码器实例。真正打开解码器是在 transcode_init时候的init_input_stream函数。</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">add_input_streams</span><span class="params">(<span class="type">const</span> OptionsContext *o, Demuxer *d)</span> </span>&#123;</span><br><span class="line">  InputFile *f = &amp;d-&gt;f;</span><br><span class="line">  AVFormatContext *ic = f-&gt;ctx;</span><br><span class="line">  <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历一个文件所有的流</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">    AVStream *st = ic-&gt;streams[i];</span><br><span class="line">    AVCodecParameters *par = st-&gt;codecpar; <span class="comment">// 解码器参数</span></span><br><span class="line">    InputStream *ist;                      <span class="comment">// 输入流信息</span></span><br><span class="line">    <span class="type">char</span> *framerate = <span class="literal">NULL</span>, *hwaccel_device = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hwaccel = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *hwaccel_output_format = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *codec_tag = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *next;</span><br><span class="line">    <span class="type">char</span> *discard_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> AVClass *cc = <span class="built_in">avcodec_get_class</span>();</span><br><span class="line">    <span class="type">const</span> AVOption *discard_opt =</span><br><span class="line">        <span class="built_in">av_opt_find</span>(&amp;cc, <span class="string">&quot;skip_frame&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, AV_OPT_SEARCH_FAKE_OBJ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    类似于全局的input_files以及 InputFile中的InputStream **streams，</span></span><br><span class="line"><span class="comment">    都是指针数组，都是二级</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 给输入流分配内存空间，后边修改属性</span></span><br><span class="line">    <span class="comment">// InputStream **streams, int nb_streams</span></span><br><span class="line"></span><br><span class="line">    ist = <span class="built_in">ALLOC_ARRAY_ELEM</span>(f-&gt;streams, f-&gt;nb_streams);</span><br><span class="line">    ist-&gt;st = st;</span><br><span class="line">    ist-&gt;file_index = f-&gt;index; <span class="comment">// 绑定对应输入文件</span></span><br><span class="line">    ist-&gt;discard = <span class="number">1</span>;</span><br><span class="line">    st-&gt;discard = AVDISCARD_ALL; <span class="comment">// 默认丢弃所有帧</span></span><br><span class="line">    ist-&gt;nb_samples = <span class="number">0</span>;</span><br><span class="line">    ist-&gt;first_dts = AV_NOPTS_VALUE;</span><br><span class="line">    ist-&gt;min_pts = INT64_MAX;</span><br><span class="line">    ist-&gt;max_pts = INT64_MIN;</span><br><span class="line"></span><br><span class="line">    ist-&gt;ts_scale = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">MATCH_PER_STREAM_OPT</span>(ts_scale, dbl, ist-&gt;ts_scale, ic, st);</span><br><span class="line"></span><br><span class="line">    ist-&gt;autorotate = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">MATCH_PER_STREAM_OPT</span>(autorotate, i, ist-&gt;autorotate, ic, st);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MATCH_PER_STREAM_OPT</span>(codec_tags, str, codec_tag, ic, st);</span><br><span class="line">    <span class="keyword">if</span> (codec_tag) &#123;</span><br><span class="line">      <span class="type">uint32_t</span> tag = <span class="built_in">strtol</span>(codec_tag, &amp;next, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (*next)</span><br><span class="line">        tag = <span class="built_in">AV_RL32</span>(codec_tag);</span><br><span class="line">      st-&gt;codecpar-&gt;codec_tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">      <span class="built_in">add_display_matrix_to_stream</span>(o, ic, st);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(hwaccels, str, hwaccel, ic, st);</span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(hwaccel_output_formats, str, hwaccel_output_format,</span><br><span class="line">                           ic, st);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hwaccel_output_format &amp;&amp; hwaccel &amp;&amp; !<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;cuvid&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">               <span class="string">&quot;WARNING: defaulting hwaccel_output_format to cuda for &quot;</span></span><br><span class="line">               <span class="string">&quot;compatibility &quot;</span></span><br><span class="line">               <span class="string">&quot;with old commandlines. This behaviour is DEPRECATED and will &quot;</span></span><br><span class="line">               <span class="string">&quot;be removed &quot;</span></span><br><span class="line">               <span class="string">&quot;in the future. Please explicitly set \&quot;-hwaccel_output_format &quot;</span></span><br><span class="line">               <span class="string">&quot;cuda\&quot;.\n&quot;</span>);</span><br><span class="line">        ist-&gt;hwaccel_output_format = AV_PIX_FMT_CUDA;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hwaccel_output_format &amp;&amp; hwaccel &amp;&amp; !<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;qsv&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">               <span class="string">&quot;WARNING: defaulting hwaccel_output_format to qsv for &quot;</span></span><br><span class="line">               <span class="string">&quot;compatibility &quot;</span></span><br><span class="line">               <span class="string">&quot;with old commandlines. This behaviour is DEPRECATED and will &quot;</span></span><br><span class="line">               <span class="string">&quot;be removed &quot;</span></span><br><span class="line">               <span class="string">&quot;in the future. Please explicitly set \&quot;-hwaccel_output_format &quot;</span></span><br><span class="line">               <span class="string">&quot;qsv\&quot;.\n&quot;</span>);</span><br><span class="line">        ist-&gt;hwaccel_output_format = AV_PIX_FMT_QSV;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hwaccel_output_format &amp;&amp; hwaccel &amp;&amp;</span><br><span class="line">                 !<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;mediacodec&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// There is no real AVHWFrameContext implementation. Set</span></span><br><span class="line">        <span class="comment">// hwaccel_output_format to avoid av_hwframe_transfer_data error.</span></span><br><span class="line">        ist-&gt;hwaccel_output_format = AV_PIX_FMT_MEDIACODEC;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hwaccel_output_format) &#123;</span><br><span class="line">        ist-&gt;hwaccel_output_format = <span class="built_in">av_get_pix_fmt</span>(hwaccel_output_format);</span><br><span class="line">        <span class="keyword">if</span> (ist-&gt;hwaccel_output_format == AV_PIX_FMT_NONE) &#123;</span><br><span class="line">          <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL,</span><br><span class="line">                 <span class="string">&quot;Unrecognised hwaccel output &quot;</span></span><br><span class="line">                 <span class="string">&quot;format: %s&quot;</span>,</span><br><span class="line">                 hwaccel_output_format);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ist-&gt;hwaccel_output_format = AV_PIX_FMT_NONE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hwaccel) &#123;</span><br><span class="line">        <span class="comment">// The NVDEC hwaccels use a CUDA device, so remap the name here.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;nvdec&quot;</span>) || !<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;cuvid&quot;</span>))</span><br><span class="line">          hwaccel = <span class="string">&quot;cuda&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;none&quot;</span>))</span><br><span class="line">          ist-&gt;hwaccel_id = HWACCEL_NONE;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(hwaccel, <span class="string">&quot;auto&quot;</span>))</span><br><span class="line">          ist-&gt;hwaccel_id = HWACCEL_AUTO;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">enum</span> AVHWDeviceType type = <span class="built_in">av_hwdevice_find_type_by_name</span>(hwaccel);</span><br><span class="line">          <span class="keyword">if</span> (type != AV_HWDEVICE_TYPE_NONE) &#123;</span><br><span class="line">            ist-&gt;hwaccel_id = HWACCEL_GENERIC;</span><br><span class="line">            ist-&gt;hwaccel_device_type = type;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!ist-&gt;hwaccel_id) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Unrecognized hwaccel: %s.\n&quot;</span>, hwaccel);</span><br><span class="line">            <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Supported hwaccels: &quot;</span>);</span><br><span class="line">            type = AV_HWDEVICE_TYPE_NONE;</span><br><span class="line">            <span class="keyword">while</span> ((type = <span class="built_in">av_hwdevice_iterate_types</span>(type)) !=</span><br><span class="line">                   AV_HWDEVICE_TYPE_NONE)</span><br><span class="line">              <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;%s &quot;</span>,</span><br><span class="line">                     <span class="built_in">av_hwdevice_get_type_name</span>(type));</span><br><span class="line">            <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(hwaccel_devices, str, hwaccel_device, ic, st);</span><br><span class="line">      <span class="keyword">if</span> (hwaccel_device) &#123;</span><br><span class="line">        ist-&gt;hwaccel_device = <span class="built_in">av_strdup</span>(hwaccel_device);</span><br><span class="line">        <span class="keyword">if</span> (!ist-&gt;hwaccel_device)</span><br><span class="line">          <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ist-&gt;hwaccel_pix_fmt = AV_PIX_FMT_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 OptionsContext 里面的解码器参数赋值给 ist-&gt;decoder_opts，选择解码器</span></span><br><span class="line">    ist-&gt;dec =</span><br><span class="line">        <span class="built_in">choose_decoder</span>(o, ic, st, ist-&gt;hwaccel_id, ist-&gt;hwaccel_device_type);</span><br><span class="line">    ist-&gt;decoder_opts = <span class="built_in">filter_codec_opts</span>(</span><br><span class="line">        o-&gt;g-&gt;codec_opts, ist-&gt;st-&gt;codecpar-&gt;codec_id, ic, st, ist-&gt;dec);</span><br><span class="line"></span><br><span class="line">    ist-&gt;reinit_filters = <span class="number">-1</span>; <span class="comment">// 默认不需要重新初始化输入滤镜</span></span><br><span class="line">    <span class="built_in">MATCH_PER_STREAM_OPT</span>(reinit_filters, i, ist-&gt;reinit_filters, ic, st);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MATCH_PER_STREAM_OPT</span>(discard, str, discard_str, ic, st);</span><br><span class="line">    ist-&gt;user_set_discard = AVDISCARD_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o-&gt;video_disable &amp;&amp;</span><br><span class="line">         ist-&gt;st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) ||</span><br><span class="line">        (o-&gt;audio_disable &amp;&amp;</span><br><span class="line">         ist-&gt;st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) ||</span><br><span class="line">        (o-&gt;subtitle_disable &amp;&amp;</span><br><span class="line">         ist-&gt;st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) ||</span><br><span class="line">        (o-&gt;data_disable &amp;&amp; ist-&gt;st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_DATA))</span><br><span class="line">      ist-&gt;user_set_discard = AVDISCARD_ALL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discard_str &amp;&amp; <span class="built_in">av_opt_eval_int</span>(&amp;cc, discard_opt, discard_str,</span><br><span class="line">                                       &amp;ist-&gt;user_set_discard) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error parsing discard %s.\n&quot;</span>, discard_str);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ist-&gt;filter_in_rescale_delta_last = AV_NOPTS_VALUE;</span><br><span class="line">    ist-&gt;prev_pkt_pts = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配解码器上下文</span></span><br><span class="line">    ist-&gt;dec_ctx = <span class="built_in">avcodec_alloc_context3</span>(ist-&gt;dec);</span><br><span class="line">    <span class="keyword">if</span> (!ist-&gt;dec_ctx)</span><br><span class="line">      <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码参数AVCodecParameters *par = st-&gt;codecpar初始化解码器上下文</span></span><br><span class="line">    ret = <span class="built_in">avcodec_parameters_to_context</span>(ist-&gt;dec_ctx, par);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error initializing the decoder context.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配decoded frame</span></span><br><span class="line">    ist-&gt;decoded_frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ist-&gt;decoded_frame)</span><br><span class="line">      <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line">    <span class="comment">// 分配packet</span></span><br><span class="line">    ist-&gt;pkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ist-&gt;pkt)</span><br><span class="line">      <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;bitexact)</span><br><span class="line">      ist-&gt;dec_ctx-&gt;flags |= AV_CODEC_FLAG_BITEXACT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (par-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      <span class="comment">// avformat_find_stream_info() doesn&#x27;t set this for us anymore.</span></span><br><span class="line">      ist-&gt;dec_ctx-&gt;framerate = st-&gt;avg_frame_rate; <span class="comment">// 设置解码器帧率</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(frame_rates, str, framerate, ic, st);</span><br><span class="line">      <span class="keyword">if</span> (framerate &amp;&amp; <span class="built_in">av_parse_video_rate</span>(&amp;ist-&gt;framerate, framerate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error parsing framerate %s.\n&quot;</span>, framerate);</span><br><span class="line">        <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ist-&gt;top_field_first = <span class="number">-1</span>;</span><br><span class="line">      <span class="comment">// 匹配设置的帧率</span></span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(top_field_first, i, ist-&gt;top_field_first, ic, st);</span><br><span class="line">      <span class="comment">// 猜测帧率</span></span><br><span class="line">      ist-&gt;framerate_guessed = <span class="built_in">av_guess_frame_rate</span>(ic, st, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      ist-&gt;guess_layout_max = INT_MAX;</span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(guess_layout_max, i, ist-&gt;guess_layout_max, ic, st);</span><br><span class="line">      <span class="built_in">guess_input_channel_layout</span>(ist);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_DATA:</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE: &#123;</span><br><span class="line">      <span class="type">char</span> *canvas_size = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(fix_sub_duration, i, ist-&gt;fix_sub_duration, ic, st);</span><br><span class="line">      <span class="built_in">MATCH_PER_STREAM_OPT</span>(canvas_sizes, str, canvas_size, ic, st);</span><br><span class="line">      <span class="keyword">if</span> (canvas_size &amp;&amp;</span><br><span class="line">          <span class="built_in">av_parse_video_size</span>(&amp;ist-&gt;dec_ctx-&gt;width, &amp;ist-&gt;dec_ctx-&gt;height,</span><br><span class="line">                              canvas_size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Invalid canvas size: %s.\n&quot;</span>, canvas_size);</span><br><span class="line">        <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_ATTACHMENT:</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_UNKNOWN:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配编解码参数</span></span><br><span class="line">    ist-&gt;par = <span class="built_in">avcodec_parameters_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ist-&gt;par)</span><br><span class="line">      <span class="built_in">report_and_exit</span>(<span class="built_in">AVERROR</span>(ENOMEM));</span><br><span class="line">    <span class="comment">// 从解码器上下文生成编解码参数</span></span><br><span class="line">    ret = <span class="built_in">avcodec_parameters_from_context</span>(ist-&gt;par, ist-&gt;dec_ctx);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Error initializing the decoder context.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打开输入文件总结"><a href="#打开输入文件总结" class="headerlink" title="打开输入文件总结"></a>打开输入文件总结</h1><ol>
<li><p>open_files(ifile_open)函数遍历所有的输入文件，parse_optgroup函数把每个文件的OptionGroup解析到OptionsContext中，然后通过ifile_open函数打开输入文件并将OptionsContext复制到对应的文件参数中。</p>
</li>
<li><p>ifile_open函数对每个输入文件进行处理。avformat_alloc_context首先给AVFormatContext分配内存，allocate_array_elem函数给全局输入文件结构体指针数组InputFile **input_files分配内存，申请的大小是Demuxer大小（这里为什么不是InputFile大小）并将AVFormatContext赋值给了Demuxer-&gt;InputFile中的参数。ifile_open函数完成了把输入文件放到全局的input_files数组。</p>
</li>
<li><p>add_input_streams函数遍历输入文件中的每个流进行处理。ALLOC_ARRAY_ELEM给输入InputFile结构体中的InputStream **streams分配内存扩容，然后设置对应的输入流AVStream。choose_decoder选择了对应的解码器，但真正打开解码器是在 transcode_init时候的init_input_stream函数。avcodec_alloc_context3函数给每个输入流的AVCodecContext分配内存，av_frame_alloc和av_packet_alloc给解码帧和读取的pkt分配内存。avcodec_parameters_alloc给解码器参数AVCodecParameters分配内存。add_input_streams函数对全局的input_files数组中的每个InputFile中的每个流的进行了相关的内存分配和参数初始化。</p>
</li>
<li><p>到这里，完成了所有输入文件的读取以及初始化操作。</p>
</li>
</ol>

              </div>
              
                <section class="post-copyright">
                  
                    <p class="copyright-item">
                      <span>Author:</span>
                      <span>lly</span>
                    </p>
                    
                      
                        <p class="copyright-item">
                          <span>Permalink:</span>
                          <span><a href="https://charstr.github.io/2024/04/05/FFmpeg%E6%89%93%E5%BC%80%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/">https://charstr.github.io/2024/04/05/FFmpeg%E6%89%93%E5%BC%80%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</a></span>
                        </p>
                        
                          
                            <p class="copyright-item">
                              <span>License:</span>
                              <span>Copyright (c) 2024 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                            </p>
                            
                              

                </section>
                
                  <section class="post-tags">
                    <div>
                      <span>Tag(s):</span>
                      <span class="tag">
                        
                          
                            <a href="/tags/FFmpeg/"># FFmpeg</a>
                            
                              
                      </span>
                    </div>
                    <div>
                      <a href="javascript:window.history.back();">back</a>
                      <span>· </span>
                      <a href="/">home</a>
                    </div>
                  </section>
                  <section class="post-nav">
                    
                      <a class="prev" rel="prev" href="/2024/04/07/FFmpeg%E6%89%93%E5%BC%80%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6/">FFmpeg打开输出文件</a>
                      
                        
                          <a class="next" rel="next" href="/2024/04/02/FFmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/">FFmpeg命令行参数解析</a>
                          
                  </section>


            </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lly | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>